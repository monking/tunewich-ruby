#!/usr/bin/env ruby

require "io/console" # STDIN.getch
require "open-uri" # URI
require "optparse" # OptionParser
require "json" # JSON
require "digest" # Digest
require "rexml/document" # REXML::Document
require "rexml/xpath" # REXML::XPath

$logFilePath = nil
$clearLineCharacter = "\033[0K"
$disableWrapCharacter = "\033[?7l"
$enableWrapCharacter = "\033[?7h"
$tunewichWorkingDirectory = "#{ENV['HOME']}/.tunewich"
$hostname = ENV.has_key?('TENT_HOSTNAME') ? ENV['TENT_HOSTNAME'] : ENV['HOSTNAME']
$tunewichTmpDirectory = "#{$tunewichWorkingDirectory}/tmp"
$serviceConfigDir = "#{$tunewichWorkingDirectory}/config"
$uniqueId = 0

# Go to .tunewich directory so that any temp files are stored there.
Dir.mkdir $tunewichWorkingDirectory if not Dir.exist? $tunewichWorkingDirectory
Dir.chdir $tunewichWorkingDirectory

Dir.mkdir $tunewichTmpDirectory if not Dir.exist? $tunewichTmpDirectory

module Tunewich

	class Player

		PROMPT_TIMEOUT_RESPONSE = 'prompt_timeout_response'
		FILTER_HELP_1 = "Filter tracks by rules, in the format 'key=value,key=value 2,key'."
		FILTER_HELP_2 = "Available rules are: [min-,max-]rating=<#0-5>,title=<query>,tag=<tag>,chapters,last=<[[[DD:]HH:]MM:]SS>,ab."
		FILTER_HELP_3 = "Prepend an '-' to your rule to add it to exclude matches (e.g. '-tag=' vs 'tag=')."
		MODES = {
			'playing' => 'playing',
			'editing' => 'editing'
		}
		TAG_INPUT_SPLIT = /[,\s]+/
		PLAYER_APPLICATION = 'mplayer'
		MPLAYER_STDOUT_BUFFER_NAME = 'mplayer-stdout'
		MPLAYER_INPUT_FIFO_NAME = 'mplayer-input'
		UNAME = `uname`.chomp

		def initialize
			@userMode = Player::MODES['playing']
			@library = nil
			@libraryHash = nil
			@eventBindings = {}
			@eventBindingsIndex = {}
			@eventBindingGroups = {}
			@sessionID = Random.rand(1024)
			@currentTrack = nil
			@currentChapterIndex = nil
			@currentlySkippingChapter = nil
			@trackIndex = nil
			@tracks = []
			@configuredVerbosity = 0
			@verbosityBoost = 0
			@logVerbosity = nil
			@shouldShowPlaybackInfo = true
			@trackFilters = nil
			@trackExcludeFilters = nil
			@networkEnabled = true
			@playlistName = nil
			@volume = 25 # volume stored as state (the "intended" volume)
			@actualVolume = 25 # actual volume heard (change during fading, or changing track loudness)
			@volumeMultipliers = {}
			@bpmGlideDuration = 0
			@bpmGlideDelay = 0
			@enableDownload = false
			@preferredFileFormat = 'bestaudio'
			@playerTemporaryInteractiveCommands = []
			@playerOverrideCommands = []
			@currentPlayerTime = nil
			@currentPlayerIndex = 0
			@speedBeforeRampingOut = 1
			@inputThread = nil
			@playerApplicationThreads = []
			@forceStreaming = false
			@commandPrompts = []
			@commandHistory = []
			@commandHistoryIndex = nil
			@commandUserInput = nil
			@streamingServerType = nil
			@youtubeDLTrackTypes = ['youtube', 'soundcloud']
			@isPlayerPlaying = false
			@tempFiles = {}
			@loop = false
			@loopLimit = 0
			@breakLoop = false

			resetLastLoop

			getConfigFiles

			getEnvironmentConfig # library is loaded in here

			doOptionSecondaryActions parseOptions # library may be loaded again from a different place here

			trackTitleListFromLastSession = readTempFile('tracks', false)
			if trackTitleListFromLastSession && trackTitleListFromLastSession.length > 0
				whisper("Using tracks from last session.", 1)
				useTracks(getTracksFromTitleList(trackTitleListFromLastSession.strip.lines))
			end
			if @library["lastMarked"]
				markedTrack = @library["tracks"][@library["lastMarked"]]
				if markedTrack && markedTrack["mark"]
					if @tracks.include?(markedTrack)
						whisper("Returning to last marked track.", 1)
						@trackIndex = @tracks.index(markedTrack)
						@library.delete "lastMarked"
						writeLibraryToFile
					else
						whisper("A track was marked, but is not in the current queue. It will remain marked until it is played again.", 0)
					end
				end
			end

			if not @trackIndex
				if @shuffle && !@trackIndex
					shuffleIndex()
				else
					@trackIndex = 0
				end
			end

			bindOnce 'before_exit', Proc.new {
				if @services && @services.length > 0
					whisper("Exiting: killing #{@services.length} services", 2)
					@services.each { |thread| thread.kill if thread.alive? }
				else
					whisper("Exiting: no services running", 2)
				end
			}

			@volume = getMplayerConfigNumericProperty('volume')
			whisper("@volume: #{@volume}", 3)
			@actualVolume = @volume
			trigger 'volume_change'
			@speed = getMplayerConfigNumericProperty('speed', 1.0)
			whisper("@speed: #{@speed}", 3)
			@currentSpeed = @speed
			trigger 'speed_change'

			listenForExternalCommands
		end

		def cleanup
			@playerApplicationThreads.each { |thread|
				thread.kill if thread && thread.alive?
			}
			@tempFiles.each { |path, nonsense|
				File.delete(path) if File.exist?(path)
			}
		end

		def getUniqueId
			$uniqueId = $uniqueId + 1
		end

		def sendPlayerCommand command, playerIndex = nil
			playerIndex ||= @currentPlayerIndex
			if playerIndex == @currentPlayerIndex
				if /play/.match command
					@isPlayerPlaying = true
				elsif /pause/.match command
					@isPlayerPlaying = false
				end
			end
			putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{playerIndex}", "#{command}\n"
		end

		def togglePlay
			sendPlayerCommand @isPlayerPlaying ? 'pause' : 'play'
		end

		def interactivePlayback
			bindingGroupName = 'interactivePlayback'

			shouldExitPlayerLoop = false
			bindOnce 'before_exit', Proc.new {
				whisper "before_exist: quitting mplayer", 3
				shouldExitPlayerLoop = true
				sendPlayerCommand "q"
			}, bindingGroupName

			if @tracks && @tracks.length > 0
				titleBlock "Playing #{@tracks.length} tracks", '#'
			else
				useEntireLibrary
			end

			# TODO: 1gG4j1
			playerOutput = nil

			interactiveCommands = getInteractiveCommands [@userMode], bindingGroupName

			# chaptersNotPlayed = []

			while not playerOutput or playerOutput[:exit] do
				if @trackIndex && @tracks[@trackIndex]
					previousTrack = @currentTrack
					@currentTrack = matchExistingLibraryTrack @tracks[@trackIndex]

					handleTrackChangeDuringPlayback previousTrack, @currentTrack if previousTrack

					titleBlock "[#{@trackIndex + 1}] - #{@currentTrack['title']}"

					nextTrack() # call nextTrack after @trackIndex is announced, but before play, so that the user can see which track will come next.

					if @updateAllPlayedTrackInfo && @networkEnabled
						printRepeat "Getting latest track information..."
						updateTrackInfo @currentTrack
					end

					fileExists = trackFileExists? @currentTrack

					if !fileExists && !@networkEnabled
						next
					end

					playerOutput = play @currentTrack, interactiveCommands

					trackDurationInSeconds = getSecondsFromDurationString(@currentTrack['duration'])

					if trackDurationInSeconds && !@currentTrack['unattached']
						loadLibrary
						@currentTrack = matchExistingLibraryTrack(@currentTrack)
						@currentTrack['playTime'] ||= 0
						@currentTrack['playTime'] += playerOutput[:playTime].to_i
						minimumPlayTime = [30, trackDurationInSeconds - 10].min
						if playerOutput[:playTime] >= minimumPlayTime
							@currentTrack['lastPlayed'] = playerOutput[:endTime].to_i
							@currentTrack['playCount'] ||= 0
							@currentTrack['playCount'] += 1
							whisper("listened for #{playerOutput[:playTime]} (>= min #{minimumPlayTime}): bumping play count to #{@currentTrack['playCount']}", 1)
						else
							@currentTrack['skipCount'] ||= 0
							@currentTrack['skipCount'] += 1
							whisper("listened for #{playerOutput[:playTime]} (< min #{minimumPlayTime}): bumping SKIP count to #{@currentTrack['skipCount']}", 1)
						end
						writeLibraryToFile
					end
				else
					whisper("Empty tracklist", 3)
					emptyAction = Proc.new { |input| false } # break command loop after any non-command input
					commandPrompt "empty", interactiveCommands, emptyAction
				end

				if shouldExitPlayerLoop
					whisper("Exiting player loop", 3)
					break
				end
			end

			unbindGroup bindingGroupName
		end

		def handleTrackChangeDuringPlayback trackA, trackB
			if (@bpmGlideDelay > 0 || @bpmGlideDuration > 0) && trackA.has_key?('bpm') && trackB.has_key?('bpm')
				whisper("gliding bpm for #{@bpmGlideDuration} seconds (after #{@bpmGlideDelay} seconds) seconds between #{trackA['bpm']} and #{trackB['bpm']} (adjust for current speed #{@speed}).", 2)
				initialSpeed = @speed
				# TODO: ramp to the nearest multiple: e.g. if going from 60bpm to 120, do nothing. If going from 60 to 140, ramp to 70; from 140 to 60, ramp to 120.
				# This is already implemented in getSoftBPMRatio
				@speed = @speed * trackA['bpm'] / trackB['bpm']
				bindOnce 'time_update', Proc.new {
					Thread.new {
						sleep @bpmGlideDelay if @bpmGlideDelay > 0
						rampSpeed initialSpeed, @bpmGlideDuration, @currentPlayerIndex
					}
				}
			end
		end

		def	interactiveEdit
			commandPrompt @userMode, getInteractiveCommands([@userMode], 'editingModeBindingGroup')
		end

		def trigger eventName, data = nil
			if @eventBindings.has_key? eventName
				whisper("trigger #{eventName}, #{@eventBindings[eventName].length} handlers bound", 5)
				@eventBindings[eventName].each { |handlerId|
					whisper("event #{eventName}, calling handler handler #{handlerId}", 5)
					result = @eventBindingsIndex[handlerId][:handler].call(data)
					break if result == false
				}
			else
				whisper("trigger #{eventName} (no handlers bound)", 5)
			end
		end

		def bind eventName, handlerProc, handlerGroup = nil, jumpQueue = false
			handlerId = getUniqueId
			@eventBindingsIndex[handlerId] = {
				:eventName => eventName,
				:handler => handlerProc,
				:id => handlerId,
				:group => handlerGroup
			}

			@eventBindings[eventName] ||= []
			if jumpQueue
				@eventBindings[eventName].unshift << handlerId
			else
				@eventBindings[eventName] << handlerId
			end

			if handlerGroup
				@eventBindingGroups[handlerGroup] ||= []
				@eventBindingGroups[handlerGroup] << handlerId
			end

			whisper("bind, #{eventName}, #{handlerGroup}, #{handlerId}", 5)

			handlerId
		end

		def bindOnce eventName, handlerProc, handlerGroup = nil
			handlerId = nil
			selfRemovingHandlerProc = Proc.new { |data|
				unbind handlerId
				handlerProc.call data
			}
			handlerId = bind eventName, selfRemovingHandlerProc, handlerGroup
			handlerId
		end

		def unbind handlerId
			if @eventBindingsIndex.has_key? handlerId
				@eventBindings[@eventBindingsIndex[handlerId][:eventName]].delete_if { |id| id == handlerId }
				if @eventBindingsIndex[handlerId][:group]
					@eventBindingGroups[@eventBindingsIndex[handlerId][:group]].delete_if { |id| id == handlerId }
				end
				@eventBindingsIndex.delete handlerId
			end
		end

		def unbindGroup groupName
			if @eventBindingGroups.has_key? groupName
				whisper("Unbinding: #{@eventBindingGroups[groupName].length} handlers in binding group '#{groupName}'", 3)
				@eventBindingGroups[groupName].each { |handlerId| unbind handlerId }
				@eventBindingGroups.delete groupName
			else
				whisper("Unbinding: No bindings assigned to group '#{groupName}'", 3)
			end
		end

		def kill
			trigger 'before_exit'
			cleanup
		end

		private

		def readCharacter
			# I think I ripped this from here: https://gist.github.com/acook/4190379
			STDIN.echo = false
			STDIN.raw!
			char = STDIN.getc.chr
			if char == "\e" then
				char << STDIN.read_nonblock(3) rescue nil
				char << STDIN.read_nonblock(2) rescue nil
			end
		ensure
			STDIN.echo = true
			STDIN.cooked!
			return char
		end

		def enablePlaybackInfo
			@shouldShowPlaybackInfo = true
			whisper("DISABLING realtime playback info", 3)
		end

		def disablePlaybackInfo
			@shouldShowPlaybackInfo = false
			whisper("ENABLING realtime playback info", 3)
		end

		def putsRealtime message
			if @shouldShowPlaybackInfo
				print "\n#{message}\n"
			else
				puts message
			end
		end

		def whisper message, verbosity = 1
			# 0: basically like puts, with the benefit of optional logging
			# 1: verbose user output
			# 2: very verbose user output
			# 3: errors
			# 4: debug
			formattedMessage = "	#{"-" * verbosity} #{message}"
			effectiveVerbosity = verbosity - @verbosityBoost
			if @configuredVerbosity >= effectiveVerbosity
				if @shouldShowPlaybackInfo
					STDERR.print "#{formattedMessage}\n"
				else
					STDERR.puts formattedMessage
				end
			end
			if $logFilePath && (!@logVerbosity || @logVerbosity >= effectiveVerbosity)
				open($logFilePath, 'a') { |f|
					f.puts "#{Time.now.to_f} #{formattedMessage}"
				}
			end
		end

		def getConfigFiles
			mplayerConfigFile = "#{$serviceConfigDir}/mplayer.options"

			if File.exist?(mplayerConfigFile)
				@playerOverrideCommands << File.read(mplayerConfigFile).chomp.strip.gsub(/[\r\n]+/, ' ')
			end
		end

		def getEnvironmentConfig
			if ENV.key? 'TUNEWICH_PLAYER_OPTS'
				@playerOverrideCommands << ENV['TUNEWICH_PLAYER_OPTS']
			end

			if ENV.key? 'TUNEWICH_DIR'
				setLibraryPath ENV['TUNEWICH_DIR']
			else
				whisper("Please add `export TUNEWICH_DIR=\"<path/to/your/music/directory>\"` to your ~/.profile or similar file.", 0)
			end

			# assume volume is not logarithmic for player on Mac
			@isVolumeAlreadyLogarithmic = !(UNAME == "Darwin")
		end

		def getSoftBPMRatio firstTrack, secondTrack
			# TODO: 1gG4Ve
			ratio = 1
			if not firstTrack.has_key? 'bpm'
				whisper("The first track being compared doesn't have BPM set.", 2)
			elsif secondTrack.has_key? 'bpm'
				whisper("The second track being compared doesn't have BPM set.", 2)
			else
				ratio = secondTrack['bpm'].to_f / firstTrack['bpm'].to_f
				if ratio >= 2.0
					ratio /= 2.0
				elsif ratio <= 0.5
					ratio *= 2.0
				end
			end
			ratio
		end

		def addChapter track, newChapter
			if not track['chapters']
				track['chapters'] = []
			end

			track['chapters'] << newChapter
			track['chapters'] = sortChapters track['chapters']
		end

		def editChapters chapters, emphasizeChapterIndex = nil
			formattedChapters = getFormattedChapterList chapters
			if emphasizeChapterIndex
				emphasisLine = "# ^ current chapter"
				formattedChapters.insert(emphasizeChapterIndex + 1, emphasisLine)
			end
			editedFormattedChapters = editListInVim formattedChapters
			editedChapters = editedFormattedChapters.map { |l|
				bits = l.match(/^\s*(skip)?\s*([0-9.:]+)\s+(.*?)( \(loop to "(.*)"\))?$/)
				#              /    1         2            3    4            5         /
				if bits
					chapter = {'time' => bits[2], 'text' => bits[3]}
					chapter['skip'] = true if bits[1] == 'skip'
					chapter['loop_target'] = bits[5] if bits[5]
					chapter
				else
					false
				end
			}
			editedChapters.keep_if { |c| c }
			whisper("from:\n#{JSON.pretty_generate(chapters)}\nto:\n#{JSON.pretty_generate(editedChapters)}", 3)
			editedChapters
		end

		def sortChapters chapters
			chapters.sort { |a, b|
				getSecondsFromDurationString(a['time']) <=> getSecondsFromDurationString(b['time'])
			}
		end

		def getInteractiveCommands modes = [], bindingGroupName

			trackTabComplete = Proc.new { |input|
				inputParts = input.match(/^([^\/]*)(.*)$/)

				if inputParts[1] && inputParts[1].length > 0
					begin
						trackTitlesAndIds = []
						@tracks.each { |t|
							trackTitlesAndIds << t['title'] if t.has_key?('title')
							trackTitlesAndIds << t['id']
						}
						guessTrackTitle = firstFuzzyMatchValue(inputParts[1], trackTitlesAndIds) if inputParts[1].length > 0
						if guessTrackTitle && guessTrackTitle.length > 0
							input = input.sub!(inputParts[1], guessTrackTitle)
						end
					rescue Exception => e
						whisper(e.message, 2) # XXX
					end
				end

				input
			}

			chapterInputPattern = /^([+-][0-9.]+ +)?([^\/]*)(.*)$/
			chapterTabComplete = Proc.new { |input|
				inputParts = input.match(chapterInputPattern)

				if @currentTrack.has_key?('chapters')
					if inputParts[2] && inputParts[2].length > 0
						chapterNames = @currentTrack['chapters'].map { |c| c['text'] }
						guessChapterName = firstFuzzyMatchValue(inputParts[2], chapterNames) if inputParts[2].length > 0
						if guessChapterName && guessChapterName.length > 0
							input = input.sub!(inputParts[2], guessChapterName)
						end
					else
						# TODO 1gzoGh: it'd be nice to put in a space if inputParts[1] (offset) is given
						putsRealtime getFormattedChapterList(@currentTrack['chapters']).join("\n")
					end
				else
					putsRealtime "No chapters on the current track."
				end

				input
			}

			tagTabComplete = Proc.new { |input|
				inputParts = input.match(/^([^\/]*)(.*)$/)

				if inputParts[1] && inputParts[1].length > 0
					lastInputToken = inputParts[1].sub(/^.* /, '')
					if lastInputToken[0] == '-'
						lastInputToken = lastInputToken[1,lastInputToken.length - 1]
					end
					tagNames = @library['tags'].keys
					@library['tags'].each { |tagName, tag|
						if tag.has_key? 'aliases'
							whisper("adding aliases for #{tagName} (#{tag['aliases'].length})")
							tagNames = tagNames + tag['aliases']
						end
					}
					guessTagName = firstFuzzyMatchValue(lastInputToken, tagNames) if lastInputToken.length > 0
					if guessTagName && guessTagName.length > 0
						input = input.sub!(Regexp.new("#{lastInputToken}$"), guessTagName)
					end
				end

				input
			}

			getToggledValueByInput = Proc.new { |value, input|
				if input && input.length > 0
					value = !!(input.match(/^(y(es)?|o(n|[^f]))/i))
				else
					value = !value
				end
				value
			}

			# TODO: 1gG4fU @refactor
			interactiveCommands = {
				'base' => {
					'wait' => {
						'description' => 'Wait for an event, or some number of seconds, to execute following chained commands. Events: chapter_change, play_start, play_end, fade_start, fade_end, speed_ramp_start, speed_ramp_end, download_success. You may use fuzzy substrings of the event names, e.g. "ch" will match "chapter_change", and "ple" will match "play_end".',
						'action' => Proc.new { |input, command|
							inputParts = input.match(/^([^\/]*)(.*)$/)

							if inputParts[2] && inputParts[2].length > 0
								output = {
									:chainedInput => inputParts[2]
								}

								waitEvent = nil
								waitInput = inputParts[1].chomp.strip
								if waitInput.length > 0
									if waitInput.match(/^[0-9:.]+\s*$/)
										waitTime = getSecondsFromDurationString waitInput
										whisper("sleeping for #{waitTime} seconds", 3)
										waitEvent = "timed_wait_in_player_#{@currentPlayerIndex}"
										Thread.new {
											sleep waitTime
											whisper("triggering #{waitEvent}", 3)
											trigger waitEvent
										}
									else
										waitEvent = firstFuzzyMatchValue waitInput.strip.downcase, command['args']
										if !waitEvent
											putsRealtime "Unknown event '#{waitInput}'. Not waiting. Available events: #{command['args'].join ', '}"
										end
									end
								else
									putsRealtime "The /wait command expects either a number of seconds, or an event name"
								end
								if waitEvent
									output[:bindChainToEvent] = waitEvent
									output[:bindingGroupName] = bindingGroupName
								end
							else
								putsRealtime "Put another command after /wait"
								output = nil
							end

							output
						},
						'args' => [
							'chapter_change',
							'play_start',
							'play_end',
							'fade_start',
							'fade_end',
							'speed_ramp_start',
							'speed_ramp_end',
							'download_success'
						]
					},
					'clear' => {
						'description' => 'Clear current tracklist',
						'action' => Proc.new { |input|
							@useTracks []
							{:chainedInput => input}
						}
					},
					'all' => {
						'description' => "Load entire library.",
						'action' => Proc.new { |input|
							useEntireLibrary
							{:chainedInput => input}
						}
					},
					'rate' => {
						'description' => "Rate this track + or -, or give it an explicit number.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							newRating = inputParts[1] if (inputParts[1].length > 0) && (inputParts[1].match(/^[+-]?[0-9]*/))
							oldRating = @currentTrack['rating']
							if newRating.length < 1
								putsRealtime "current rating: #{@currentTrack['rating']}"
							elsif newRating.match(/^[+-][0-9]*$/)
								if newRating.match(/^[+-]$/) # if it's simply "+" or "-", append "1"
									newRating = newRating + '1';
								end
								if not @currentTrack['rating']
									@currentTrack['rating'] = 0
								end
								@currentTrack['rating'] += newRating.to_i
							else
								@currentTrack['rating'] = newRating.to_i
							end
							if oldRating != @currentTrack['rating'] && !@currentTrack['unattached']
								loadLibrary
								addTrackToLibrary @currentTrack if @currentTrack['unattached']
								writeLibraryToFile
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'bpm' => {
						'description' => "Interactively set the beats-per-minute of the track. Do '/bpm 0' to remove (not chainable)",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							commitBPM = false

							if inputParts[1].length > 0
								bpm = inputParts[1].to_f
								commitBPM = true
							else
								bpm = getUserInputBPM
								if bpm
									commitBPM = true
									bpm /= @speed
								end
							end

							if commitBPM
								loadLibrary
								@currentTrack = matchExistingLibraryTrack @currentTrack
								if bpm == 0
									putsRealtime "Removing BPM from track."
									@currentTrack.delete 'bpm' if @currentTrack.has_key? 'bpm'
								else
									putsRealtime "Setting track BPM to #{bpm}."
									@currentTrack['bpm'] = bpm
								end
								writeLibraryToFile
							else
								putsRealtime "Canceling: leaving track BPM alone."
							end

							{:chainedInput => inputParts[2]}
						}
					},
					'tag' => {
						'description' => "Tag this track.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if !inputParts[1] || inputParts[1].length < 1
								putsRealtime "current tags: #{getTrackTags @currentTrack}"
							else
								tagsToAdd = inputParts[1].split(/[, ]+/)
								whisper("all tags given: #{tagsToAdd}", 2)
								tagsToRemove = []
								tagsToRemove.replace(tagsToAdd).keep_if {|name| name.match(/^-/)}
								tagsToRemove.map! {|name| name.sub(/^-/, '')}
								tagsToAdd.delete_if {|name| name.match(/^-/)}

								loadLibrary
								addTrackToTags @currentTrack, tagsToAdd
								removeTagsFromTrack @currentTrack, tagsToRemove
								addTrackToLibrary @currentTrack if @currentTrack['unattached']
								writeLibraryToFile
							end
							{:chainedInput => inputParts[2]}
						},
						'tabComplete' => tagTabComplete
					},
					'tagall' => {
						'description' => "Tag all tracks in the current tracklist.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1] && inputParts[1].length > 0
								tagsToAdd = inputParts[1].split(/[, ]+/)
								tagsToRemove = []
								tagsToAdd.each { |tagName|
									if /^-/.match tagName
										tagsToRemove << tagName.gsub(/^-/, '')
										tagsToAdd.delete tagName
									end
								}
								loadLibrary
								@tracks.each { |t|
									addTrackToTags t, tagsToAdd
									removeTagsFromTrack t, tagsToRemove
									addTrackToLibrary t if t['unattached']
								}
								writeLibraryToFile
							end
							{:chainedInput => inputParts[2]}
						},
						'tabComplete' => tagTabComplete
					},
					'list' => {
						'description' => "Load a playlist. (not chainable)",
						'action' => Proc.new { |input|
							# TODO: 1gG4gW
							whisper("playlistQuery: #{input}", 4)
							playlistNames = @library['playlists'].keys
							if input && input.length > 0
								match = firstFuzzyMatch input, playlistNames

								if match && match[:score] > 1 # FIXME 1gpaoq: what's a good baseline score for a playlist match?
									playlistName = match[:value]
								end
							end

							if playlistName
								usePlaylist playlistName, true
							else
								putsRealtime playlistNames.join "\n"
							end
							nil
						}
					},
					'tracks' => {
						'description' => 'Edit playing tracklist in Vim.',
						'action' => Proc.new { |input|
							editedTrackList = editTrackList @tracks
							# writeTitleChangesInTrackList editedTrackList # TODO 1gSlF1
							writeLibraryToFile
							useTracks editedTrackList, false
							putsRealtime "#{@tracks.length} tracks selected"
							{:chainedInput => input}
						}
					},
					'go' => {
						'description' => "Go to a track in the current list.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1] && inputParts[1].length > 0
								@trackIndex = findTrackIndex inputParts[1]
							end
							{:chainedInput => inputParts[2]}
						},
						'tabComplete' => trackTabComplete
					},
					'more' => {
						'description' => "Play all tracks on this video's page.",
						'action' => Proc.new { |input|
							if @currentTrack['type'] == 'youtube'
								disablePlaybackInfo
								tracks = getYouTubeTracksFromPage(@currentTrack['link'] || @currentTrack['src'])
								enablePlaybackInfo
							elsif @currentTrack['type'] == 'soundcloud'
								disablePlaybackInfo
								tracks = getSoundcloudRecommendations(@currentTrack['link'] || @currentTrack['src'])
								enablePlaybackInfo
							else
								putsRealtime "The /more currently only supports YouTube and Soundcloud tracks."
							end

							if tracks
								tracks.shift # remove the first track, which will be the main video on the page
								@trackIndex = @tracks.length
								@trackFilters = nil
								useTracks tracks, true # and set track index to the first
							end
							{:chainedInput => input}
						}
					},
					'info' => {
						'description' => "Show track info. Track is: without input = currently playing track; with '>' = the track that will play next; with numeric input = the track at that position in the track list; any other input = the track with the title that best matches that input",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							track = nil
							trackIndex = nil
							if inputParts[1] && inputParts[1].length > 0
								trackIndex = findTrackIndex(inputParts[1])
								track = @tracks[trackIndex] if trackIndex
							else
								# the user may have altered the track list, so that it no longer includes the currently playing track
								trackIndex = @trackIndex if @tracks[@trackIndex] === @currentTrack
								track = @currentTrack
							end

							if track
								alreadyHas = {
									:title => track.has_key?('title'),
									:duration => track.has_key?('duration'),
									:description => track.has_key?('description'),
									:bpm => track.has_key?('bpm')
								}
								tagNames = getTrackTags track

								outputMessageLines = []
								info = {}
								if !alreadyHas[:title] || !alreadyHas[:duration] || track['title'].length == 0
									if track['type'] === 'youtube'
										info = getYouTubeTrackInfo track['src']
									elsif track['type'] === 'soundcloud'
										info = getSoundcloudTrackInfo track['src']
									end
									updateTrackInfo track, info
								end
								outputMessageLines << "     title : #{track['title']}" if track.has_key? 'title'
								outputMessageLines << "      tags : #{tagNames.join ', '}" if tagNames.length > 0
								outputMessageLines << "sourceTags : #{info['sourceTags']}" if info && info.has_key?('sourceTags')
								outputMessageLines << "    rating : #{track['rating']}" if track['rating']
								outputMessageLines << "       bpm : #{track['bpm']}" if alreadyHas[:bpm]

								if track == @currentTrack
									timeMessage = "			time : #{getDurationStringFromSeconds @currentPlayerTime}"
									if !alreadyHas[:duration] || getSecondsFromDurationString(track['duration']) == 0
										durationResponseFromPlayer = getMplayerProperty('get_time_length', /^(ANS_LENGTH=)(.*?)(\?)?$/, 0.1)
										whisper("Got duration from player: '#{durationResponseFromPlayer}'", 2)
										if durationResponseFromPlayer
											track['duration'] = getDurationStringFromSeconds durationResponseFromPlayer.to_f
										end
									end
									timeMessage += " / #{track['duration']}"
									timeMessage += " (#{@speed}x)" if @speed != 1
									if @currentTrack.has_key? 'chapters'
										chapterIndex = getChapterIndexAtTime @currentTrack['chapters'], @currentPlayerTime
										if chapterIndex > -1
											timeMessage += "\n	 chapter : #{@currentTrack['chapters'][chapterIndex]['text']}"
										end
									end
									outputMessageLines << "#{timeMessage}"
								else
									outputMessageLines << "	duration : #{track['duration']}" if alreadyHas[:duration]
								end

								outputMessageLines << "downloaded : #{trackFileExists? track}"
								outputMessageLines << "#{track['description']}" if track.has_key?('description')
								if !info.has_key? 'link'
									info['link'] = track['link'] || track['src']
									if track['type'] === 'youtube'
										info['link'] = "http://youtu.be/#{track['src']}"
									end
								end
								outputMessageLines << "      link : #{info['link']}" if info

								outputMessageLines << "     index : #{trackIndex + 1}/#{@tracks.length}" if trackIndex
								outputMessageLines << "    volume : #{@actualVolume}/100" if track == @currentTrack

								if @configuredVerbosity > 1 && tagNames.length > 0
									whisper("about to loop through tagNames", 4)
									tagNames.each { |tagName|
										whisper("digging up ancestors of #{tagName}", 4)
										ancestorTags = getAncestorTagNames tagName
										whisper("ancestors of tag '#{tagName}': #{ancestorTags}", 1) if ancestorTags.length > 0
									}
								end

								outputMessageLines << "------------------------------"
								putsRealtime outputMessageLines.join "\n"
								notify outputMessageLines.join "\n"
							else
								putsRealtime "Cannot show info. No track found."
							end

							{:chainedInput => inputParts[2]}
						},
						'tabComplete' => trackTabComplete
					},
					'search' => {
						'description' => "<query> Search YouTube. (not chainable)",
						'action' => Proc.new { |input|
							if input and input.length > 1
								disablePlaybackInfo
								searchedTracks = searchYouTube(input)
								enablePlaybackInfo
								if searchedTracks
									@trackIndex = @tracks.length
									@trackFilters = nil
									useTracks searchedTracks
								end
							else
								putsRealtime "Enter a search term of at least 2 characters."
							end
							nil
						}
					},
					'shuffle' => {
						'description' => 'Toggle shuffle.',
						'args' => ['on', 'off'],
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							@shuffle = getToggledValueByInput.call(@shuffle, inputParts[1])
							shuffleIndex() if @shuffle
							putsRealtime "shuffle: #{@shuffle ? 'on' : 'off'}" if @configuredVerbosity >= 1
							{:chainedInput => inputParts[2]}
						}
					},
					'network' => {
						'description' => 'Toggle network enabled.',
						'args' => ['on', 'off'],
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							@networkEnabled = getToggledValueByInput.call(@networkEnabled, inputParts[1])
							putsRealtime "network: #{@networkEnabled ? 'on' : 'off'}"
							{:chainedInput => input}
						}
					},
					'download' => {
						'description' => "Download the current track for faster play in the future. Optional 'get' parameter prints the download shell command instead.",
						'args' => ['get'],
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)

							options = inputParts[1].length > 0 ? inputParts[1].split(/\s+/) : []

							track = @currentTrack
							shouldEchoCommand = false
							options.each { |option|
								case option
								when 'get'
									shouldEchoCommand = true
								else
									trackIndex = findTrackIndex option
									track = @tracks[trackIndex] if trackIndex
								end
							}

							if shouldEchoCommand
								if trackFileExists? track
									whisper(findTrackFiles(track)[0], 0)
								else
									putsRealtime getDownloadCommand track
								end
							else
								if trackFileExists? track
									putsRealtime "This file is already downloaded."
								else
									disablePlaybackInfo
									downloadTrack track
									enablePlaybackInfo
								end
							end

							{:chainedInput => inputParts[2]}
						}
						# 'tabComplete' => Proc.new { |input, command|
						# 	trackTabComplete input.sub(Regexp.new("^(#{command['args'].join('|')}) "), '')
						# }
						## FIXME ^: erroring
					},
					'add' => {
						'description' => 'Add a new track to the play queue. Input: <URL>[,<URL>,...] [<TAG>[,<TAG>,...]] -- URLs: comma-separated URLs or YouTube IDs (Some URLs will add multiple tracks, like a bandcamp album (or TODO: YouTube playliist); tags: comma-separated tags to add to the tracks.',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^ ]*?)( .*?)?( \/.*)?$/)
							urls = inputParts[1].split ',' if inputParts[1]
							tags = inputParts[2].split ',' if inputParts[2]
							whisper("urls: #{urls}\ntags: #{tags}", 3)
							if urls && urls.length > 0
								tracks = getTracksFromURLs urls
								putsRealtime "Adding #{tracks.length} tracks to queue. Playing next."
								if tracks.length && tags && tags.length > 0
									tracks.each { |t|
										addTrackToTags t, tags
									}
								end
								useTracks tracks

								@trackIndex = @tracks.length - tracks.length
							end
							{:chainedInput => inputParts[3]}
						}
					},
					'feed' => {
						'description' => 'Load a feed that has been saved with /add (currently only podcasts).',
						'action' => Proc.new { |input|
							inputParts = input.match(/^(.*?)( \/.*)?$/)

							feed = nil

							feedNames = @library['feeds'].map { |libraryFeed| libraryFeed['title'] }
							availableFeedsMessage = "Available feeds:\n	#{feedNames.join "\n	"}"
							if @library.has_key?('feeds') && @library['feeds'].length > 0
								if inputParts[1] && inputParts[1].length > 0
									match = firstFuzzyMatch inputParts[1], feedNames

									if match && match[:score] > 1
										feed = @library['feeds'][match[:index]]
										if !@networkEnabled
											putsRealtime "Found feed \"#{feed['title']}\". Network is disabled, not fetching feed contents."
										else
											putsRealtime "Loading podcast: \"#{feed['title']}\"..."
											feedTracks = loadPodcast feed['src']
											useTracks feedTracks if feedTracks
											putsRealtime "Loaded #{feedTracks.length} tracks. Playing oldest next."
											@trackIndex = @tracks.length - feedTracks.length
										end
									else
										putsRealtime "No matching feed found. #{availableFeedsMessage}"
									end
								else
									putsRealtime availableFeedsMessage
								end
							else
								putsRealtime "No feeds to choose from. Add one with /add."
								whisper("@library.keys: #{@library.keys}", 3)
							end

							{:chainedInput => inputParts[2]}
						}
					},
					'chapter' => {
						'description' => 'Skip to a chapter, or show chapter list. Input: [optional seconds offset], number or name of chapter; or "<" or ">" to go back or forward, multiples to go further.',
						'action' => Proc.new { |input|
							whisper("chapter command - input: #{input}", 3)
							inputParts = input.match(chapterInputPattern)
							if @currentTrack['chapters']
								if inputParts[2] && inputParts[2].length > 0
									chapterIndex = getChapterIndexByQuery inputParts[2], @currentTrack['chapters']
								else
									putsRealtime getFormattedChapterList(@currentTrack['chapters']).join("\n")
									# FIXME: promptForChapterIndex doesn't respond correctly to input, even ctrl+c
									# whisper("Prompting to select a chapter from the list...", 3)

									# chapterPromptMessage = nil

									# disablePlaybackInfo
									# chapterResponse = promptForChapterIndex @currentTrack['chapters'], interactiveCommands, chapterPromptMessage
									# enablePlaybackInfo
									# chapterIndex = chapterResponse[:index]
								end
							else
								putsRealtime "No chapters on the current track."
							end

							if chapterIndex && chapterIndex >= 0 && chapterIndex < @currentTrack['chapters'].length
								whisper("Done with chapter selection. Resulting chapter index: #{chapterIndex}", 3)
								chapter = @currentTrack['chapters'][chapterIndex]
								resetLastLoop
								seekSeconds = getSecondsFromDurationString chapter['time']
								seekOffset = inputParts[1].to_f
								seekSeconds += seekOffset if seekOffset
								seek seekSeconds, 0.5, 0.25
							elsif inputParts[2] && inputParts[2].length > 0
								putsRealtime "No chapter found."
							end

							{:chainedInput => inputParts[3]}
						},
						'tabComplete' => chapterTabComplete
					},
					'mkchapter' => {
						'description' => "Make a chapter, with a timestamp taken from the time you type '/' to begin the command (so that you can take your time composing the note without worrying about the moment passing). Input: name.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)

							loadLibrary
							@currentTrack = matchExistingLibraryTrack @currentTrack

							addChapter(
								@currentTrack,
								{
									'time' => getDurationStringFromSeconds(@commandinputStartPlayerTime),
									'text' => inputParts[1]
								}
							)

							writeLibraryToFile

							{:chainedInput => inputParts[2]}
						}
					},
					'rmchapter' => {
						'description' => "Remove the current chapter.",
						'action' => Proc.new { |input|
							# TODO 1gzTHg: take input to choose a chapter
							inputParts = input.match(/^([^\/]*)(.*)$/)
							chapterIndex = getChapterIndexAtTime @currentTrack['chapters'], @currentPlayerTime
							if chapterIndex > -1
								@currentTrack['chapters'].delete_at chapterIndex
								writeLibraryToFile
							end

							{:chainedInput => inputParts[2]}
						}
						# 'tabComplete' => chapterTabComplete # TODO 1gzTHg: take input to choose a chapter
					},
					'skipchapter' => {
						'description' => "Mark the current chapter as to be skipped every time.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							chapterIndex = getChapterIndexAtTime @currentTrack['chapters'], @currentPlayerTime
							if chapterIndex > -1
								@currentTrack['chapters'][chapterIndex]['skip'] = true
								writeLibraryToFile
								seekToNextPlayableChapterOrSkip @currentTrack['chapters'], @currentChapterIndex
							end

							{:chainedInput => inputParts[2]}
						}
					},
					'editchapters' => {
						'description' => "Edit all the chapters for the current track (using vim).",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							chapters = editChapters(@currentTrack['chapters'] || [], @currentChapterIndex)
							if chapters && chapters.length > 0
								@currentTrack['chapters'] = sortChapters chapters
							elsif @currentTrack['chapters'] && @currentTrack['chapters'].length > 0
								if confirm("Do you want to clear chapters from this track?")
									@currentTrack.delete 'chapters'
								end
							end
							writeLibraryToFile
							whisper("Chapter changes written to library file", 3)

							{:chainedInput => inputParts[2]}
						}
					},
					'filter' => {
						'description' => 'Edit filters.',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1] && inputParts[1].length > 0
								filters = parseOptionParameters inputParts[1]
							else
								filtersList = []
								filtersList += @trackFilters.map { |filter, rule| "#{filter}=#{rule}" } if @trackFilters
								filtersList += @trackExcludeFilters.map { |filter, rule| "-#{filter}=#{rule}" } if @trackExcludeFilters
								filterInstructions = []
								filterInstructions << Player::FILTER_HELP_1
								filterInstructions << Player::FILTER_HELP_2
								filterInstructions << Player::FILTER_HELP_3
								filterInstructions << '' # empty line
								filterInstructions << "Available tags: \n	#{listAllTagsWithCountsAndAliases.join "\n	"}"
								filterInstructions << "For music without words: -tag=verbal acapella visual live noise delete missing-source"
								instructions = filterInstructions.join "\n"
								filters = parseOptionParameters editListInVim(filtersList, instructions).join ','
							end

							@trackFilters = {}
							@trackExcludeFilters = {}
							filters.each { |name, filter|
								if name.match(/^-/)
									@trackExcludeFilters[name.sub(/^-/, '')] = filter
								else
									@trackFilters[name] = filter
								end
							}

							filterTracksOnDeck
							{:chainedInput => inputParts[2]}
						}
					},
					'exit' => {
						'description' => 'Exit tunewich when the current track finishes or is quit.',
						'action' => Proc.new { |input|
							kill
							{:chainedInput => input}
						}
					},
					'verbose' => {
						'description' => 'Set level of verbosity: -1 (silent) to 5 (extra debugging).',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1] && inputParts[1].length > 0
								@configuredVerbosity = inputParts[1].to_i
							end
							putsRealtime "verbosity set to #{@configuredVerbosity}"
							{:chainedInput => inputParts[2]}
						}
					},
					'format' => {
						'description' => 'Choose the file format to download/stream (e.g. "mp4"; default "m4a").',
						'args' => ['m4a', 'mp4', 'bestaudio', 'bestvideo', '[height=720]'],
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1].length > 0
								@preferredFileFormat = inputParts[1]
							else
								putsRealtime "preferred file format: #{@preferredFileFormat}"
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'commands' => {
						'description' => "List #{Player::PLAYER_APPLICATION} commands.",
						'action' => Proc.new { |input|
							system "#{Player::PLAYER_APPLICATION} -input cmdlist"
							{:chainedInput => input}
						}
					},
					'relatetags' => {
						'description' => '(USAGE: /relatetags A B...) Make tag A a child of tag(s) B...',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							success = false

							if inputParts[1].length > 0
								tags = inputParts[1].split(Player::TAG_INPUT_SPLIT)
								if tags.length == 2
									# TODO: optionally remove parent tags from all tracks which contain child tag
									success = relateTags tags
									if success
										writeLibraryToFile
									else
										putsRealtime "There was a problem with relating the tags. Your changes were not saved."
									end
								else
									putsRealtime "Please give exactly two tags."
								end
							end

							putsRealtime "Tags: \n	#{@library['tags'].keys.sort.join(", ")}" if not success
							{:chainedInput => inputParts[2]}
						},
						'tabComplete' => tagTabComplete
					},
					'jointag' => {
						'description' => '(USAGE: /jointag A B...) Join tracks from two tags, making tag(s) B an alias of tag A',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							success = false

							if inputParts[1].length > 0
								tags = inputParts[1].split(Player::TAG_INPUT_SPLIT)
								if tags.length > 1
									success = combineTags tags
									if success
										writeLibraryToFile
									else
										putsRealtime "There was a problem with combining the tags. Your changes were not saved."
									end
								else
									putsRealtime "Please give at least two tags."
								end
							end

							putsRealtime "Tags: \n	#{@library['tags'].keys.sort.join(", ")}" if not success
							{:chainedInput => inputParts[2]}
						},
						'tabComplete' => tagTabComplete
					},
					'rm' => {
						'description' => 'remove selected tracks',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							editedTrackList = editTrackList @tracks
							initialLibraryLength = @library['tracks'].length
							editedTrackList.each do |track|
								removeTrackFromLibrary track['id']
							end
							checksum = initialLibraryLength - editedTrackList.length == @library['tracks'].length
							checksumString = "#{initialLibraryLength} - #{editedTrackList.length} == #{@library['tracks'].length}"
							if checksum
								writeLibraryToFile
							end
							putsRealtime "#{checksumString} ... #{checksum ? 'OK: changes written' : 'Mismatch: changes not written'}"
							{:chainedInput => inputParts[2]}
						}
					},
					'rmfile' => {
						'description' => 'Remove files: (options: this (default), unknown (files not referenced by the library), current (files for all selected tracks), all (what it sounds like), You\'ll be prompted with a list to edit; clear the list if you want to cancel the operation.',
						'args' => ['this', 'unknown', 'current', 'all'],
						'action' => Proc.new { |input, command|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							setDescriptor = inputParts[1] && inputParts[1].length > 0 ? inputParts[1] : 'this'

							filesToDelete = []
							filesToIgnore = ['.', '..']

							case setDescriptor
							when "this"
								trackFiles = findTrackFiles @currentTrack
								if trackFiles
									filesToDelete.concat(trackFiles.map { |p|
										p.sub "#{@fileDirectory}/", ''
									})
								end
							when "unknown"
								Dir.entries(@fileDirectory).each { |file|
									if !filesToIgnore.include? file
										id = getIdFromFileName file
										if !id || !@library['tracks'][id]
											filesToDelete << file
										end
									end
								}
							when "current"
								Dir.entries(@fileDirectory).each { |file|
									if !filesToIgnore.include? file
										id = getIdFromFileName file
										if !id || !@tracks.include?(id)
											filesToDelete << file
										end
									end
								}
							when "all"
								Dir.entries(@fileDirectory).each { |file|
									if !filesToIgnore.include? file
										filesToDelete << file
									end
								}
							else
								putsRealtime "\nUnrecognized option '#{setDescriptor}'. Use one of #{command['args'].join(", ")}"
							end

							filesToDelete = editListInVim filesToDelete, "remove any files you don't want to delete" if filesToDelete.length > 0

							if filesToDelete.length > 0

								if confirm("Delete #{filesToDelete.length} files?")
									filesToDelete.each { |file|
										File.delete "#{@fileDirectory}/#{file.chomp}"
									}
									putsRealtime "#{filesToDelete.length} files deleted."
									writeLibraryToFile
								end
							else
								putsRealtime "No files to delete."
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'rmlist' => {
						'description' => '<playlistName> remove a playlist.',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1] && inputParts[1].length > 0
								playlistName = findPlaylistName inputParts[1]

								if playlistName
									@library['playlists'].delete playlistName
									writeLibraryToFile
									putsRealtime "removed playlist #{playlistName}"
								end

							else
								putsRealtime "#{@library['playlists'].map { |name, p| name } .join "\n"}\n\nPlease specify a playlist name (new or existing)."
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'refresh' => {
						'description' => 'Load the latest version of the media library.',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							loadLibrary
							@currentTrack = matchExistingLibraryTrack @currentTrack
							{:chainedInput => inputParts[2]}
						}
					}
				},
				'editing' => {
				},
				'playing' => {
					'' => {
						'description' => "Chainable player commands (empty command, i.e. '/').",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							output = {
								:chainedInput => inputParts[2]
							}
							if inputParts[1] && inputParts[1].length > 0
								whisper("Running player action (#{input})", 3)
								output[:action] = inputParts[1]
							end

							output
						}
					},
					'note' => {
						'description' => "Make a note on this track, with a timestamp taken from the time you type '/' to begin the command (so that you can take your time composing the note without worrying about the moment passing).",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							notesChanged = false;

							loadLibrary
							@currentTrack = matchExistingLibraryTrack @currentTrack

							# TODO 1gor9z: when typing `/note` and there are no existing notes, begin creating a note
							if !inputParts[1] || inputParts[1].length < 1
								if @currentTrack.has_key? 'notes'
									notesList = @currentTrack['notes'].map { |note| "#{note['time']} - #{note['text']}" }
									editedNotesList = editListInVim notesList
									if editedNotesList.length > 0
										editedNotes = []
										editedNotesList.each_with_index { |editedLine, index|
											lineMatches = editedLine.match(/^([0-9:]+) - (.*)( \(([0-9-]{10}T[0-9]{8}[Z0-9-]+)\))?/)
											if lineMatches
												editedNote = {
													'time' => lineMatches[1],
													'text' => lineMatches[2]
												}
												if lineMatches[4] && lineMatches[4].length > 0
													editedNote['datetime'] = lineMatches[4]
												end
												editedNotes << editedNote
											else
												editedNotes.last['text'] += "\n#{editedLine}"
											end
										}
										@currentTrack['notes'] = editedNotes
									else
										@currentTrack.delete('notes')
									end
									notesChanged = true
								else
									putsRealtime "No notes on the current track."
								end
							else
								@currentTrack['notes'] ||= []
								note = {
									'text' => inputParts[1],
									'time' => getDurationStringFromSeconds(@commandinputStartPlayerTime)
								}
								liveStreaming = doesTrackHaveTag(@currentTrack, 'live-radio') # TODO: 1gSke5
								if liveStreaming
									note['datetime'] = Time.now.iso8601
								end
								if note['text'].length < 1
									note['text'] = editListInVim([], 'Write your note').join "\n"
								end
								@currentTrack['notes'] << note
								notesChanged = true
							end

							if notesChanged
								if @currentTrack.has_key?('notes')
									@currentTrack['notes'].sort! { |a, b| getSecondsFromDurationString(a['time']) <=> getSecondsFromDurationString(b['time']) } # TODO: 1gG4hJ
								end
								addTrackToLibrary @currentTrack if @currentTrack['unattached']
								writeLibraryToFile
							end

							{:chainedInput => inputParts[2]}
						}
					},
					'eq' => {
						'description' => 'Set EQ, or save a new preset (/eq [PRESET | save NEW_NAME]). If no preset is given, a list of presets is shown, along with an interactive EQ display, which can by changed using the arrow keys.',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							loadLibrary
							@library['player'] ||= {}
							@library['player']['equalizer_presets'] ||= {}

							# default presets
							@library['player']['equalizer_presets']['flat'] = '0:0:0:0:0:0:0:0:0:0'
							@library['player']['equalizer_presets']['bass'] ||= '-1:0:-2:-3:-5:-5:-5:-5:-5:-5'
							@library['player']['equalizer_presets']['earplugs'] ||= '-4:0:-5:-6:-6:-5:-4:-2:0:-3'

							def handleEQTextInput input
								is_success = false
								savePresetNamePattern = /^save ([^ ]+).*/
								if savePresetNamePattern.match input
									@eqPreset = input.sub savePresetNamePattern, '\1'
									@library['player']['equalizer_presets'][@eqPreset] = @eqSetting
									writeLibraryToFile
									is_success = true
								else
									chosenEQPreset = firstFuzzyMatchValue input, @library['player']['equalizer_presets'].keys
									if chosenEQPreset
										@eqPreset = chosenEQPreset
										@eqSetting = @library['player']['equalizer_presets'][chosenEQPreset]
										is_success = true
										# FIXME 1gpapK: can I target `af_clr` at _just_ `equalizer`? I don't want to also remove scaletempo, for instance
										sendPlayerCommand "af_clr\naf_add equalizer=#{@eqSetting}"
									else
										putsRealtime "Unknown preset '#{input}'."
									end
								end
								is_success
							end

							if inputParts[1] && inputParts[1].length > 0
								handleEQTextInput inputParts[1]
							else
								chosenPresetMessage = @eqPreset ? "Using #{@eqPreset}. " : ""
								putsRealtime "#{chosenPresetMessage}Presets: #{@library['player']['equalizer_presets'].keys.join ", "}"

								def showInteractiveEQ bands, selectedIndex
									printRepeat "#{bands.join(':')}\r	#{selectedIndex > 0 ? bands.slice(0, selectedIndex).join(':') + ":" : ''}"
								end

								@eqSetting ||= @library['player']['equalizer_presets']['flat']
								eqBands = @eqSetting.split(':').map { |level| level.to_i }
								selectedBandIndex = 0
								showInteractiveEQ eqBands, selectedBandIndex
								disablePlaybackInfo
								interactivePresetNameInput = ''
								while eqInput = readCharacter
									inputCausedEQChange = false
									if eqInput == "\e[A" # up arrow
										eqBands[selectedBandIndex] = [eqBands[selectedBandIndex] + 1, 10].min
										inputCausedEQChange = true
									elsif eqInput == "\e[B" # down arrow
										eqBands[selectedBandIndex] = [eqBands[selectedBandIndex] - 1, -10].max
										inputCausedEQChange = true
									elsif eqInput == "\e[C" # right arrow
										selectedBandIndex = [selectedBandIndex + 1, eqBands.length - 1].min
									elsif eqInput == "\e[D" # left arrow
										selectedBandIndex = [selectedBandIndex - 1, 0].max
									elsif eqInput == "" # backspace
										if interactivePresetNameInput.length > 0
											interactivePresetNameInput = interactivePresetNameInput[0, interactivePresetNameInput.length - 1]
											printRepeat interactivePresetNameInput
										end
									elsif eqInput == "" # clear line
										interactivePresetNameInput = ''
										printRepeat interactivePresetNameInput
									elsif /[\n\r]/.match(eqInput)
										if interactivePresetNameInput.length > 0
											print "\n"
											inputCausedEQChange = handleEQTextInput interactivePresetNameInput
										end
										break
									else
										interactivePresetNameInput += eqInput
									end

									if interactivePresetNameInput.length > 0
										printRepeat interactivePresetNameInput
									else
										showInteractiveEQ eqBands, selectedBandIndex
									end

									if inputCausedEQChange
										@eqSetting = eqBands.join ':'
										sendPlayerCommand "af_clr\naf_add equalizer=#{@eqSetting}"
									end
								end
								enablePlaybackInfo
							end
							{:chainedInput => inputParts[2]}
						},
						'tabComplete' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							presetNames = @library['player']['equalizer_presets'].keys

							if inputParts[1] && inputParts[1].length > 0
								presetGuess = firstFuzzyMatchValue(inputParts[1], presetNames)
								if presetGuess && presetGuess.length > 0
									input = input.sub!(inputParts[1], presetGuess)
								end
							else
								putsRealtime "\nEQ presets: #{presetNames.join(", ")}"
							end

							input
						}
					},
					'fade' => {
						'description' => '/fade VOLUME [DURATION]; VOLUME can be "out" or "in", which will fade from or to the last explicit volume set.',
						'args' => ['out', 'in'],
						'action' => Proc.new { |input|
							output = nil
							fadeCommandMatch = /^(out|in|[0-9.]+x?)( [0-9.]+)?[^\/]*(.*)$/.match input
							if fadeCommandMatch
								output = {:chainedInput => fadeCommandMatch[3]}
								whisper("fade command", 4)
								duration = fadeCommandMatch[2] && fadeCommandMatch[2].length > 0 ? fadeCommandMatch[2].to_f : 2.0
								targetFadeVolume = fadeCommandMatch[1]
								if output[:chainedInput] && output[:chainedInput].length > 0
									whisper("fade in main thread", 4)
									fadeVolume targetFadeVolume, duration, @currentPlayerIndex
								else
									whisper("fade in separate thread", 4)
									Thread.new {
										fadeVolume targetFadeVolume, duration, @currentPlayerIndex
									}
								end
							end
							output
						}
					},
					'ramp' => {
						'description' => '/ramp SPEED [DURATION] - Ramp speed',
						'action' => Proc.new { |input|
							output = nil
							rampCommandMatch = /^(out|in|[0-9.]*(bpm)?)( [0-9.]+)?[^\/]*(.*)$/.match input
							#                    1              2      3                4
							if rampCommandMatch
								output = {:chainedInput => rampCommandMatch[4]}
								duration = rampCommandMatch[3] && rampCommandMatch[3].length > 0 ? rampCommandMatch[3].to_f : 0.3
								whisper('without -af scaletempo[=speed=tempo], min and max limited by the system (~1/8 and ~4.5 on my Mac Mini)', 1)
								targetRampSpeed = rampCommandMatch[1]
								if rampCommandMatch[1] == 'bpm'
									targetRampBPM = getUserInputBPM
									if targetRampBPM && targetRampBPM > 0
										targetRampSpeed = "#{targetRampBPM}bpm"
									else
										targetRampSpeed = nil
									end
								end
								if targetRampSpeed
									targetRampSpeed = determineRelativeSpeed targetRampSpeed, @currentTrack, true
									if rampCommandMatch[4] && rampCommandMatch[4].length > 0
										whisper("ramping speed in the main thread", 4)
										rampSpeed targetRampSpeed, duration, @currentPlayerIndex
										whisper("Waiting 1 second for buffered sound to play", 2)
										sleep 1.0
									else
										whisper("ramping speed in a separate thread", 4)
										Thread.new {
											rampSpeed targetRampSpeed, duration, @currentPlayerIndex
										}
									end
								end
							end
							output
						}
					},
					'glide' => {
						'description' => '/glide DURATION [DELAY] - Set BPM "glide" period. Default 0 (i.e. off). If changing between two tracks with tempo information, the second track will begin playing to match the tempo of the first, and then "glide" for DURATION (after DELAY) back to the configured global speed.',
						'action' => Proc.new { |input|
							output = nil
							glideCommandMatch = /^([0-9.]+)( [0-9.]+)?[^\/]*(.*)$/.match input
							#                     1        2                3
							if glideCommandMatch
								output = {:chainedInput => glideCommandMatch[3]}
								@bpmGlideDuration = glideCommandMatch[1].to_f
								@bpmGlideDelay = glideCommandMatch[2] && glideCommandMatch[2].length > 0 ? glideCommandMatch[2].to_f : 0.0
							end
							output
						}
					},
					'mark' => {
						'description' => 'Mark the point at which to play this track next time. Pass any argument to remove an existing mark',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							loadLibrary
							@currentTrack = matchExistingLibraryTrack @currentTrack
							if inputParts[1] && inputParts[1].length > 0
								removeMarkFromTrack @currentTrack
							else
								addMarkToTrack @currentTrack, @commandinputStartPlayerTime
							end
							writeLibraryToFile
							{:chainedInput => input}
						}
					},
					'turn' => {
						# TODO: 1gG4hV
						'description' => "Use all this track's tags to populate the track list.",
						'action' => Proc.new { |input|
							trackTags = getTrackTags @currentTrack
							if trackTags.length > 0
								putsRealtime "Playing tracks with similar tags: #{trackTags.join ', '}"
								@trackFilters ||= {}
								@trackFilters['tag'] = "+#{trackTags.join ' +'}"
								useEntireLibrary
								@trackIndex = 1 # next track (current track will almost certainly be at index 0)
								if @shuffle
									@shuffle = false
									putsRealtime "shuffle: off"
								end
							else
								putsRealtime "Add some tags to this track to find similar tracks."
							end
							{:chainedInput => input}
						}
					},
					'breakloop' => {
						'description' => 'Play the current track to the end, and on to the next, while keeping looping enabled.',
						'action' => Proc.new { |input|
							@breakLoop = true
							{:chainedInput => input}
						}
					},
					'loop' => {
						'description' => '/loop [COUNT]: Set the loop limit, or toggle looping off/on.',
						'args' => ['off', 'on', 'status'],
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1].match(/^[0-9]+$/)
								loopLimit = inputParts[1].to_i
								@loop = true
								@loopLimit = loopLimit
							elsif inputParts[1] != 'status' # if status, fall though
								@loop = getToggledValueByInput.call(@loop, inputParts[1])
							end

							putsRealtime "loop: #{@loop ? 'on' : 'off'} (#{@lastLoop[1]}/#{@loopLimit == 0 ? "indefinite" : "#{@loopLimit} times"})"

							{:chainedInput => inputParts[2]}
						}
					},
					'seek' => {
						'description' => 'Seek to a time code. Prefix with "+" or "-" to seek relative to current play position. use "/seek mark" to seek to a time marked with the "/mark" command."',
						'args' => ['mark'],
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)

							seekInput = inputParts[1].strip
							seekTimeInSeconds = parseRelativeTime seekInput
							seek seekTimeInSeconds, 0.5, 0.5
							{:chainedInput => inputParts[2]}
						}
					},
					'logarithmic' => {
						'description' => 'Toggle logarithmic volume scale.',
						'action' => Proc.new { |input|
							@isVolumeAlreadyLogarithmic= !@isVolumeAlreadyLogarithmic
							putsRealtime "logarithmic volume scale: #{@isVolumeAlreadyLogarithmic ? 'off' : 'on'}"
							{:chainedInput => input}
						}
					},
					'loudness' => { # TODO 1gzQHH
						'description' => "Save current volume relative to default in library.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							loudness = inputParts[1].to_f
							if loudness > 0.0
								loadLibrary
								@currentTrack = matchExistingLibraryTrack @currentTrack
								@currentTrack['loudness'] = loudness
								@volumeMultipliers['track_loudness'] = loudness
								writeLibraryToFile
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'again' => {
						'description' => "Play the last track again.",
						'action' => Proc.new { |input|
							@trackIndex = @tracks.index @currentTrack
							if !@trackIndex
								useTracks [@currentTrack]
								@trackIndex = @tracks.length - 1
								# TODO: 1gG4iz
							end
							{:chainedInput => input}
						}
					},
					'stream' => {
						'description' => "Ignore downloaded files. This is useful if you want to play a different format than the one downloaded (e.g. audio vs. video).",
						'action' => Proc.new { |input|
							@forceStreaming = !@forceStreaming
							putsRealtime "force streaming: #{@forceStreaming ? 'on' : 'off'}"
							{:chainedInput => input}
						}
					},
					'player' => {
						'description' => 'Define player startup options. Takes effect on the next track being played',
						'action' => Proc.new { |input|
							samplePlayerCommands = [];
							samplePlayerCommands << 'Some sample options:';
							samplePlayerCommands << 'small video window in the corner: -geometry 100%:100% -xy 150';
							samplePlayerCommands << 'mix stereo to mono: -af pan=1:0.5:0.5';
							@playerOverrideCommands = editListInVim(@playerOverrideCommands, samplePlayerCommands.join("\n"))
							{:chainedInput => input}
						}
					}
				}
			}

			modes << 'base'
			modes.uniq!
			requestedCommandSet = {}

			modes.each { |modeName|
				requestedCommandSet.merge! interactiveCommands[modeName]
			}

			if requestedCommandSet
				requestedCommandSet['?'] = requestedCommandSet['help'] = {
					'description' => 'Show interactive command info (like this). Not chainable.',
					'action' => Proc.new {
						showInteractiveCommandHelp requestedCommandSet
					}
				}
			end

			requestedCommandSet
		end

		def getChapterIndexAtTime chapters, seconds
			chapterIndex = -1
			chapters.each_with_index { |chapter, index|
				chapterSeconds = getSecondsFromDurationString chapter['time']
				if chapterSeconds <= seconds
					chapterIndex = index
				else
					break
				end
			}
			chapterIndex
		end

		def getOffsetFromInputString input
			offset = nil
			input.strip!
			if input.match(/^>+$/)
				offset = input.length
			elsif input.match(/^<+$/)
				offset = -input.length + 1
			end

			offset
		end

		def getChapterIndexByQuery input, chapters, referenceChapterIndex = nil
			chapterIndex = nil

			chapterIndex = input.to_i - 1
			if chapterIndex < 0
				chapterIndexOffset = getOffsetFromInputString input
				if chapterIndexOffset
					referenceChapterIndex ||= getChapterIndexAtTime chapters, @currentPlayerTime
					chapterIndex = referenceChapterIndex + chapterIndexOffset
				else
					chapterList = chapters.map { |chapter| "#{chapter['time']} - #{chapter['text']}" }
					chapterIndex = firstFuzzyMatchIndex input, chapterList
				end
			end
			whisper("Choosing chapter #{chapterIndex}", 2)

			chapterIndex
		end

		def parseRelativeTime seekInput
			whisper("seek input: #{seekInput}")
			if seekInput && seekInput.length > 0
				if seekInput == 'mark' && @currentTrack.has_key?('mark')
					seekInput = @currentTrack['mark']
				end

				relativeDirection = nil
				relativeDirectionMatch = seekInput.match(/^[+-]/)
				if relativeDirectionMatch
					seekInput.sub!(/^[+-]/, '')
					relativeDirection = relativeDirectionMatch[0] == '-' ? -1 : 1
				end

				seekTimeInSeconds = getSecondsFromDurationString seekInput
				if seekTimeInSeconds
					if relativeDirection
						seekTimeInSeconds = @currentPlayerTime + relativeDirection * seekTimeInSeconds
					end
				else
					whisper("Failed to get seconds from input '#{seekInput}'")
					# TODO: 1gG4hv
				end
			else
				whisper("seek input is empty: '#{seekInput}'")
			end

			seekTimeInSeconds
		end

		def seek seekTimeInSeconds, fadeOutPeriod = 0.0, fadeInPeriod = 0.0
			isAbleToSeek = trackFileExists?(@currentTrack) || @currentTrack['type'] == 'audio/mpeg' || seekTimeInSeconds > @currentPlayerTime
			if isAbleToSeek
				fadeVolume 'out', fadeOutPeriod, @currentPlayerIndex if fadeOutPeriod > 0

				sendPlayerCommand "seek #{seekTimeInSeconds} 2"

				fadeVolume 'in', fadeInPeriod, @currentPlayerIndex if fadeInPeriod > 0
			else
				putsRealtime "Download the file to be able to seek backwards."
			end
		end
		
		def seekToChapter chapterIndex, fadeOutPeriod = 1.0, fadeInPeriod = 0.1
			whisper("seeking to chapter #{chapterIndex} (fade #{fadeOutPeriod}/#{fadeInPeriod}", 3)
			seekTime = @currentTrack['chapters'][chapterIndex]['time']
			seekSeconds = getSecondsFromDurationString seekTime
			whisper("seeking to chapter at #{seekSeconds} seconds", 3)

			seek seekSeconds, fadeOutPeriod, fadeInPeriod
		end

		def getUserInputBPM

			disablePlaybackInfo
			firstTimeInSeconds = nil
			lastTimeInSeconds = nil
			iterations = 0;
			bpm = @currentTrack['bpm'];
			outputMessageLines = []
			outputMessageLines << "Current BPM is #{bpm}." if bpm
			outputMessageLines << "Hit ENTER key on the beat. Type \"k\" to accept, \"r\" to accept the nearest whole number, or anything else to cancel setting the BPM."
			putsRealtime outputMessageLines.join "\n"
			while bpmInput = readCharacter
				if not (/[\n\r]/).match(bpmInput)
					if bpmInput.match(/^[kr]$/)
						if bpmInput == 'r'
							bpm = bpm.round
						end
					else
						bpm = nil
					end
					break
				end

				iterations += 1
				now = Time.now.to_f
				firstTimeInSeconds ||= now
				lastTimeInSeconds = now
				if lastTimeInSeconds != firstTimeInSeconds
					bpm = ((iterations - 1).to_f / (lastTimeInSeconds - firstTimeInSeconds) * 60.0).round(1);
					printRepeat "BPM: #{bpm} "
				end
			end
			print "\n"

			enablePlaybackInfo

			return bpm
		end

		def getMultipliedVolume newVolume
			@volumeMultipliers.each { |m|
				newVolume *= m
			}

			newVolume
		end

		def setActualVolume newVolume
			@volume = newVolume
			@actualVolume = getMultipliedVolume newVolume
			sendPlayerCommand "volume #{@actualVolume} 1", @currentPlayerIndex
		end

		def fadeVolume targetFadeVolume, duration, playerIndex
			whisper("fadeVolume(targetFadeVolume:#{targetFadeVolume}, duration:#{duration}, playerIndex:#{playerIndex})", 4)
			# @volumeMultipliers['fade'] ||= 1 # TODO 1gzQHH: I haven't worked this out yet
			transitionVolume = @actualVolume
			if targetFadeVolume == 'out'
				whisper("fading out volume", 4)
				targetFadeVolume = 0
			elsif targetFadeVolume == 'in'
				targetFadeVolume = @volume
				whisper("fading in volume (to #{targetFadeVolume})", 4)
			elsif targetFadeVolume.match(/x$/)
				multiplier = targetFadeVolume.to_f
				targetFadeVolume = transitionVolume * multiplier
				@volume = targetFadeVolume
				whisper("fading volume #{multiplier}x (to #{targetFadeVolume})", 4)
			else
				targetFadeVolume = targetFadeVolume.to_f
				@volume = targetFadeVolume
				whisper("fading to volume #{targetFadeVolume}", 4)
			end
			targetFadeVolume = [[targetFadeVolume, 0].max, 100].min
			whisper("fading from #{transitionVolume} to #{targetFadeVolume} in #{duration} seconds (playerIndex: #{playerIndex})", 4)
			volumeFadeInterval = 0.02
			volumeFadeStepCount = (duration.to_f / volumeFadeInterval).to_i
			volumeSpan = targetFadeVolume - transitionVolume
			lowerVolume = [transitionVolume, targetFadeVolume].min
			if volumeSpan != 0
				if @isVolumeAlreadyLogarithmic
					volumeStepStrategy = Proc.new { |stepIndex|
						transitionVolume = lowerVolume + volumeSpan.abs * (stepIndex.to_f / volumeFadeStepCount)
					}
				else
					volumeStepStrategy = Proc.new { |stepIndex|
						transitionVolume = lowerVolume + 10**(Math.log10(volumeSpan.abs + 1) / volumeFadeStepCount * stepIndex) - 1
					}
				end
				stepFade = Proc.new { |stepIndex|
					volumeStepStrategy.call(stepIndex)
					sendPlayerCommand "volume #{transitionVolume} 1", playerIndex
					@actualVolume = transitionVolume
					trigger 'volume_change'
					sleep volumeFadeInterval
				}
				if volumeSpan > 0
					1.upto(volumeFadeStepCount - 1) { |stepIndex| stepFade.call stepIndex }
				else
					(volumeFadeStepCount - 1).downto(1) { |stepIndex| stepFade.call stepIndex }
				end
				sendPlayerCommand "volume #{targetFadeVolume} 1", playerIndex
				@actualVolume = targetFadeVolume
				trigger 'volume_change'
			else
				whisper("fading to the same volume: doing nothing", 4)
			end

			trigger 'fade_end'
		end

		def rampSpeed targetRampSpeed, duration, playerIndex
			isValidInput = false
			whisper("ramp speed to #{targetRampSpeed} over #{duration} seconds", 2)
			if targetRampSpeed
				transitionSpeed = @currentSpeed
				if targetRampSpeed == 'out'
					targetRampSpeed = 0
					@speedBeforeRampingOut = transitionSpeed
				elsif targetRampSpeed == 'in'
					targetRampSpeed = @speedBeforeRampingOut
				else
					targetRampSpeed = targetRampSpeed.to_f
					@speed = targetRampSpeed
					# does this work? # @speed = targetRampSpeed.to_f!
				end
				speedRampInterval = 0.02
				speedRampStepCount = duration / speedRampInterval
				speedStep = (targetRampSpeed - transitionSpeed) / duration * speedRampInterval
				whisper("about to ramp speed by #{speedStep} every #{speedRampInterval} seconds", 3)
				for stepIndex in 1..speedRampStepCount
					whisper("rampSpeed: step #{stepIndex} of #{speedRampStepCount}", 4)
					transitionSpeed += speedStep
					sendPlayerCommand "speed_set #{transitionSpeed}", playerIndex
					@currentSpeed = transitionSpeed
					trigger 'speed_change'
					sleep speedRampInterval
				end
				sendPlayerCommand "speed_set #{targetRampSpeed}", playerIndex
				@currentSpeed = targetRampSpeed
				trigger 'speed_change'
				isValidInput = true
			else
				putsRealtime "Bad speed format, or track has no bpm set."
			end

			trigger 'speed_ramp_end'

			isValidInput
		end

		def findTag(query)
			verifiedTagName = nil
			meansToFindTag = nil

			if @library['tags'].has_key? query
				meansToFindTag = 'name'
				verifiedTagName = query
			else
				@library['tags'].each { |name, t|
					if t['aliases'] && t['aliases'].include?(query)
						meansToFindTag = 'alias'
						verifiedTagName = name
					end
				}
			end

			if verifiedTagName
				whisper("found tag '#{verifiedTagName}' by #{meansToFindTag} '#{query}'", 2)
				return @library['tags'][verifiedTagName]
			else
				whisper("no tag found by query '#{query}'", 2)
				return false
			end
		end

		def addTrackToTags(track, tagNames)
			# TODO 1gtzi6: for tags containing ':' colons, add the tag as-is, and set
			# its parents to the list resulting from splitting on ':' colon (e.g.
			# 'composer:vangelis' will create/add to the tag of that name, and assign
			# that tags parents to be 'composer' and 'vangelis', creating those tags
			# as necessary).
			whisper("adding tags (input): #{tagNames}", 3)
			tagNames.each { |tagName|
				whisper("about to add to tag '#{tagName}'", 4)
				matchingTag = findTag(tagName) || createTag(tagName)
				whisper("matchingTag: #{matchingTag}", 4)
				matchingTag['tracks'] ||= []
				whisper("adding track to tag #{tagName}", 4)
				matchingTag['tracks'] << track['id']

				matchingTag['score'] ||= {}
				matchingTag['score'][track['id']] ||= 0
				matchingTag['score'][track['id']] = matchingTag['score'][track['id']] + 1

				matchingTag['tracks'].uniq!
			}
		end

		def removeTagsFromTrack(track, tagNames)
			whisper("removing tags: #{tagNames}", 3)
			tagNames.each { |tagName|
				matchingTag = findTag tagName
				if matchingTag && matchingTag['tracks']
					matchingTag['tracks'].delete track['id'] if matchingTag['tracks'].include? track['id']
				end
			}
		end

		def relateTags(tagNames)
			childTagName = tagNames.shift
			childTag = findTag childTagName

			if childTag && tagNames.length > 0
				childTag['parents'] ||= []
				childTag['parents'].concat tagNames
				childTag['parents'].uniq!
			else
				putsRealtime "provide 2 or more tags to relate together"
			end

			childTag
		end

		def combineTags(tagNames)
			firstTagName = tagNames.shift
			firstTag = findTag firstTagName

			if firstTag && tagNames.length > 0
				whisper("merging #{tagNames.join ', '} into #{firstTagName}", 3)
				tagNames.each { |collapsingTagName|
					collapsingTag = findTag collapsingTagName
					if collapsingTag && collapsingTag != firstTag
						firstTag['aliases'] ||= []
						firstTag['aliases'] << collapsingTagName
						if collapsingTag['tracks'] && collapsingTag['tracks'].length > 0
							firstTag['tracks'] ||= []
							firstTag['tracks'].concat collapsingTag['tracks']
						end
						deleteTag collapsingTagName
					end
				}

				firstTag['aliases'].uniq!
				firstTag['tracks'].uniq!
			else
				putsRealtime "provide 2 or more tags to join together"
			end

			firstTag
		end

		def createTag(tagName)
			whisper("creating tag '#{tagName}'", 3)
			@library['tags'][tagName] = {}
			@library['tags'][tagName]
		end

		def deleteTag(tagName)
			@library['tags'].delete tagName if @library['tags'].has_key? tagName
		end

		def getNextPlayableChapterIndex chapters, fromIndex = -1
			nextChapterIndex = nil
			chapters.each_with_index { |chapter, index|
				if index > fromIndex && (!chapter.has_key?('skip') || !chapter['skip'])
					nextChapterIndex = index
					break
				end
			}

			nextChapterIndex
		end

		def seekToNextPlayableChapterOrSkip chapters, fromIndex
			nextChapterIndex = getNextPlayableChapterIndex @currentTrack['chapters'], fromIndex

			if nextChapterIndex
				chapter = chapters[nextChapterIndex]
				seekSeconds = getSecondsFromDurationString chapter['time']
				whisper("Skipping chapter #{fromIndex + 1}, to #{nextChapterIndex + 1} (#{chapter['time']}, #{seekSeconds}).", 0)
				seek seekSeconds, 0, 0
			else
				whisper("Skipping chapter #{fromIndex + 1}; no more playable chapters; skipping track.", 0)
				fadeVolume 'out', 0.25, @currentPlayerIndex
				sendPlayerCommand "q"
			end
		end

		def play(track, interactiveCommands)
			fileAlreadyExists = !@forceStreaming && trackFileExists?(track) # TODO: 1gG4j4: I shouldn't need to check twice
			liveStreaming = doesTrackHaveTag(track, 'live-radio') # TODO: 1gSke5
			streaming = @forceStreaming || (!fileAlreadyExists && !@enableDownload)

			if !@networkEnabled && !fileAlreadyExists
				whisper("No local file to play: #{track['title']}", 0)
				return response
			end

			trigger 'play_start'

			bindingGroupName = 'play'

			whisper("playing track: #{track}", 3)
			@currentPlayerIndex = 1 - @currentPlayerIndex
			whisper("@currentPlayerIndex: #{@currentPlayerIndex}", 4)
			response = {
				:exit => true,
				:playTime => 0
			}

			playerInputStreamName = "#{Player::MPLAYER_INPUT_FIFO_NAME}#{@currentPlayerIndex}"
			deleteStream playerInputStreamName
			playerInputFile = makeStream playerInputStreamName

			playerStdoutName = "#{Player::MPLAYER_STDOUT_BUFFER_NAME}#{@currentPlayerIndex}"
			playerStdoutFile = getTempFilePath playerStdoutName

			playerStartupOptions = ["-slave -quiet -input file=#{playerInputFile}"]
			playerStatus = nil
			playerAction = Proc.new { |command|
				sendPlayerCommand command
				true
			}

			firstPlayableChapterIndex = nil
			if track.has_key?('chapters') && track['chapters'].length > 0 && track['chapters'][0]['time']
				firstPlayableChapterIndex = 0
				firstChapterStartTime = getSecondsFromDurationString(track['chapters'][0]['time'])
				if firstChapterStartTime == 0
					firstPlayableChapterIndex = getNextPlayableChapterIndex track['chapters']
				end # don't skip if first chapter doesn't start at 0:00
			end

			if @loop && track['loop'].kind_of?(Array)
				whisper("This track has has an A/B loop (#{track['loop'].join(" - ")}. This will deprecated in favor of looping notes; for now, use looping chapters instead.", 1)
			end

			if track['mark'] && !liveStreaming
				puts("Starting from mark at #{track['mark']}.", 0)
				offsetSeconds = getSecondsFromDurationString track['mark']
				playerStartupOptions << "-ss #{offsetSeconds}"
				loadLibrary
				editingTrack = matchExistingLibraryTrack track
				removeMarkFromTrack editingTrack
				writeLibraryToFile
			elsif firstPlayableChapterIndex && firstPlayableChapterIndex > 0
				startTime = getSecondsFromDurationString track['chapters'][firstPlayableChapterIndex]['time']
				playerStartupOptions << "-ss #{startTime}"
				whisper("Skipping marked chapters at the beginning.", 2)
				whisper("-ss #{startTime}", 2)
			else
				whisper("No mark, no A/B loop.", 2)
			end

			if fileAlreadyExists
				mediaFilePath = firstTrackFile track
			else
				downloadOptions = {}
				if streaming
					if @youtubeDLTrackTypes.include? track['type']
						whisper("streaming youtube track", 2)
						streamName = 'youtube-stream'
						deleteStream streamName
						downloadOptions['streamPath'] = mediaFilePath = makeStream streamName
						if not downloadTrack(track, downloadOptions)
							whisper("could not download/stream track", 1)
							mediaFilePath = nil
						end
					else
						whisper("streaming other type of track (#{track['type']})", 2)
						streamName = 'mp3-stream'
						deleteStream streamName
						# mplayer 4.2.1 on Mac OS Sierra unable to stream HTTPS
						if /^https:\/\//.match track['src']
							downloadOptions['streamPath'] = mediaFilePath = makeStream streamName
							if not downloadTrack(track, downloadOptions)
								whisper("could not download/stream track", 1)
								mediaFilePath = nil
							end
						else
							mediaFilePath = track['src']
						end
					end
				end
			end

			if not mediaFilePath
				puts("File not found for #{track['title']}.", 0)
				return response
			end

			if !streamName
				resetLastLoop
				playerStartupOptions << "-loop #{@loopLimit}" if @loop && !doesTrackHaveLoopingChapters?(@currentTrack)
			end

			@speed = 1 if @speed < 0.01
			speed = @speed
			if @playingBPM && @currentTrack['bpm']
				speed = @speed * @playingBPM / @currentTrack['bpm']
			end

			## TODO 1gzQHH
			# if track.has_key?('loudness') && track['loudness']
			#   @volumeMultipliers['track_loudness'] = track['loudness']
			# elsif @volumeMultipliers.has_key? 'track_loudness'
			#   @volumeMultipliers.delete 'track_loudness'
			# end
			# 
			# newVolume = getMultipliedVolume @volume
			# if @actualVolume != newVolume
			# 	@actualVolume = newVolume # they may differ, but at this point, only @volume matters
			# 	trigger 'volume_change'
			# end

			if @currentVolume != @volume
				@currentVolume = @volume # they may differ, but at this point, only @volume matters
				trigger 'volume_change'
			end

			playerStartupOptions += @playerOverrideCommands
			playerStartupOptions << "-volume #{@volume}"
			playerStartupOptions << "-speed #{speed}"

			response[:startTime] = Time.now.to_f

			@inputThread.kill if @inputThread
			@inputThread = Thread.new {
				whisper("commandPrompt start (opening input thread)", 4)
				commandPrompt '', interactiveCommands, playerAction
				whisper("commandPrompt end", 4)
			}
			if @playerTemporaryInteractiveCommands.length > 0
				playerAction.call @playerTemporaryInteractiveCommands.join("\n")
				@playerTemporaryInteractiveCommands = []
			end
			@playerApplicationThreads[@currentPlayerIndex] = Thread.new {
				@isPlayerPlaying = true
				# TODO 1gnyIc: fix missing input characters while paused
				@tempFiles[playerStdoutFile] = true
				playerCommand = "#{Player::PLAYER_APPLICATION} \"#{mediaFilePath}\" #{playerStartupOptions.join ' '} > #{playerStdoutFile}"
				whisper(playerCommand, 3)
				playerStatus = `#{playerCommand} 2> /dev/null`
				whisper("#{Player::PLAYER_APPLICATION} is finished. killing user input thread", 4)
				@inputThread.kill if @inputThread
			}

			enablePlaybackInfo # might have been set false if the player quit while realtime output was hidden
			bind('time_update', Proc.new {
				if @currentTrack.has_key?('chapters')
					newChapterIndex = getChapterIndexAtTime @currentTrack['chapters'], @currentPlayerTime
					if newChapterIndex > -1
						if @currentChapterIndex != newChapterIndex
							@currentChapterIndex = newChapterIndex
							trigger 'chapter_change'
						end
					end
				else
					@currentChapterIndex = nil
				end
				showPlaybackInfo
			}, bindingGroupName)
			bind('chapter_change', Proc.new {
				# check if we need to skip this chapter
				if (
						@loop  &&
						!@breakLoop  &&
						!@currentlySkippingChapter &&
						@currentTrack['chapters'][@currentChapterIndex] &&
						@currentTrack['chapters'][@currentChapterIndex].has_key?('loop_target') &&
						(
							@lastLoop[0] != @currentTrack['chapters'][@currentChapterIndex]['loop_target'] ||
							@lastLoop[1] < @loopLimit
						)
				)
					whisper("jumping to target chapter '#{@currentTrack['chapters'][@currentChapterIndex]['loop_target']}'", 2)
					@currentlySkippingChapter = @currentChapterIndex

					targetChapterIndex = getChapterIndexByQuery @currentTrack['chapters'][@currentChapterIndex]['loop_target'], @currentTrack['chapters']
					if targetChapterIndex
						if @lastLoop[0] == @currentTrack['chapters'][@currentChapterIndex]['loop_target']
							@lastLoop[1] += 1
						else
							@lastLoop = [@currentTrack['chapters'][@currentChapterIndex]['loop_target'], 1];
						end
						whisper("\nLoop ##{@lastLoop[1]}/#{@loopLimit > 0 ? @loopLimit : ""}", 1)
						fadeInterval = 0.0
						seekToChapter targetChapterIndex, fadeInterval, fadeInterval
					end

					bindOnce('chapter_change', Proc.new {
						@currentlySkippingChapter = nil
					})
				elsif (
						!@currentlySkippingChapter &&
						@currentTrack['chapters'][@currentChapterIndex] &&
						@currentTrack['chapters'][@currentChapterIndex].has_key?('skip') &&
						@currentTrack['chapters'][@currentChapterIndex]['skip'] == true
				)
					@currentlySkippingChapter = @currentChapterIndex

					seekToNextPlayableChapterOrSkip @currentTrack['chapters'], @currentlySkippingChapter

					bindOnce('chapter_change', Proc.new {
						@currentlySkippingChapter = nil
					})
				end
			}, bindingGroupName)

			while @playerApplicationThreads[@currentPlayerIndex].alive?
				playerResponseDelay = 0.1
				playerTimeResponse = getMplayerProperty('get_time_pos', /^(ANS_TIME_POSITION=|.*Time: )(.*?)(\?)?$/, playerResponseDelay)
				if playerTimeResponse
					@currentPlayerTime = playerTimeResponse.to_f
					trigger 'time_update'
				end
			end

			@breakLoop = false

			# @playerApplicationThreads[@currentPlayerIndex].join
			whisper("killing user input thread (again)", 4)
			@inputThread.kill if @inputThread # FIXME 1gpapl: overkill?

			response[:endTime] = Time.now.to_f

			deleteStream playerInputStreamName
			deleteTempFile playerStdoutName

			response[:playTime] = response[:endTime] - response[:startTime]

			deleteStream streamName if streamName
			 
			trigger 'play_end'

			unbindGroup bindingGroupName

			response[:exit] = playerStatus
			response
		end

		def showPlaybackInfo
			if @shouldShowPlaybackInfo && @configuredVerbosity > -1 && @configuredVerbosity < 5
				playbackInfo = []
				unicodeChars = {
					:speaker => "",
					:timer => "",
					:openBook => "",
					:label => "",
					:star => "",
					:crossArrows => "",
					:parallelArrows => "",
					:whiteStar => "",
					:floppyDisk => ""
				}

				# show shuffle or regular playback
				playbackInfo << "#{@shuffle ? unicodeChars[:crossArrows] : unicodeChars[:parallelArrows]}"

				# show volume
				volumeIndication = "" * (@actualVolume / 10).to_i + ["", "", "", "", "", "", "", ""][(@actualVolume % 10 / 1.25).to_i]
				volumeIndication = "[#{volumeIndication}#{" " * (10 - volumeIndication.length)}]"
				playbackInfo << "#{unicodeChars[:speaker]} #{volumeIndication}"

				# show playback position
				timeMessage = "#{unicodeChars[:timer]}	#{getDurationStringFromSeconds @currentPlayerTime, 0}"
				timeMessage += "/#{@currentTrack['duration']}" if @currentTrack.has_key?('duration')
				timeMessage += "(#{(@currentSpeed * 10).round / 10.0}x)" if @currentSpeed != 1
				playbackInfo << timeMessage

				# show if the track file is downloaded
				playbackInfo << "#{unicodeChars[:floppyDisk]}" if trackFileExists?(@currentTrack)

				# show track rating
				if @currentTrack.has_key? 'rating'
					playbackInfo << "#{unicodeChars[:star]} #{@currentTrack['rating']}"
				end

				# show current chapter name
				if @currentTrack.has_key?('chapters')
					if @currentChapterIndex && @currentTrack['chapters'][@currentChapterIndex]
						playbackInfo << "#{unicodeChars[:openBook]}	#{@currentTrack['chapters'][@currentChapterIndex]['text']}" # undefined method `[]' for nil:NilClass (NoMethodError)
					end
				else
					@currentChapterIndex = nil
				end

				# show tags on this track
				currentTags = getTrackTags @currentTrack
				if currentTags && currentTags.length > 0
					playbackInfo << "#{unicodeChars[:label]}	#{currentTags.join ', '}"
				end

				# check again if realtime output has been disabled while were doing all this stuff
				if @shouldShowPlaybackInfo && @configuredVerbosity > -1 && @configuredVerbosity < 5
					printRepeat(playbackInfo.join(' '), true)
				end
			end
		end

		def getMplayerProperty property, pattern = nil, responseDelay = nil
			output = nil
			if @isPlayerPlaying # TODO: 1gG4j9 get time position without unpausing
				pattern ||= /^()(.*)$/
				command = "#{property}"
				command = "get_property #{command}" if not property.match(/^get_/)
				# TODO: 1gG4jB maybe this needs pausing_keep (http://www.mplayerhq.hu/DOCS/tech/slave.txt). doesn't quite work in my testing
				sendPlayerCommand command
				sleep responseDelay if responseDelay
				lastPlayerOutput = tailTempFile "#{Player::MPLAYER_STDOUT_BUFFER_NAME}#{@currentPlayerIndex}"
				if lastPlayerOutput
					whisper("read #{property} from player, output: #{lastPlayerOutput}", 5)
					matches = lastPlayerOutput.match pattern
					output = matches[2] if matches
				end
			else
				# don't use 100% CPU while doing nothing
				sleep responseDelay if responseDelay
			end
			output
		end

		def getMplayerConfigNumericProperty(propertyName, defaultValue = 0.0)
			playerCommands = []
			playerCommands += @playerOverrideCommands if @playerOverrideCommands
			propertyValue = defaultValue

			playerCommands.each { |command|
				if command.include? propertyName
					propertyValue = command.match(/.*-#{propertyName} ([0-9.]+)/)[1].to_f
				end
			}

			propertyValue.to_f
		end

		def nextTrack
			whisper("next track", 3)
			if @shuffle
				# FIXME 1gpalq: filterTracksOnDeck should run regardles of @shuffle, but it would mess with @trackIndex. With @shuffle == true, it doesn't matter.
				filterTracksOnDeck()
				shuffleIndex()
			else
				@trackIndex += 1

				if @trackIndex > @tracks.length - 1

					if @youtubeSearchPage && @networkEnabled
						@youtubeSearchPage += 1
						searchedTracks = searchYouTube(@youtubeSearch, (@youtubeSearchPage - 1) * 20)
						useTracks(searchedTracks, true) if searchedTracks
					else
						@trackIndex %= @tracks.length
					end

				end

			end
		end

		def useTracks tracks, append = true
			if append
				whisper("Adding #{tracks.length} tracks to the end of your play queue.")
			else
				whisper("Replacing your play queue with #{tracks.length} tracks.")
				@tracks = []
			end
			@tracks += tracks
			filterTracksOnDeck
			putInTempFile('tracks', listTrackTitles(@tracks).join("\n"), false)
			if @trackIndex && @trackIndex > @tracks.length - 1
				@trackIndex = 0
			end
		end

		def writeTitleChangesInTrackList tracks
			whisper("writeTitleChangesInTrackList: say something!", 3)
			anyChanges = false
			tracks.each { |track|
				canonicalTrack = matchExistingLibraryTrack(track)
				if track['title'] != canonicalTrack['title']
					whisper("Updating '#{canonicalTrack['title']}' = '#{track['title']}'", 3)
					canonicalTrack['title'] = track['title']
					anyChanges = true
				else
					whisper("Identical: '#{canonicalTrack['title']}' == '#{track['title']}'", 3)
				end
			}
			if anyChanges then writeLibraryToFile
			else whisper("No changes to track titles.", 3)
			end
		end

		def filterTracksOnDeck
			if @trackFilters
				@tracks = filterTracks @tracks, @trackFilters
			end

			if @trackExcludeFilters
				@tracks = filterTracks @tracks, @trackExcludeFilters, true
			end
		end

		def shuffleIndex
			@trackIndex = Random.rand(@tracks.length - 1) if @tracks.length > 1
		end

		def setLibraryPath libraryPath
			@tunewichDirectory = libraryPath
			if not Dir.exist? @tunewichDirectory
				whisper("Please create the directory '#{@tunewichDirectory}'.", 0)
				exit
			end

			@fileDirectory = "#{@tunewichDirectory}/music"
			Dir.mkdir @fileDirectory if not Dir.exist? @fileDirectory

			@libraryFilePath = "#{@tunewichDirectory}/tunewich-library.json"
			if not File.exist? @libraryFilePath
				raise "TODO: create library file at #{@libraryFilePath}"
			end

			loadLibrary

			if not @library
				raise "Unable to load library from path #{@libraryFilePath}."
			end
		end

		def extendHash sourceTrack, overrideTrack
			overrideTrack.each { |property, value|
				sourceTrack[property] ||= value
			}
			sourceTrack
		end

		def matchExistingLibraryTrack track
			@library['tracks'].each { |id, t|
				if t['src'] === track['src']
					extendHash t, track
					track = t
					track.delete 'unattached' if track.has_key? 'unattached'
					break
				end
			}
			track
		end

		def getTrackTags track
			tags = []
			@library['tags'].each { |name, tag|
				tags << name if tag.has_key?('tracks') && tag['tracks'].include?(track['id'])
			}
			tags
		end

		def doesTrackHaveLoopingChapters? track
			hasLoopingChapters = false

			if track && track.has_key?('chapters')
				track['chapters'].each { |c|
					if c && c['loop_target']
						hasLoopingChapters = true 
						break
					end
				}
			end

			hasLoopingChapters
		end

		def resetLastLoop
			@lastLoop = [nil, 0]
		end

		def doesTrackHaveTag(track, *tagNames)
			tagNames.each { |tagName|
				@library['tags'].has_key?(tagName) &&
					@library['tags'][tagName].has_key?('tracks') &&
					@library['tags'][tagName]['tracks'].include?(track['id'])
			}
		end

		def getTrackTitles tracks
			tracks.map{|t| t['title']}
		end

		def findTrackIndex(query, referenceTrackIndex = nil)
			referenceTrackIndex ||= @trackIndex
			newTrackIndex = referenceTrackIndex

			trackIndexOffset = getOffsetFromInputString query

			if trackIndexOffset
				newTrackIndex += trackIndexOffset
			elsif query.to_i == 0
				newTrackIndex = @tracks.index(query) || firstFuzzyMatchIndex(query, getTrackTitles(@tracks))
			else
				newTrackIndex = (query.to_i - 1) % @tracks.length
			end

			newTrackIndex
		end

		def findPlaylistName(query)
			firstFuzzyMatchValue query, @library['playlists'].keys
		end

		def fuzzyStringSearchInList(query, list)
			regexSafeQuery = query.gsub(/[\*]+/, '')
			explodedPattern = regexSafeQuery.gsub(/\s+/, '').split('').join('.*')
			queryPattern = Regexp.new(regexSafeQuery + '|' + explodedPattern, Regexp::IGNORECASE)
			matches = []
			list.each_with_index do |value, index|
				matchedPortion = queryPattern.match(value)

				if matchedPortion
					match = {
						:index => index,
						:value => value,
						:matchLength => matchedPortion[0].length,
						:starts => value.downcase.start_with?(query.downcase)
					};
					match[:density] = query.length.to_f / match[:matchLength].to_f
					match[:breadth] = match[:matchLength].to_f / match[:value].length.to_f
					match[:score] = match[:density] * 10 + match[:breadth]
					whisper("match:score]: #{match}", 3)
					matches << match
				end

			end

			if matches.length > 1
				matches.sort! { |a,b|
					if a[:starts] != b[:starts]
						(b[:starts] ? 1 : 0) <=> (a[:starts] ? 1 : 0) # starts first
					elsif a[:starts] # && b[:starts] (^ implied)
						a[:value].length <=> b[:value].length # shorter first
					else
						b[:score] <=> a[:score] # higher first
					end
				}
			end

			matches
		end

		def firstFuzzyMatch(query, list)
			matches = fuzzyStringSearchInList query, list
			matches.length ? matches[0] : false
		end

		def firstFuzzyMatchValue(query, list)
			match = firstFuzzyMatch query, list
			match ? match[:value] : false
		end

		def firstFuzzyMatchIndex(query, list)
			match = firstFuzzyMatch query, list
			match ? match[:index] : false
		end

		def deleteTrackFile(track)
			`rm #{getTrackFilePrefix track}.*` # including `.` after prefix
		end

		def firstTrackFile(track)
			files = findTrackFiles(track)
			files.length ? files[0] : nil
		end

		def findTrackFiles(track)
			globString = "#{getTrackFilePrefix track}*"
			files = Dir.glob(globString)
			files.delete_if { |fileName| fileName.match(/\.part$/) }
			files
		end

		def trackFileExists?(track)
			findTrackFiles(track).length > 0
		end

		def getIdFromFileName(fileName)
			id = fileName.gsub(/^tunewich.([^.]+).*$/) {
				$1
			}
			id != fileName ? id : false
		end

		def getTrackFilePrefix(track)
			"#{@fileDirectory}/tunewich.#{track['id']}"
		end

		# @typedef DownloadOptions
		# @property audioFormat (see youtube-dl --audio-format)
		# @property feedbackPath {string} defaults to '/dev/null'
		# @property streamPath {string} defaults to nil

		# @param track Track
		# @param options DownloadOptions
		# @returns string download command
		def getDownloadCommand(track, options = nil)
			downloadCommand = ''
			options ||= {}
			options['feedbackPath'] ||= '/dev/null'

			# TODO 1gparD: output youtube-dl error messages to user
			if @youtubeDLTrackTypes.include? track['type']
				youtubeDlCommandBegin = "youtube-dl -f #{@preferredFileFormat} -q"
				# youtubeDlCommandBegin = "youtube-dl -f #{@preferredFileFormat} --no-part --no-cache-dir --no-continue"
				youtubeDlCommandEnd = "-- #{track['src']}"
				if options['streamPath']
					downloadCommand = "rm -f -- --Frag*; #{youtubeDlCommandBegin} -o - #{youtubeDlCommandEnd} > \"#{options['streamPath']}\" 2> \"#{options['feedbackPath']}\""
				else
					youtubeDlOptions = ''
					if options
						youtubeDlOptions += " --audio-format #{options['audioFormat']} " if options.has_key? "audioFormat"
					end
					youtubeDlOptions += " -o \"#{getTrackFilePrefix track}.%(title)s.%(ext)s\""
					downloadCommand = "#{youtubeDlCommandBegin}#{youtubeDlOptions} #{youtubeDlCommandEnd}"
				end
			else
				if options['streamPath']
					downloadCommand = "curl -sL \"#{track['src']}\" > #{options['streamPath']}"
				else
					downloadCommand = "curl -sL \"#{track['src']}\" > #{getTrackFilePrefix track}.mp3" #FIXME 1gpanQ: don't assume mp3 file extension
				end
			end

			downloadCommand
		end

		# @param track hash
		# @param options DownloadOptions
		# @returns integer PID of download process, or nil if download failed
		def downloadTrack(track, options = nil)
			if !@networkEnabled
				whisper("not downloading --no-network", 0)
				return
			end

			options ||= {}

			downloadPid = nil
			downloadFeedbackFileName = 'download-feedback'
			options['feedbackFile'] ||= createTempFile downloadFeedbackFileName
			downloadCommand = getDownloadCommand track, options

			whisper(downloadCommand, 3)
			if options['streamPath']
				downloadPid = spawn(downloadCommand) # spawn: non-blocking
			else
				trigger 'download_begin', track
				Thread.new {
					downloadPid = system(downloadCommand) # system: blocking
					if trackFileExists? track
						loadLibrary
						@library['x.hosts'][$hostname] ||= {'hostname' => ENV['HOSTNAME']}
						@library['x.hosts'][$hostname]['downloaded'] ||= []
						@library['x.hosts'][$hostname]['downloaded'] << track['id']
						writeLibraryToFile
						trigger 'download_success', track
					else
						trigger 'download_fail', track
					end
					trigger 'download_end', track
				}
			end

			deleteTempFile downloadFeedbackFileName

			downloadPid
		end

		def notify(message)
			if @configuredVerbosity > 0
				if UNAME == 'Linux'
						`notify-send --expire-time=3000 --urgency=low tunewich "#{message}"`
				elsif UNAME == 'Darwin'
					clean_message = message.gsub(/"/, '\\"').gsub(/'/, "'\"'\"'"); # what a mess: escaped double-quoted string in applescript, as single-quoted arg to osascript, as double-quoted string in ruby
					notifyCommand = "osascript -e 'display notification \"#{clean_message}\" with title \"tunewich\"' &>/dev/null"
					whisper(notifyCommand, 3);
					system notifyCommand
				end
			end
		end

		def titleBlock(message, fill = '=')
			width = `tput cols`.chomp.to_i
			blockRow = fill * width
			padding = '	'
			marginSize = (width - message.length) / 2 - padding.length
			marginLeft = marginSize > 1 ? fill * marginSize : ''
			marginRight = marginLeft
			marginRight += fill if (width - message.length) % 2 == 1
			puts "\n#{blockRow}"
			puts "#{marginLeft}#{padding}#{message}#{padding}#{marginRight}"
			puts blockRow
			notify message
		end

		def updateRadioMetadata metadata
			if @streamingServerType == 'homebrew'
				serverUsername = 'admin'
				serverPassword = 'hackme'
				serverHost = 'localhost:8000'
				serverMountName = 'radio'
				# ruby 2.3.1 `open` doesn't support userinfo (user:password@host)
				`curl -s "http://#{serverUsername}:#{serverPassword}@#{serverHost}/admin/metadata?mount=/#{serverMountName}&mode=updinfo&song=#{URI::encode metadata}"`
			end
		end

		##
		# File Methods
		##

		def getTempFilePath(name, shouldIncludeSessionID = true)
			nameSegments = ["tunewich"]
			nameSegments << @sessionID if shouldIncludeSessionID
			nameSegments << name
			"#{$tunewichTmpDirectory}/#{nameSegments.join '-'}"
		end

		def createTempFile(name)
			whisper("make tmp #{name}", 4)
			putInTempFile name, ''
		end

		def putInTempFile(name, value, shouldIncludeSessionID = true)
			path = getTempFilePath(name, shouldIncludeSessionID)
			# FIXME 1gpani: why does this stall when writing to a FIFO before something is reading from it?
			Thread.new {
				# FIXME 1gpani: trying to put it in a new thread...maybe won't fix the problem, but it will unblock the main thread.
				writeResult = File.write(path, value)
				whisper("#{name} << '#{value.chomp}' (#{writeResult})", 5)
			}
			path
		end

		def readTempFile(name, shouldIncludeSessionID = true)
			whisper("read tmp #{name}", 5)
			path = getTempFilePath(name, shouldIncludeSessionID)

			if File.exist? path
				whisper("read tmp #{name}: exists", 5)
				contents = File.read path
				# whisper("read tmp #{name}, contents: #{contents}", 5)
				return contents
			else
				whisper("read tmp #{name}: missing", 5)
				return ''
			end
		end

		def tailTempFile(name, shouldIncludeSessionID = true)
			whisper("tail tmp #{name}", 5)
			content = readTempFile(name, shouldIncludeSessionID)
			lastLine = ''
			if content && content.length > 0
				lastLine = content.gsub("\r","\n").lines.pop.strip.chomp
			end
			lastLine
		end

		def deleteTempFile(name, shouldIncludeSessionID = true)
			whisper("delete tmp #{name}", 4)
			path = getTempFilePath(name, shouldIncludeSessionID)

			if File.exist? path
				File.delete path
				if @tempFiles.has_key? path
					@tempFiles.delete path
				end
			end
		end

		def makeStream(name)
			path = getTempFilePath name
			whisper("mkfifo #{path}", 4)

			if File.exist? path
				File.delete path
				# raise "The temp file '#{name}' already exists. (#{path})"
			end

			if not system "mkfifo \"#{path}\""
				raise "ERROR: Could not create the stream file (#{path})"
			end

			if File.exist?(path)
				@tempFiles[path] = true
			else
				path = nil
			end

			path
		end

		alias deleteStream deleteTempFile

		##
		# Library Methods
		##

		def usePlaylist(name, append = false)
			@playlistName = name
			tracks = []

			if @library['playlists'][@playlistName]['tracks']
				@library['playlists'][@playlistName]['tracks'].each do |trackReference|
					tracks << @library['tracks'][trackReference]
				end
			end

			useTracks tracks, append
		end

		def useEntireLibrary
			tracks = []

			@library['tracks'].keys.each do |trackKey|
				tracks << @library['tracks'][trackKey]
			end

			useTracks tracks, false
		end

		def processLibraryJSON(json)
			libraryData = {
				:json => json,
				:hash => Digest::MD5.hexdigest(json),
				:data => nil
			}

			begin
				libraryData[:data] = JSON.parse(json)
			rescue
				whisper("Invalid JSON.", 0)
			end


			libraryData
		end

		def addMarkToTrack track, time
			track['mark'] = getDurationStringFromSeconds time
			@library["lastMarked"] = track["id"]
		end

		def removeMarkFromTrack track
			if track.has_key? 'mark'
				track.delete 'mark'
			end
		end

		def loadLibrary
			libraryInfo = processLibraryJSON File.read(@libraryFilePath)
			if libraryInfo && libraryInfo[:data]
				@library = libraryInfo[:data]
				@libraryHash = libraryInfo[:hash]
				if @tracks && @tracks.length > 0
					@tracks.each_with_index { |track, index|
						@tracks[index] = matchExistingLibraryTrack(@tracks[index])
					}
				end
			end
		end

		# TODO: 1gG4jL
		def writeLibraryToFile shouldPrompt = false
			if shouldPrompt && !@writeEnabled
				return if !confirm("Write changes to library?")
			end
			libraryJSON = JSON.pretty_generate(@library)
			# FIXME 1gpb0C
			if not libraryJSON || libraryJSON == 'null' || libraryJSON.length < 1
				putsRealtime "Sorry! The loaded library has been corrupted. Please restart the player if you want to save any changes to your library."
				return
			end
			libraryOnFile = processLibraryJSON File.read(@libraryFilePath) # since we're writing, no need to check for libraryOnFile[:data], right?
			if @libraryHash == libraryOnFile[:hash] || confirm("Library file has changed since last load. Overwrite?")
				libraryInfo = processLibraryJSON libraryJSON
				File.write(@libraryFilePath, libraryJSON)
				@libraryHash = libraryInfo[:hash]
				whisper("Saved change to library file.", 2)
			end
		end

		def removeTrackFromLibrary(id)
			whisper("Removing track (#{id}) from library", 2)
			@library['tracks'].delete id
			@library['playlists'].each { |playlistName, playlist|
				index = playlist['tracks'].index id
				if index
					playlist['tracks'].delete_at index
				end
			}
			@library['tags'].each { |tagName, tag|
				index = tag.has_key?('tracks') ? tag['tracks'].index(id) : nil
				if index
					tag['tracks'].delete_at index
				end
			}
		end

		def interactiveCleanup
			commands = {
			}

			confirmMsg = "Choose a command, or \"y\" to write changes to file"
			if confirm confirmMsg, commands
				writeLibraryToFile
			else
				whisper("No changes saved.", 0)
			end

			whisper("Cleanup finished.", 0)
		end

		def determineRelativeSpeed input, track, shouldSetPlayingBPM = false
			relativeSpeed = input.to_f
			whisper("relativeSpeed: #{input} -> #{relativeSpeed}", 3)
			if input.to_s.match(/bpm$/)
				if track.has_key? 'bpm'
					inputBPM = relativeSpeed
					if shouldSetPlayingBPM
						@playingBPM = inputBPM
						whisper("Setting playing BPM to #{@playingBPM}", 1)
					end
					relativeSpeed = inputBPM / track['bpm']
				else
					relativeSpeed = nil
				end
			end
			relativeSpeed
		end

		def matchPropertyWithRangeString rangeString, hash, property
			rangeParts = " #{rangeString} ".split('-')
			isAMatch = false
			if hash.has_key? property
				if rangeParts.length == 2
					lowerMatch = rangeParts[0] == " " || hash[property] >= rangeParts[0].to_i
					upperMatch = rangeParts[1] == " " || hash[property] <= rangeParts[1].to_i
					isAMatch = lowerMatch && upperMatch
				else
					isAMatch = rangeParts[0].to_i == hash[property].to_i
				end
			end
			isAMatch
		end

		def getDescendantTagNames ancestorTagName, depth = 0
			whisper("getDescendantTagNames: depth #{depth}", 4)
			allDescendantTags = []
			@library['tags'].each { |tagName, tag|
				if tag.has_key?('parents') && tag['parents'].include?(ancestorTagName)
					allDescendantTags << tagName
					whisper("#{ancestorTagName} #{">" * (depth + 1)} #{tagName}", 4)
					allDescendantTags += getDescendantTagNames tagName, (depth + 1)
				end
			}
			allDescendantTags
		end

		def getAncestorTagNames descendantTagName, depth = 0
			whisper("getAncestorTagNames(descendantTagName:#{descendantTagName}, depth:#{depth})", 4)
			allAncestorTags = []
			if @library['tags'].has_key? descendantTagName
				whisper("tag #{descendantTagName} has a definition", 5)
				thisTag = @library['tags'][descendantTagName]
				if thisTag && thisTag['parents']
					whisper("thisTag['parents'].each ", 5)
					thisTag['parents'].each { |tagName|
						whisper("tagName: #{tagName}", 5)
						allAncestorTags << tagName
						whisper("#{descendantTagName} #{"<" * (depth + 1)} #{tagName}", 4)
						allAncestorTags += getAncestorTagNames tagName, (depth + 1)
					}
				end
			else
				whisper("tag #{descendantTagName} is referenced as a parent, but has no definition of its own", 5)
			end
			whisper("allAncestorTags.uniq", 5)
			allAncestorTags.uniq
		end

		def filterTracks tracks, filters, isExcludeFilter = false
			action = isExcludeFilter ? 'delete_if' : 'keep_if'

			if filters.has_key? 'local'
				tracks.send(action) { |t|
					trackFileExists? t
				}
			end

			if filters.has_key? 'rating'
				if filters['rating'] && filters['rating'].length > 0
					whisper("filtering tracks with rating in range #{filters['rating']}", 3)
					tracks.send(action) { |t|
						matchPropertyWithRangeString filters['rating'], t, 'rating'
					}
				else
					whisper("filtering tracks with any rating", 3)
					tracks.send(action) { |t| t.has_key? 'rating' }
				end
			end

			if filters.has_key? 'tag'
				if filters['tag']
					whisper("filtering tracks with the tag filter #{filters['tag']}", 3)
					# TODO: 1gG4jN
					selectedTags = []
					unionTagTracks = []
					filterTags = filters['tag'].split(' ')
					descendantFilterTags = []
					filterTags.each { |tagName| descendantFilterTags += getDescendantTagNames(tagName).map {|name| "+#{name}"} }
					filterTags += descendantFilterTags
					filterTags.each { |tagName|
						unionPattern = /^\+/
						isUnionTag = tagName.match unionPattern
						tagName.sub!(unionPattern, '') if isUnionTag
						if @library['tags'].has_key? tagName
							selectedTags << {:name => tagName, :tag => @library['tags'][tagName], :union => isUnionTag}
							if isUnionTag && @library['tags'][tagName]['tracks']
								unionTagTracks += @library['tags'][tagName]['tracks'];
							end
						else
							@library['tags'].each { |name, libraryTag|
								if libraryTag['aliases']
									libraryTag['aliases'].each { |tagAlias|
										if tagAlias == tagName
											selectedTags << {:name => name, :tag => libraryTag, :union => isUnionTag}
											if isUnionTag && @library['tags'][tagName]['tracks']
												unionTagTracks += @library['tags'][tagName]['tracks']
											end
										end
									}
								end
							}
						end
					}

					whisper("expanded filter tag list with descendants: #{selectedTags}", 4)
					if selectedTags.length > 0
						# TODO 1gG4jP: make a list of IDs and filter tracks against it once, rather than filtering separately for each tag @performance
						selectedTags.each { |tagInfo|
							tracks.send(action) { |t| tagInfo[:tag]['tracks'] && tagInfo[:tag]['tracks'].index(t['id']) || unionTagTracks.index(t['id']) }
						}

						if unionTagTracks.length > 0
							tracks.sort! { |a, b| unionTagTracks.count(b['id']) <=> unionTagTracks.count(a['id']) }
						end
					else
						whisper("No matches for \"#{filters['tag']}\". Available tags are: #{listAllTagsWithAliases.join ", "}", 0)
					end
				else
					whisper("filtering tracks that have any tags", 3)
					@library['tags'].each { |name, libraryTag|
						tracks.send(action) { |t|
							libraryTag['tracks'] && libraryTag['tracks'].index(t['id'])
						}
					}
				end
			end

			if filters.has_key? 'bpm'
				if filters['bpm'] && filters['bpm'].length > 0
					whisper("filtering tracks with bpm matching #{filters['bpm']}", 3)
					tracks.send(action) { |t|
						matchPropertyWithRangeString filters['bpm'], t, 'bpm'
					}
				else
					whisper("filtering tracks with bpm data", 3)
					tracks.send(action) { |t| t.has_key? 'bpm' }
				end
			end

			if filters['title']
				whisper("filtering tracks with title matching #{filters['title']}", 3)
				matches = fuzzyStringSearchInList(filters['title'], getTrackTitles(tracks))
				matches.sort! { |a,b| b[:density] <=> a[:density] }
				matchedIds = []
				matchesByTrackTitle = {}
				matches.each { |match|
					track = tracks[match[:index]]
					matchedIds << track['id']
					matchesByTrackTitle[track['title']] = match
				}
				tracks.send(action) { |t| matchedIds.include? t['id'] }
				if !isExcludeFilter
					tracks.sort! { |a,b| matchesByTrackTitle[b['title']][:density] <=> matchesByTrackTitle[a['title']][:density] }
				end
			end

			if filters['last']
				whisper("filtering tracks with playtime within the last #{filters['last']}", 3)
				now = Time.now.to_i
				watershed = now - getSecondsFromDurationString(filters['last']).to_i
				tracks.send(action) { |t|
					t['lastPlayed'] ? t['lastPlayed'].to_i >= watershed : false
				}
			end

			if filters['min-duration']
				whisper("Filtering tracks with duration of at least #{filters['min-duration']}", 3)
				minDuration = getSecondsFromDurationString filters['min-duration']
				tracks.send(action) { |t|
					t['duration'] ? getSecondsFromDurationString(t['duration']) > minDuration : false
				}
			end

			if filters.has_key? 'chapters'
				whisper("Filtering tracks with chapters", 3)
				tracks.send(action) { |track|
					if track
						track.has_key? 'chapters'
					else
						false
					end
				}
			end

			putsRealtime "#{tracks.length} matches for filters"

			tracks
		end

		def listAllTagsWithCountsAndAliases
			allTagNames = []

			@library['tags'].each { |name, libraryTag|
				# ignore tracks that have no tracks assigned
				if libraryTag['tracks'] && libraryTag['tracks'].length > 0
					entryParts = [name]

					if libraryTag['aliases'] && libraryTag['aliases'].length > 0
						entryParts << "[#{libraryTag['aliases'].join(', ')}]"
					end

					entryParts << "(#{libraryTag["tracks"].length})"

					allTagNames << entryParts.join('')
				end
			}

			# sort in descending order of # of tracks with that tag
			allTagNames.sort { |a,b| b.sub(/.*\((\d+)\).*/, '\1').to_i <=> a.sub(/.*\((\d+)\).*/, '\1').to_i }
		end

		def listAllTagsWithAliases
			allTagNames = []

			@library['tags'].each { |name, libraryTag|
				allTagNames << name
				if libraryTag['aliases']
					libraryTag['aliases'].each { |tagAlias| allTagNames << tagAlias }
				end
			}

			allTagNames.sort
		end

		def createPlaylist name, tracks = [], description = ''
			newPlaylist = {
				'description' => description,
				'public' => true,
				'tracks' => tracks
			}
			@library['playlists'][name] = newPlaylist
		end

		def createTrack url, type
			newTrack = {
				'type' => type,
				'unattached' => true
			}

			if type == 'youtube'
				newTrack['src'] = looksLikeAYouTubeID?(url) ? url : getYoutubeIdFromUrl(url)
				newTrack['id'] = newTrack['src']
			elsif type == 'ocremix'
				newTrack['src'] = url # TODO: 1gG4jS
				newTrack['id'] = getIDFromOCRemixURL url
			else
				newTrack['src'] = url
				newTrack['id'] = Digest::MD5.hexdigest(url).to_s
			end

			newTrack
		end

		def getYouTubeTrackInfo youtubeVideoID
			track = {
				'type' => 'youtube',
				'src' => youtubeVideoID,
				'id' => youtubeVideoID
			}
			if !@networkEnabled
				whisper("no getYouTubeTrackInfo --no-network", 0)
				return track
			end
			json = `youtube-dl -j -- #{youtubeVideoID} 2>/dev/null` # suppress errors
			return track if !json || json.length == 0

			trackInfo = JSON.parse(json)
			track['title'] = trackInfo['fulltitle']
			track['duration'] = getDurationStringFromSeconds(trackInfo['duration']), 0
			track['description'] = trackInfo['description']
			track['link'] = trackInfo['webpage_url'] || "https://youtu.be/#{youtubeVideoID}"
			track['type'] = trackInfo['extractor']
			track['sourceTags'] = trackInfo['tags'] if trackInfo['tags']
			whisper("sourceTags: #{trackInfo['tags']}", 4)

			track
		end

		def getSoundcloudTrackInfo soundcloudURL
			track = {
				'type' => 'soundcloud',
				'src' => soundcloudURL,
				'id' => Digest::MD5.hexdigest(soundcloudURL).to_s
			}
			if !@networkEnabled
				whisper("no getSoundcloudTrackInfo --no-network", 0)
				return track
			end
			json = `youtube-dl -j -- #{soundcloudURL} 2>/dev/null` # suppress errors
			return track if !json || json.length == 0

			trackInfo = JSON.parse(json)
			track['title'] = trackInfo['fulltitle']
			track['duration'] = getDurationStringFromSeconds(trackInfo['duration'])
			track['description'] = trackInfo['description']
			track['link'] = trackInfo['webpage_url'] || soundcloudURL
			track['type'] = trackInfo['extractor']
			track['sourceTags'] = trackInfo['tags'] if trackInfo['tags']
			whisper("sourceTags: #{trackInfo['tags']}", 4)

			track
		end

		def updateTrackInfo track, trackInfo = nil, force = false
			if track['type'] === 'youtube'
				trackInfo ||= getYouTubeTrackInfo track['id']
			elsif track['type'] === 'soundcloud'
				trackInfo ||= getSoundcloudTrackInfo track['src']
			end
			if trackInfo
				track['title'] = trackInfo['title'] if (!track['title'] || force) && trackInfo['title'] && trackInfo['title'].length > 0

				if (!track['description'] || force) && trackInfo['description'] && trackInfo['description'].length > 0
					if !track['chapters'] || force
						chapters = getChaptersFromDescription trackInfo['description'].lines
						track['chapters'] = chapters if chapters && chapters.length > 0
					end
				end

				track['duration'] = trackInfo['duration'] if trackInfo['duration']
				track['link'] = trackInfo['url'] if trackInfo['url']
				track['type'] = trackInfo['type'] if	trackInfo['type']
			end

			track
		end

		def getChaptersFromDescription description
			description.grep(/[0-9]+:[0-9:.]+/).map! do |line|
				matches = line.match(/^(.*?)[ (]*([0-9]+:[0-9:.]+)[ )]*(.*)$/)
				{
					'time' => matches[2],
					'text' => "#{matches[1]} #{matches[3]}".gsub(/^[^0-z]/, '').strip
				}
			end
		end

		def addTrackToLibrary track
			track.delete 'unattached' if track.has_key? 'unattached'
			trackReference = track['id']
			track['dateAdded'] = Time.now.to_i
			@library['tracks'][trackReference] ||= track

			trackReference
		end

		def addTrackReferenceToPlaylist trackReference, playlistName
			track = @library['tracks'][trackReference]

			if !@library['playlists'][playlistName].has_key?('tracks') || !@library['playlists'][playlistName]['tracks'].include?(trackReference)
				@library['playlists'][playlistName]['tracks'] ||= []
				@library['playlists'][playlistName]['tracks'] << trackReference
				whisper("Saved '#{track['title']}' (#{trackReference}) to playlist '#{playlistName}'", 0)
			else
				whisper("Track '#{track['title']}' (#{trackReference}) is already in playlist '#{playlistName}'", 0)
			end
		end

		##
		# YouTube Methods
		##

		def looksLikeAYouTubeID? string
			youtubeIdPattern = /^[A-Za-z0-9_-]{11}$/
			!! string.match(youtubeIdPattern)
		end

		def getYoutubeIdFromUrl url
			youtubeIDInURLPattern = /^.*youtu(\.be\/|be\.com.*v=)([^&\/]+)/
			matches = url.match(youtubeIDInURLPattern)
			matches ? matches[2] : false
		end

		def searchYouTube query, offset = 0, count = 20
			# FIXME 1gpaoG: sometimes the STDIN is not editable after this
			whisper("Searching YouTube for '#{query}'", 0)
			resultsPerPage = 20
			page = (offset.to_f / resultsPerPage.to_f).to_i + 1
			queryParameter = URI::encode(query)
			queryUrl="https://www.youtube.com/results?search_query=#{queryParameter}&page=#{page}"
			getYouTubeTracksFromPage queryUrl
		end

		def getValidYouTubeURI uri
			looksLikeAYouTubeID?(uri) ? "https://www.youtube.com/watch?v=#{uri}" : uri
		end

		def getYouTubeTracksFromPage url
			if !@networkEnabled
				whisper("no getYouTubeTracksFromPage --no-network", 0)
				return false
			end
			url = getValidYouTubeURI url
			queryResultIds = []
			whisper("reading URL #{url}", 2)
			open(url) do |handle|
				whisper("received URL #{url}", 4)
				html = []
				handle.each_line { |line| html << line }

				queryResultIds = html.grep(/href="(.*youtube.*)?\/watch/).map! do |line|
					line.sub!(/^.*watch\?v=([^\"&<]+).*\n/, '\1')
				end

				queryResultIds.uniq!
			end

			threads = []
			resultTracks = []
			receivedCount = 0
			printRepeat "Getting track information (#{receivedCount}/#{queryResultIds.length})"

			queryResultIds.each_with_index do |id, index|
				track = matchExistingLibraryTrack createTrack(id, 'youtube')
				resultTracks << track
				whisper("starting a new thread to get track info for #{track['id']}", 4)
				threads << Thread.new {
					if not updateTrackInfo track
						resultTracks.delete track
					end
					receivedCount += 1
					printRepeat "Getting track information (#{receivedCount}/#{queryResultIds.length})"
				}
			end

			whisper("joining 'update info' threads", 4)
			threads.each { |thread| thread.join }
			print "\n"

			resultTracks
		end

		def getSoundcloudRecommendations url
			if !@networkEnabled
				whisper("no getSoundcloudRecommendations --no-network", 0)
				return false
			end
			url = "#{url}/recommended"
			queryResultURLs = []
			open(url) do |handle|
				html = []
				handle.each_line { |line| html << line }

				queryResultURLs = html.grep(/<h2.*itemprop="url"/).map! do |line|
					line.sub!(/^.*<h2.*itemprop="url".*href="([^\"]+)".*\n/, 'https://soundcloud.com\1')
				end

				queryResultURLs.uniq!
			end

			# FIXME 1gpaoS: seems to be skipping the first recommended track

			threads = []
			resultTracks = []
			receivedCount = 0
			printRepeat "Getting track information (#{receivedCount}/#{queryResultURLs.length})"

			queryResultURLs.each_with_index do |recommendedURL, index|
				track = matchExistingLibraryTrack createTrack(recommendedURL, 'soundcloud')
				resultTracks << track
				whisper("starting a new thread to get track info for #{track['src']}", 4)
				threads << Thread.new {
					if not updateTrackInfo track
						resultTracks.delete track
					end
					receivedCount += 1
					printRepeat "Getting track information (#{receivedCount}/#{queryResultURLs.length})"
				}
			end

			whisper("joining 'update info' threads", 4)
			threads.each { |thread| thread.join }
			print "\n"

			resultTracks
		end

		def getOCRemixSource(url)
			source = nil
			if !@networkEnabled
				whisper("no getOCRemixSource --no-network", 0)
				return false
			end

			open(url) do |handle|
				sourcePattern = /^.*href="(https?:\/\/ocrmirror.org[^"]+)".*$/
				sourceLine = handle.lines.grep(sourcePattern)
				if sourceLine && sourceLine.length > 0
					match = sourceLine[0].match sourcePattern
					source = match[1]
					whisper("source: #{source}", 4)
				end
			end

			source
		end

		def getIDFromOCRemixURL(url)
			url.sub(/^.*\/remix\/([^\/?]+).*/, '\1')
		end

		##
		# Utility Methods
		##

		def getDurationStringFromSeconds inputSeconds, roundDigits = 2
			inputSeconds = inputSeconds.to_f
			wholeSeconds = inputSeconds.to_i
			seconds = (inputSeconds % 60).truncate(roundDigits)
			minutes = wholeSeconds / 60 % 60
			hours = wholeSeconds / 3600 % 24
			days = wholeSeconds / 86400

			outputString = ''
			outputString += "#{days}" if days > 0
			outputString += ":#{hours < 10 ? "0#{hours}" : hours}" if hours > 0
			outputString += ":#{minutes < 10 ? "0#{minutes}" : minutes}"
			outputString += ":#{seconds < 10 ? "0#{seconds}" : seconds}"
			outputString.sub(/^:/, '')
		end

		def getSecondsFromDurationString durationString
			seconds = 0
			factor = 1
			factors = [1,60,60,24]

			timecodeRegExpPattern = /^[0-9:.]+$/
			if durationString && durationString.length > 0 && durationString.match(timecodeRegExpPattern)
				durationString.split(':').reverse.each_with_index { |unit, index|
					factor *= factors[index]
					seconds += unit.to_f * factor
				}
			else
				seconds = nil
			end

			seconds
		end

		##
		# UI Methods
		##

		def parseOptions
			output = {}

			parser = OptionParser.new

			parser.on("-a", "--add-track YOUTUBE_URLS", "Add tracks to the library, and to a playlist, if specified. Takes a comma-separated list of YouTube URLs or IDs.", " ") do |urls|
				output[:newTracks] = getTracksFromURLs urls.split(',')
			end

			parser.on("-d", "--download", "Enable downloading files when encountering a file that is not already download.", " ") do |keep|
				@enableDownload = true
			end

			parser.on("-D DIR", "--input-dir DIR", "Directory from which to read the playlist and files.\nNOTE: when used, this must be the first option. Recommended to define TUNEWICH_DIR instead.", " ") do |inputDir|
				# FIXME 1gpaoe: always process this option first, even if it's provided last
				setLibraryPath inputDir
			end

			parser.on("-f RULES", "--filter RULES", Player::FILTER_HELP_1, Player::FILTER_HELP_2, Player::FILTER_HELP_3, " ") do |rules|
				@trackFilters = parseOptionParameters rules
			end

			parser.on("-F FORMAT", "--format FORMAT", "Set the file format to request for streaming or downloading.", " ") do |format|
				@preferredFileFormat = format
			end

			parser.on("-h", "--help", "Show this help.", " ") do
				puts parser.help()
				puts "INTERACTIVE COMMANDS"
				interactiveCommands = getInteractiveCommands(['playing'], 'help')
				showInteractiveCommandHelp(interactiveCommands)
				exit
			end

			parser.on("-l [COUNT]", "--loop [COUNT]", "Loop tracks COUNT times (indefinitely if COUNT is 0 or missing). A track may contain chapters which loop, in which case each loop will be repeated COUNT times.", " ") do |count = 0|
				@loopLimit = count.to_i
				@loop = true
			end

			parser.on("-L FILE", "--log FILE", "Log most verbose output to FILE. This includes events and crosstalk between the script and player", " ") do |logFile|
				$logFilePath = logFile
			end

			parser.on("--loglevel LEVEL", "Set the log verbosity, as with -v, but applying only to logs. By default, all messages are logged.", " ") do |level|
				@logVerbosity = level ? level.to_i : 1
				whisper("Log level: #{@logVerbosity}", 1)
			end

			parser.on("-m MODE", "--mode MODE", "Choose a player mode: #{Player::MODES.keys.join ', '}", " ") do |modeName|
				if Player::MODES.has_key? modeName
					@userMode = modeName
				else
					putsRealtime "#{modeName} is not a valid player mode. Please use one of #{Player::MODES.keys.join ', '}"
				end
			end

			parser.on("-N", "--no-network", "Don't fetch any information or media from the internet. Use only local files.", " ") do
				@networkEnabled = false
				@trackFilters ||= {}
				@trackFilters['local'] = ''
			end

			parser.on("-o OPTIONS", "--player-opts OPTIONS", "Set player options. Set interactively with the /player command. You can also add mplayer options in #{$serviceConfigDir}/mplayer.options (You can find a starting copy in the 'config' directory that came with tunewich). --player-opts will override those options.", " ") do |options|
				# TODO: 1gG4jU
				isFirstElement = true
				@playerOverrideCommands += options.split(' -').map { |option|
					if isFirstElement
						isFirstElement = false
					else
						option = "-#{option}"
					end
					option
				}
			end

			parser.on("-p", "--playlist [NAME]", "Choose or create a playlist. If no NAME/QUERY is given, a name is guessed from other input, such as a -q query", " ") do |playlistQuery|
				output[:playlistQuery] = playlistQuery
			end

			parser.on("-q", "--query QUERY", "Search YouTube for a video.", " ") do |query|
				@youtubeSearch = query
			end

			parser.on("-r", "--rating-prompt [SECONDS]", "Prompt for a rating and tags after every track plays, waiting 5 (or the number given) seconds before continuing to the next track", " ") do |seconds|
				@ratingsPromptDuration = seconds ? seconds.to_i : 5
			end

			parser.on("-R [SERVER_TYPE]", "--radio [SERVER_TYPE]", "TODO: stream to a network radio service (SERVER_TYPE: default 'homebrew' or 'Nicecast'", " ") do |streamingServerType = 'homebrew'| #1gG4jc
				if !streamingServerType || streamingServerType.length == 0
					streamingServerType = 'homebrew'
				end
				@streamingServerType = streamingServerType
				whisper("streamingServerType: #{streamingServerType}", 2)
				isRadioConfigured = true
				whisper("Preparing to start radio (#{streamingServerType}).", 0)
				if streamingServerType == 'homebrew'
					whisper("About to prompt you for your password, so that the darkice server can be run as root.", 0)
					`sudo ls &>/dev/null`
				end
				if UNAME == "Darwin"
					audioDeviceID = `say -a ? | grep 'Soundflower (2ch)'`.chomp.sub(/^\s*(\d+).*/, '\1')
					if audioDeviceID && audioDeviceID.length > 0
						@playerOverrideCommands << "-ao coreaudio:device_id=#{audioDeviceID}"
						jackAudioDeviceAndOptions = "coreaudio -d SoundflowerEngine:0"
					else
						whisper("Please install Soundflower (https://github.com/mattingalls/Soundflower)", 0)
						isRadioConfigured = false
					end
				else
					whisper("Playing to jack server", 2)
					@playerOverrideCommands << "-ao alsa"
					jackAudioDeviceAndOptions = "alsa"
				end

				if isRadioConfigured
					bind 'play_start', Proc.new {
						updateRadioMetadata @currentTrack['title']
					}
					bind 'chapter_change', Proc.new {
						updateRadioMetadata "#{@currentTrack['title']} (#{@currentTrack['chapters'][@currentChapterIndex]['text']})"
					}
					if streamingServerType == 'homebrew'
						icecastConfigFile = "#{$serviceConfigDir}/icecast.xml"
						darkiceConfigFile = "#{$serviceConfigDir}/darkice.cfg"

						if not File.exist? icecastConfigFile
							whisper("Please create the icecast config file at #{icecastConfigFile}.", 0)
							isRadioConfigured = false
						elsif not File.exist? darkiceConfigFile
							whisper("Please create the darkice config file at #{darkiceConfigFile}.", 0)
							isRadioConfigured = false
						end
					else
						whisper("Radio is configured. Ready to play.", 2)
					end
				else
					whisper("Radio is NOT configured. Ready to play.", 2)
				end

				# Currently 2 methods of doing radio:
				# Both have the same first step, using Soundflower.
				# a) Rogue Amoeba's Nicecast (functionaly, not free)
				#		1) mplayer plays to "Soundflower (2ch)" audio device
				#		2) Nicecast captures "Soundflower (2ch)" and streams with its built-in icecast server
				#			i) The capture is probably what's being paid for here, since their other capture tools are also paid.
				# b) jack + darkice + icecast (not currently working)
				#		1) mplayer plays to "Soundflower (2ch)" audio device
				#		2) jackd captures audio from "Soundflower (2ch)" (getting errors)
				# 	3) darkice pushes the jackd audio to the icecast2 server (might be working)
				# 	4) listeners stream music from the icecast2 server (seems to be working)
				#
				# This article from 2012 has some good info, but it may be outdated.
				# http://dzello.com/blog/2012/11/21/live-stream-audio-from-osx-mountain-lion-with-icecast-and-darkice/

				if isRadioConfigured
					if UNAME == 'Darwin'
						puts "#" * 40
						puts "## Open Soundflowerbed and make sure that the volume is all the way up on Soundflower (2ch)."
						puts "## If you mute your system audio, \"Soundflower (2ch)\" may also be muted, so take care not to do that. Open up Soundflowerbed \"Audio Setup\" and unmute \"Soundflower (2ch)\" if that happens."
						puts "#" * 40
					end
					if streamingServerType == 'homebrew'
						@services = []
						whisper("starting jackd (to capture audio)", 2)
						@services << Thread.new { `sudo jackd -d #{jackAudioDeviceAndOptions}` }
						whisper("starting icecast (to stream audio to listeners)", 2)
						if UNAME == 'Darwin'
							@services << Thread.new { `icecast -c "#{icecastConfigFile}"` }
						else
							@services << Thread.new { `icecast2 -c "#{icecastConfigFile}"` }
						end
						darkiceStartDelay = 5.0
						whisper("waiting #{darkiceStartDelay} seconds to start darkice", 2)
						sleep darkiceStartDelay
						whisper("starting darkice (to encode and push audio to streaming server)", 2)
						@services << Thread.new { `sudo darkice -v 10 -c "#{darkiceConfigFile}"` }
					else
						whisper("continue to Nicecast server", 2)
					end
				else
					whisper("Unable to configure radio server.", 0)
				end
			end

			parser.on("-s", "--shuffle", "Enable shuffle.", " ") do
				@shuffle = true
			end

			# parser.on("-S SESSION", "--session SESSION", "Load a session: a set of most options, like filters, track list. Pass no value in order to see a list of sessions available See INTERACTIVE COMMANDS for info on saving a session during playback.", " ") do
			# 	# TODO 1gTpuh
			# end

			parser.on("-t", "--track INDEX/QUERY", "Seek to the given track (either by its number in the list, or by its name).", " ") do |trackQuery|
				if trackQuery.to_i != 0
					@trackIndex = trackQuery.to_i - 1
				else
					@trackIndex = findTrackIndex(trackQuery) || nil
					if @trackIndex
						whisper("Going to track #{@trackIndex + 1}.", 2)
					else
						whisper("Could not find track by query '#{trackQuery}'.", 0)
					end
				end
			end

			parser.on("-U", "--update-track-info", "Fetch updated track information for every track played.", " ") do
				@updateAllPlayedTrackInfo = true
			end

			parser.on("-v [LEVEL]", "--verbose", "Chatter about what's going on (more detailed or frequent messages are in levels 2 or 3.", " ") do |level|
				@configuredVerbosity = level ? level.to_i : 1
				whisper("Verbosity level: #{@configuredVerbosity}", 1)
			end

			parser.on("-w", "--write [SECONDS]", "Save changes to the library. If SECONDS are given, only tracks played that many seconds will be written.", " ") do |seconds|
				@writeEnabled = true
				@writeAfterSecondsPlayed = seconds ? seconds.to_f : 0.0
			end

			parser.on("-x", "--exclude-filter RULES", "Excludes tracks matching the rules. See --filter", " ") do |rules|
				@trackExcludeFilters = parseOptionParameters rules
			end

			unparsedOptions = parser.parse(ARGV)
			whisper("unparsed options: #{unparsedOptions}", 4)

			output
		end

		def doOptionSecondaryActions optionsOutput

			if not @fileDirectory
				whisper("please specify an input directory with -i", 0)
				exit
			end

			if @youtubeSearch && @networkEnabled
				@youtubeSearchPage = 1
				searchedTracks = searchYouTube @youtubeSearch
				useTracks searchedTracks if searchedTracks
			end

			if optionsOutput.has_key? :playlistQuery
				if optionsOutput[:playlistQuery]
					match = firstFuzzyMatch optionsOutput[:playlistQuery], @library['playlists'].keys

					if match && match[:score] > 1 # FIXME 1gpaoq: what's a good baseline score for a playlist match?
						playlistName = match[:value]
					elsif confirm("Create new playlist #{optionsOutput[:playlistQuery]}?")
						playlistName = optionsOutput[:playlistQuery]
					end
				elsif @youtubeSearch
					playlistName = @youtubeSearch
				end

				if playlistName
					if not @library['playlists'].has_key? playlistName
						whisper("Creating new playlist: #{playlistName}", 0)
						createPlaylist playlistName
						writeLibraryToFile
					end

					usePlaylist playlistName, true
				end
			end

			if optionsOutput.has_key? :newTracks
				optionsOutput[:newTracks].each { |newTrack|
					if 0 == @writeAfterSecondsPlayed
						trackReference = addTrackToLibrary newTrack
						addTrackReferenceToPlaylist trackReference, @playlistName if @playlistName
					end
					@tracks << newTrack
				}
				writeLibraryToFile true
			end
		end

		def getTracksFromURLs(urls)
			tracks = []

			def getHTTPHeaderByPattern(head, pattern)
				value = nil
				if head
					matchingLines = head.lines.keep_if { |line| line.match(pattern) }
					if matchingLines && matchingLines.length > 0
						value = matchingLines.last.chomp.sub pattern, '\1'
					end
				end
				value
			end

			urls.each { |url|
				urlCanBeScraped = true # assuming this for now
				if url.match(/ocremix\.org\/remix/)
					tracks << matchExistingLibraryTrack(createTrack(url, 'ocremix'))
					whisper("This URL contains an OC Remix ID. Adding.", 0)
				elsif looksLikeAYouTubeID? url
					youtubeId = url
				else
					youtubeId = getYoutubeIdFromUrl url
				end

				if youtubeId
					tracks << updateTrackInfo(matchExistingLibraryTrack(createTrack(youtubeId, 'youtube')))
					whisper("This URL contains a YouTube ID. Adding.", 0)
				else
					urlHTTPHead = `curl -sL --head "#{url}"`
					urlContentType = getHTTPHeaderByPattern urlHTTPHead, /^Content-Type: ([^;]*).*/i
					cookieDomain = getHTTPHeaderByPattern urlHTTPHead, /^Set-Cookie:.*domain=([^;]*).*/i
					whisper("urlContentType: #{urlContentType}, cookieDomain: #{cookieDomain}", 3)
					if 'text/html' == urlContentType && (cookieDomain == '.bandcamp.com' || url.match(/(https?:\/\/)([^\.]+)\.bandcamp\.com.*/))
						whisper("WIP: scraping bandcamp page")
						urlCanBeScraped = false
						bandcampTracks = loadBandcamp url
						tracks += bandcampTracks if bandcampTracks
					elsif 'text/html' == urlContentType && cookieDomain == '.soundcloud.com'
						whisper("WIP: getting soundcloud track")
						urlCanBeScraped = false
						soundcloudTracks = loadSoundcloud url
						tracks += soundcloudTracks if soundcloudTracks
					elsif urlContentType && ['text/xml', 'application/rss+xml'].include?(urlContentType) # TODO: 1gG4kV
						whisper("WIP: try to load podcast feed")
						urlCanBeScraped = false
						podcastTracks = loadPodcast url
						tracks += podcastTracks if podcastTracks
					else
						urlCanBeScraped = false
						whisper("assuming that URL is an audio file. Adding as a track", 3)
						track = createTrack(url, urlContentType)
						whisper("track: #{track}", 3)
						track = matchExistingLibraryTrack(track)
						whisper("track (after matching existing): #{track}", 3)
						tracks << track
						whisper("added: #{tracks.last}", 3)
					end
				end

				begin
					if urlCanBeScraped && confirm("Look for all tracks on this page?")
						youTubeTracks = getYouTubeTracksFromPage url
						tracks.concat youTubeTracks if youTubeTracks
					end
				rescue Exception => e
					whisper("Trouble scraping this page: #{e.message}\nbacktrace: #{e.backtrace.join "\n"}", 0) # TODO: well you give it some...Trouble.
				end
			}

			whisper("Added these tracks: #{tracks.join(', ')}", 3)
			tracks
		end

		def loadPodcast url
			feedAlreadyInLibrary = false
			@library['feeds'] ||= []
			@library['feeds'].each { |feed|
				if feed['src'] == url
					feedAlreadyInLibrary = true
					break
				end
			}
			feedXML = `curl -sL "#{url}"`
			feedDoc = REXML::Document.new(feedXML)
			if not feedDoc
				whisper("bad feed XML", 3)
				whisper(feedXML, 4)
				return nil
			end
			channel = REXML::XPath.first(feedDoc, '//rss/channel')
			if not feedAlreadyInLibrary
				podcastFeed = {
					'title' => REXML::XPath.first(channel, 'title').text,
					'description' => REXML::XPath.first(channel, 'description').text,
					'src' => url,
					'type' => 'podcast',
					'dateAdded' => Time.now.to_i
				}
				@library['feeds'] << podcastFeed
				writeLibraryToFile
			end
			podcastTracks = []
			REXML::XPath.each(channel, 'item') { |itemElement|
				whisper("itemElement: #{itemElement}", 4)
				enclosure = REXML::XPath.first(itemElement, 'enclosure')
				if enclosure
					newTrack = createTrack(enclosure.attribute('url').to_s.gsub('&amp;', '&'), enclosure.attribute('type').to_s || 'audio/mpeg')
					newTrack['title'] = REXML::XPath.first(itemElement, 'title').text.chomp
					descriptionElement = REXML::XPath.first(itemElement, 'itunes:summary') || REXML::XPath.first(itemElement, 'description')
					newTrack['description'] = descriptionElement.text.chomp
					durationElement = REXML::XPath.first(itemElement, 'itunes:duration')
					newTrack['duration'] = durationElement.text.chomp if durationElement
					linkElement = REXML::XPath.first(itemElement, 'link')
					newTrack['link'] = linkElement.text.chomp if linkElement
					whisper("newTrack: #{newTrack}", 4)
					podcastTracks << newTrack
				else
					whisper("This RSS item does not have an enclosure, i.e. no link to the audio", 3)
				end
			}
			podcastTracks.reverse # put the oldest ones first
		end

		def loadBandcamp url
			whisper("loadBandcamp #{url}", 3)
			tracks = []
			open(url) do |handle|
				handle.each_line { |line|
					matchResults = line.match(/^\s*trackinfo: (.*?),?$/)
					if matchResults
						whisper("loadBandcamp: found trackinfo: #{matchResults[1]}", 3)
						trackinfo = JSON.parse matchResults[1]
						if trackinfo
							whisper("loadBandcamp: trackinfo is valid JSON", 3)
							trackinfo.each { |bandcampTrack|
								if bandcampTrack.has_key?('file') && bandcampTrack['file'].has_key?('mp3-128')
									whisper("loadBandcamp: found track file #{bandcampTrack['file']['mp3-128']}", 3)
									fileURL = bandcampTrack['file']['mp3-128']
									fileURL = "http:#{fileURL}" if fileURL.match(/^\/\//)
									track = createTrack(fileURL, 'audio/mpeg')
									track['title'] = bandcampTrack['title'] if bandcampTrack.has_key?('title')
									if bandcampTrack.has_key?('title_link')
										urlDomain = url.sub(/((^(https?:)?\/\/)?[^\/]+).*/, '\1')
										track['link'] = "#{urlDomain}#{bandcampTrack['title_link']}"
									end
									tracks << track
								end
							}
						end
					end
				}
			end
			tracks
		end

		def loadSoundcloud url
			whisper("loadSoundcloud #{url}", 3)
			tracks = [createTrack(url, 'soundcloud')]
			whisper("tracks: #{tracks}", 3)
			tracks
		end

		def encodeOptionParameters hash
			clumps = []
			hash.each { |key, value|
				clumps << "#{key}=#{value}"
			}
			clumps.join ','
		end

		def parseOptionParameters serialized
			hash = {}
			# TODO: 1gG4kY

			serialized.split(',').each { |clump|
				pair = clump.split '='
				hash[pair[0]] = pair[1]
			}

			hash
		end

		def printRepeat message, shouldReturnCursorToBeginning = false
			message = message.to_s if message.respond_to? 'to_s'
			outputMessage = "	#{message}"
			print "\r#{$clearLineCharacter}#{$disableWrapCharacter}#{outputMessage}#{$enableWrapCharacter}"
			print "\r" if shouldReturnCursorToBeginning
		end

		def cliRotate
			if not @cliRotateIndex
				@cliRotateIndex = 0
				@cliRotateCharacters = ['==', '\\\\', '||', '//']
			else
				@cliRotateIndex = (@cliRotateIndex + 1) % @cliRotateCharacters.length
			end

			@cliRotateCharacters[@cliRotateIndex]
		end

		def editListInVim list, instructions = nil
			scopedShouldShowRealtimeOutput = @shouldShowPlaybackInfo
			disablePlaybackInfo
			instructions ||= "edit"
			fileDirections = "##\n#{instructions.gsub(/^/, '# ')}\n##"

			editListName = 'edit-list'
			deleteTempFile editListName
			putInTempFile editListName, list.join("\n") + "\n\n" + fileDirections

			system "vim #{getTempFilePath editListName}"

			list = readTempFile(editListName).strip.lines
			list.map! { |line|
				line.sub(/\n/, '')
			}
			list.delete_if { |line| # remove empty and comment lines from the list
				line.match(/^(#.*|\s*)$/)
			}

			deleteTempFile editListName

			whisper(list, 4)

			@shouldShowPlaybackInfo = scopedShouldShowRealtimeOutput

			list
		end

		def editHashInVim map, instructions = nil
			editableList = map.map { |name, value|
				"#{name}: #{value}"
			}
			editedOutput = editListInVim editableList, instructions
			outputHash = {}
			editedOutput.each { |line|
				parts = line.match(/^([^:]+): (.*)/)
				whisper("edited map line: name='#{parts[1]}',	value='#{parts[2]}'", 3)
				outputHash[parts[1]] = parts[2]
			}
			outputHash
		end

		def editTrackList tracks
			editedList = editListInVim(listTrackTitles(tracks), "remove or comment with # any tracks you want to deselect")
			getTracksFromTitleList editedList, tracks
		end

		def showInteractiveCommandHelp commands = nil
			commandInfo = []
			maxCommandNameLength = 0
			sortedCommandList = []
			whisper("gathering command info", 3)
			commands.each { |name, command|
				sortedCommandList << {:name => name, :command => command}
				maxCommandNameLength = name.length if name.length > maxCommandNameLength
			}
			sortedCommandList.sort! { |a,b| a[:name] <=> b[:name] }
			sortedCommandList.each { |commandMeta|
				info = "		/"
				commandPaddingLength = info.length
				info += commandMeta[:name]
				info += " " * (maxCommandNameLength - info.length + commandPaddingLength)
				info += " : #{commandMeta[:command]['description']}" if commandMeta[:command]['description']
				commandInfo << info
			}
			putsRealtime(commandInfo.join("\n"))
			nil
		end

		def processCommandsWithInput commandLoopInput, commands, leftoverAction
			while commandLoopInput && !commandLoopInput.empty? && commandLoopInput[0] == '/'
				whisper("parsing commands, input: #{commandLoopInput}", 3)
				commandParts = commandLoopInput.match(/^\/([^\s]*)\s*(.*)/)
				if commandParts
					commandName = commandParts[1]
					commandInput = commandParts[2]

					if !commands.has_key? commandName
						possibleCommands = fuzzyStringSearchInList(commandName, commands.keys).keep_if{ |c| c[:starts] }.map { |c| c[:value] }
						if possibleCommands.length == 1
							whisper("matched #{commandName} -> #{possibleCommands[0]}", 1)
							commandName = possibleCommands[0]
						else
							commandName = ''
							commandLoopInput = nil
							putsRealtime "Did you mean #{possibleCommands.join ", or "}?" if possibleCommands.length > 1
						end
					end
				else
					commandName = ''
				end

				if commands.has_key? commandName
					commandInfo = {
						:name => commandName,
						:commandLoopInput => commandInput,
						:output => nil
					}
					begin
						commandInfo[:output] = commands[commandName]['action'].call(commandInput, commands[commandName])
					rescue Exception => e
						putsRealtime "There was a problem running '#{commandName}' with input '#{commandInput}'"
						whisper("Exception: #{e.message}\nbacktrace: #{e.backtrace.join "\n"}", 3)
					end
					whisper("command info: #{commandInfo}", 3)
					if commandInfo[:output] && commandInfo[:output][:action]
						whisper("chained command calling action (#{commandInfo[:output][:action]})", 3)
						leftoverAction.call commandInfo[:output][:action]
					end
					if commandInfo[:output] && commandInfo[:output][:chainedInput] && commandInfo[:output][:chainedInput].length > 0
						whisper("chained commandLoopInput: #{commandInfo[:output][:chainedInput]}", 3)
						if commandInfo[:output][:bindChainToEvent]
							commandLoopInput = nil
							whisper("binding deferred chained commands to event '#{commandInfo[:output][:bindChainToEvent]}'", 3)
							bindOnce commandInfo[:output][:bindChainToEvent], Proc.new {
								whisper("running deferred chained commands", 1)
								whisper("deferred commands: #{commandInfo[:output][:chainedInput]}", 2)
								commandLoopInput = processCommandsWithInput(commandInfo[:output][:chainedInput], commands, leftoverAction)
							}, commandInfo[:output][:bindingGroupName]
							break
						else
							commandLoopInput = commandInfo[:output][:chainedInput]
						end
					else
						whisper("no chained commandLoopInput", 3)
						commandLoopInput = nil
						break
					end
				end
				# break if shouldBreakCommandLoop # leftover from bad refactor
			end

			whisper("no more commands to execute (for now)", 3)

			commandLoopInput
		end

		def handleInputLine inputLine, commands, leftoverAction
			@commandHistory.unshift inputLine
			enablePlaybackInfo

			whisper("received input: #{inputLine}", 3)
			if commands
				inputLine = processCommandsWithInput(inputLine, commands, leftoverAction)
			end

			handledActionResponse = true
			if leftoverAction && inputLine && inputLine.length > 0
				whisper("input left over after commands: passing to action (#{inputLine})", 3)
				handledActionResponse = leftoverAction.call inputLine
			end

			handledActionResponse
		end

		def handleInputCharacter inputCharacter, prompt, commands, leftoverAction
			result = true

			if /[\n\r]/.match inputCharacter
				inputLine = @commandUserInput
				@commandUserInput = nil
				actionResponse = handleInputLine(inputLine, commands, leftoverAction) if inputLine

				if actionResponse
					prompt.call
				else
					result = false
				end
			elsif inputCharacter == " " && (!@commandUserInput || @commandUserInput.length == 0) # first space
				togglePlay
			elsif inputCharacter == "" # control-c character
				whisper("interrupt character, is that you?", 3)
				enablePlaybackInfo
				result = false
			elsif inputCharacter == "" # backspace
				if @commandUserInput
					@commandUserInput = @commandUserInput[0,@commandUserInput.length - 1]
					if @commandUserInput.length > 0
						printRepeat @commandUserInput
					else
						@commandUserInput = nil
						enablePlaybackInfo;
					end
				end
			elsif inputCharacter == "" # stop job
				Process.kill("STOP", Process.pid) # TODO: 1gG4ko
			elsif inputCharacter == "" # clear line
				if @commandUserInput
					@commandInputTyped = nil
					@commandUserInput = ''
					printRepeat @commandUserInput
				end
				@commandInputTyped = nil
			else
				if not @commandUserInput
					@commandUserInput = ''
					disablePlaybackInfo
					if inputCharacter == '/'
						@commandinputStartPlayerTime = @currentPlayerTime
					end
				end

				if inputCharacter == "\e[A" # up arrow
					if @commandInputTyped
						matchingCommands = @commandHistory.select { |command|
							command.start_with? @commandInputTyped if command
						}
						if matchingCommands && matchingCommands.length > 0
							@commandUserInput = matchingCommands.last
						end
					else
						@commandHistoryIndex = (@commandHistoryIndex ? @commandHistoryIndex + 1 : 0) % @commandHistory.length
						@commandUserInput = @commandHistory[@commandHistoryIndex]
					end

					printRepeat @commandUserInput
				elsif inputCharacter == "\e[B" # down arrow
					if @commandInputTyped
						matchingCommands = @commandHistory.select { |command|
							command.start_with? @commandInputTyped
						}
						if matchingCommands && matchingCommands.length > 0
							@commandUserInput = matchingCommands.first
						end
					else
						@commandHistoryIndex = (@commandHistoryIndex ? @commandHistoryIndex - 1 : 0) % @commandHistory.length
						@commandUserInput = @commandHistory[@commandHistoryIndex]
					end

					printRepeat @commandUserInput
				elsif inputCharacter == "\e[C" # right arrow
					whisper("TODO: move cursor right", 3)
				elsif inputCharacter == "\e[D" # left arrow
					whisper("TODO: move cursor left", 3)
				elsif inputCharacter == "	" # tab
					whisper("tab completion (TODO: repeat tab to step through matches)", 3)
					if @commandUserInput[0] == "/"
						inputCommands = @commandUserInput.sub(/^\//, '').split(/ \//)
						lastCommandIndex = inputCommands.length - 1
						if lastCommandIndex > -1
							inputParts = inputCommands[lastCommandIndex].match(/^(\w+)( (.*))?/)
							if inputParts
								commandKeys = commands.keys
								commandName = inputParts[1]
								if (
									commandName &&
									commandName.length > 0 &&
									!commands.has_key?(commandName)
								)
									newCommandName = firstFuzzyMatchValue commandName, commandKeys
									if newCommandName
										commandName = newCommandName 
									end
								end

								commandInput = inputParts[3] || ''

								if commands.has_key?(commandName)
									if commandInput.length == 0
										printRepeat "#{commandName}: #{commands[commandName]['description']}\n"
										if commands[commandName].has_key?('args')
											printRepeat commands[commandName]['args'].join("\n") + "\n"
										end
									end

									if commands[commandName].has_key?('tabComplete')
										modifiedCommandInput = commands[commandName]['tabComplete'].call(commandInput, commands[commandName])
										commandInput = modifiedCommandInput if modifiedCommandInput
									elsif commands[commandName].has_key?('args')
										inputParts = commandInput.match(/^([^\/]*)(.*)$/)
										if inputParts[1] && inputParts[1].length > 0
											guessArg = firstFuzzyMatchValue(inputParts[1], commands[commandName]['args'])
											if guessArg && guessArg.length > 0
												commandInput = commandInput.sub!(inputParts[1], guessArg)
											end
										end
									end
								end

								inputCommands[lastCommandIndex] = "#{commandName} #{commandInput}"
							end
							@commandUserInput = "/" + inputCommands.join(' /')
						else
							printRepeat "Availble commands: #{commands.keys.join(", ")}\n"
						end
					end
				else
					@commandUserInput += inputCharacter
					@commandInputTyped = @commandUserInput
				end

				printRepeat @commandUserInput
			end

			result
		end

		def commandPrompt message = nil, commands = nil, action = nil
			shouldBreakCommandLoop = false
			commandLoopExitBinding = bindOnce 'before_exit', Proc.new {
				whisper "before_exit: break command loop", 3
				shouldBreakCommandLoop = true
			}
			whisper("opening command prompt (commandLoopExitBinding: #{commandLoopExitBinding})", 3)

			prompt = Proc.new {
				print "#{message} " if message
				print "$ "
			}
			prompt.call

			whisper("waiting for user input on STDIN", 3)
			@commandHistoryIndex = nil

			@commandUserInput = nil

			externalInputHandlerId = bind('external_input', Proc.new { |extInputChar|
				handleInputCharacter(extInputChar, prompt, commands, action)
				false # stop propagation of event
			}, nil, true);
			externalCommandHandlerId = bind('external_command', Proc.new { |extInput|
				whisper("external_command: #{extInput}", 3)
				handleInputLine(extInput, commands, action) if extInput
				false # stop propagation of event
			}, nil, true);

			while directInputCharacter = readCharacter
				inputResult = handleInputCharacter(directInputCharacter, prompt, commands, action)
				break if shouldBreakCommandLoop || !inputResult
			end

			unbind(commandLoopExitBinding)
			unbind(externalCommandHandlerId)
			unbind(externalInputHandlerId)


			response = {
				:input => @commandHistory[@commandHistory.length - 1] # FIXME: @hack
			}

			whisper("closing command \"#{message}\" prompt (response #{response})", 3)

			response
		end

		def confirm message, commands = nil
			confirmMessage = "#{message} (y/N): "
			confirmed = false
			confirmAction = Proc.new { |input|
				confirmed = input.match(/^[Yy]/)
				!input
			}
			scopedShouldShowRealtimeOutput = @shouldShowPlaybackInfo
			disablePlaybackInfo
			commandPrompt(confirmMessage, commands, confirmAction)
			@shouldShowPlaybackInfo = scopedShouldShowRealtimeOutput
			confirmed
		end

		def promptForPlaylist
			whisper("Please choose a playlist (leave blank to play all):\n	#{@library['playlists'].keys.join "\n	"}", 0)
			selectedListName = nil
			while !selectedListName do
				playlistQuery = commandPrompt[:input]

				if not playlistQuery or playlistQuery.length === 0
					useEntireLibrary
					break
				end

				selectedListName = findPlaylistName playlistQuery

				if not selectedListName
					whisper("No matches. Try again", 0)
				end

			end

			selectedListName
		end

		def getFormattedChapterList chapters
			chapters.map { |c|
				output = "#{" " * (9-c['time'].length)}#{c['time']} #{c['text']}"

				if c.has_key?('skip')
					output = "#{c.has_key?('skip') && c['skip'] ? 'skip' : '    '}" + output
				end

				if c.has_key?('loop_target')
					output += " (loop to \"#{c['loop_target']}\")"
				end

				output
			}
		end

		def promptForChapterIndex chapters, commands = nil, message = nil
			whisper("prompting for chapter selection", 3)
			selectedChapterIndex = nil

			chapterList = getFormattedChapterList chapters
			prePromptMessage = "	#{chapterList.join "\n	"}"
			prePromptMessage += "\n#{message}" if message
			promptMessage = "Please choose a chapter (leave blank to play first):"

			while not selectedChapterIndex do
				puts prePromptMessage
				emptyAction = Proc.new { |input| false }
				chapterQuery = commandPrompt(promptMessage, commands, emptyAction)[:input]
				break if not chapterQuery or chapterQuery.length === 0

				selectedChapterIndex = firstFuzzyMatchIndex chapterQuery, chapterList

				if selectedChapterIndex
					break
				else
					whisper("No matches. Try again.", 0)
				end

			end

			whisper("Selected chapter #{selectedChapterIndex}", 4)

			{
				:index => selectedChapterIndex
			}
		end

		def listTrackTitles(tracks)
			tracks.map { |t| "#{t['title']} [#{t['type']}::#{t['src']}]" }
		end

		def getTracksFromTitleList(titleList, referenceTracks = nil)
			referenceTracks ||= @library['tracks'].values
			tracks = []
			titleList.each { |line|
				matches = line.match(/^(.*) \[(.*)::(.*)\]$/)
				if matches
					trackType = matches[2]
					trackSource = matches[3]
					track = nil
					referenceTracks.each { |referenceTrack|
						if referenceTrack['src'] == trackSource
							track = referenceTrack
							if matches[1].length > 0 and matches[1] != track['title']
								track['title'] = matches[1]
							end
							break
						end
					}
					track = createTrack(trackSource, trackType) if not track
					tracks << track if track
				end
			}

			tracks
		end

		def cloneTracks inputTracks
			tracks = []
			inputTracks.each { |id, t| tracks <<	t }
			tracks
		end

		def cloneLibraryToTracks inputLibrary
			tracks = []
			inputLibrary.each { |id, t| tracks << t }
			tracks
		end

		def cloneLibrary inputLibrary
			library = {}
			inputLibrary.each { |id, t| library[t['id']] = t }
			library
		end

		def cloneTracksToLibrary inputTracks
			library = {}
			inputTracks.each { |t| library[t['id']] = t }
			library
		end

		def listenForExternalCommands # 1gOsMN
			streamName = 'command-queue'
			shouldListenForExternalCommands = true
			Thread.new {
				externalCommandStream = makeStream streamName
				whisper("external command stream: #{externalCommandStream}", 2)
				File.open(externalCommandStream, 'r') { |externalCommandStreamHandle|
					# externalCommand = ""
					while shouldListenForExternalCommands do
						while ($_ = externalCommandStreamHandle.read(1)) do
							trigger 'external_input', $_
							# if $_ != "\n"
							# 	externalCommand << $_
							# else
							# 	if externalCommand && externalCommand.length > 0
							# 		trigger 'external_command', externalCommand
							# 		externalCommand = ""
							# 	end
							# end
						end
					end
				}
			}
			bindOnce 'before_exit', Proc.new{
				whisper "before_exit: killing external commands listener (nerfed: will it allow stuff to continue?)", 3
				shouldListenForExternalCommands = false
			}
		end

	end

end

begin
	player = Tunewich::Player.new

	if player.instance_variable_get(:@userMode) == Tunewich::Player::MODES['playing']
		player.interactivePlayback
	else
		player.interactiveEdit
	end

	player.kill
rescue Exception => e
	message = "Exception: #{e.message}\nbacktrace: #{e.backtrace.join "\n"}"
	puts message
	if $logFilePath
		open($logFilePath, 'a') { |f|
			f.puts message
		}
	end
	player && player.kill
end
