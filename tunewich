#!/usr/bin/env ruby

# TODO: fix /edit swapping first and last tracks
# TODO: fix inability to pause with @configuredVerbosity > -1

require "io/console" # STDIN.getch
require "open-uri" # URI
require "optparse" # OptionParser
require "json" # JSON
require "digest" # Digest
require "rexml/document" # REXML::Document
require "rexml/xpath" # REXML::XPath

$clearLineCharacter = "\033[0K"
$disableWrapCharacter = "\033[?7l"
$enableWrapCharacter = "\033[?7h"
$tunewichWorkingDirectory = "#{ENV['HOME']}/.tunewich"
$tunewichTmpDirectory = "#{$tunewichWorkingDirectory}/tmp"

# Go to .tunewich directory so that any temp files are stored there.
# FIXME: don't allow youtube-dl to create --Frag files, or clean them up
Dir.mkdir $tunewichWorkingDirectory if not Dir.exist? $tunewichWorkingDirectory
Dir.chdir $tunewichWorkingDirectory

Dir.mkdir $tunewichTmpDirectory if not Dir.exist? $tunewichTmpDirectory

module Tunewich

	class UI

	end

	class Library

	end

	class Playlist

	end

	class YouTubeClient

	end

	class Player

		PROMPT_TIMEOUT_RESPONSE = 'prompt_timeout_response'
		FILTER_HELP_1 = "Filter tracks by rules, in the format 'key=value,key=value 2,key'."
		FILTER_HELP_2 = "Available rules are: [min-,max-]rating=<#0-5>,title=<query>,tag=<tag>,chapters,last=<[[[DD:]HH:]MM:]SS>,ab."
		FILTER_HELP_3 = "Prepend an '-' to your rule to add it to exclude matches (e.g. '-tag=' vs 'tag=')."
		MODES = {
			'playing' => 'playing',
			'editing' => 'editing'
		}
		TAG_INPUT_SPLIT = /[,\s]+/
		PLAYER_APPLICATION = 'mplayer'
		MPLAYER_STDOUT_BUFFER_NAME = 'mplayer-stdout'
		MPLAYER_INPUT_FIFO_NAME = 'mplayer-input'
		UNAME = `uname`.chomp

		def initialize
			@userMode = Player::MODES['playing']
			@library = nil
			@libraryHash = nil
			@eventBindings = {}
			@eventBindingsIndex = []
			@eventBindingGroups = {}
			@sessionID = Random.rand(1024)
			@currentTrack = nil
			@currentChapterIndex = nil
			@currentlySkippingChapter = nil
			@trackIndex = 0
			@tracks = []
			@configuredVerbosity = 0
			@shouldShowPlaybackInfo = true
			@trackFilters = nil
			@trackExcludeFilters = nil
			@noNetwork = false
			@playlistName = nil
			@volume = 25
			@currentVolume = 25
			@enableDownload = false
			@preferredFileFormat = 'bestaudio'
			@playerTemporaryInteractiveCommands = []
			@playerOverrideCommands = []
			@currentPlayerTime = nil
			@currentPlayerIndex = 0
			@speedBeforeRampingOut = 1
			@playerThreads = [] # Not currently used. For instances of the player class.
			@inputThread = nil
			@playerApplicationThreads = []
			@otherThreads = []
			@forceStreaming = false
			@commandHistory = []
			@streamingServerType = nil
			@youtubeDLTrackTypes = ['youtube', 'soundcloud']

			getEnvironmentConfig

			doOptionSecondaryActions parseOptions

			trackTitleListFromLastSession = readTempFile('tracks', false)
			if trackTitleListFromLastSession && trackTitleListFromLastSession.length > 0
				whisper "Using tracks from last session.", 1
				useTracks(getTracksFromTitleList(trackTitleListFromLastSession.strip.lines))
			end

			bindOnce 'request_exit', Proc.new {
				if @services && @services.length > 0
					whisper "Exiting: killing #{@services.length} services", 1
					@services.each { |thread| thread.kill if thread.alive? }
				else
					whisper "Exiting: no services running", 1
				end
			}

			@volume = getMplayerConfigNumericProperty('volume')
			whisper "@volume: #{@volume}", 3
			@currentVolume = @volume
			trigger 'volume_change'
			@speed = getMplayerConfigNumericProperty('speed', 1.0)
			whisper "@speed: #{@speed}", 3
			@currentSpeed = @speed
			trigger 'speed_change'

			if @userMode == Player::MODES['playing']
				interactivePlayback
			else
				bindingGroupName = 'editingModeBindingGroup'
				commandPrompt @userMode, getInteractiveCommands([@userMode], bindingGroupName)
			end

			trigger 'request_exit'
		end

		private

		def bind eventName, handlerProc, handlerGroup = nil
			@eventBindings[eventName] ||= []

			handlerIndexOnEvent = @eventBindings[eventName].length
			@eventBindings[eventName] << handlerProc

			handlerID = @eventBindingsIndex.length
			@eventBindingsIndex << {
				:name => eventName,
				:index => handlerIndexOnEvent
			}

			if handlerGroup
				@eventBindingGroups[handlerGroup] ||= []
				@eventBindingGroups[handlerGroup] << handlerID
			end

			whisper "bind, #{eventName}, #{handlerGroup}, #{handlerID}", 5

			handlerID
		end

		def bindOnce eventName, handlerProc, handlerGroup = nil
			bindingID = nil
			selfRemovingHandlerProc = Proc.new { |data|
				unbind bindingID
				handlerProc.call data
			}
			bindingID = bind eventName, selfRemovingHandlerProc, handlerGroup
			bindingID
		end
		
		def unbind bindingID
			if @eventBindingsIndex[bindingID]
				@eventBindings[@eventBindingsIndex[bindingID][:name]][@eventBindingsIndex[bindingID][:index]] = nil
				@eventBindingsIndex[bindingID] = nil # if lots of bindings are set, will all these nils bloat memory?
			end
		end

		def unbindGroup groupName
			if @eventBindingGroups.has_key? groupName
				whisper "Unbinding: #{@eventBindingGroups[groupName].length} handlers in binding group '#{groupName}'", 3
				@eventBindingGroups[groupName].each { |bindingID| unbind bindingID }
			else
				whisper "Unbinding: No bindings assigned to group '#{groupName}'", 3
			end
		end

		def trigger eventName, data = nil
			if @eventBindings.has_key? eventName
				whisper "trigger #{eventName}, #{@eventBindings[eventName].length} handlers bound", 5
				@eventBindings[eventName].each { |handlerProc| handlerProc.call(data) if handlerProc }
			else
				whisper "trigger #{eventName} (no handlers bound)", 5
			end
		end

		def readCharacter
			# I think I ripped this from here: https://gist.github.com/acook/4190379
			STDIN.echo = false
			STDIN.raw!
			input = STDIN.getc.chr
			if input == "\e" then
				input << STDIN.read_nonblock(3) rescue nil
				input << STDIN.read_nonblock(2) rescue nil
			end
		ensure
			STDIN.echo = true
			STDIN.cooked!
			return input
		end

		def whisper message, verbosity = 1
			# 1: verbose user output
			# 2: very verbose user output
			# 3: errors
			# 4: debug
      if @configuredVerbosity >= verbosity
        STDERR.puts "  #{"-" * verbosity} #{message}"
      end
		end

		def getEnvironmentConfig
			if ENV.key? 'TUNEWICH_PLAYER_OPTS'
				@playerOverrideCommands << ENV['TUNEWICH_PLAYER_OPTS']
			end

			if ENV.key? 'TUNEWICH_DIR'
				setLibraryPath ENV['TUNEWICH_DIR']
			else
				puts "Please add `export TUNEWICH_DIR=\"<path/to/your/music/directory>\"` to your ~/.profile or similar file."
			end

			# assume volume is not logarithmic for player on Mac
			@isVolumeAlreadyLogarithmic = !(UNAME == "Darwin")
		end

		def findBPMRatio firstTrack, secondTrack
			# TODO: optionally use common factors or time signatures to find other
			# good ratios
			ratio = 1
			if not firstTrack.has_key? 'bpm'
				whisper "The first track being compared doesn't have BPM set.", 2
			elsif secondTrack.has_key? 'bpm'
				whisper "The second track being compared doesn't have BPM set.", 2
			else
				ratio = secondTrack['bpm'].to_f / firstTrack['bpm'].to_f
				if ratio >= 2.0
					ratio /= 2.0
				elsif ratio <= 0.5
					ratio *= 2.0
				end
			end
			ratio
		end

		def editChapter chapter
			# TODO: set chapter rating
			editableChapterInfo = chapter # want to pass this by value, not by reference
			editableChapterInfo['name'] = '<empty>' if !editableChapterInfo.has_key? 'name'
			editableChapterInfo['skip'] = 'false' if !editableChapterInfo.has_key? 'skip'
			editedChapterInfo = editHashInVim editableChapterInfo
			if editedChapterInfo
				if editedChapterInfo.has_key?('skip')
					if editedChapterInfo['skip'] == 'true'
						editedChapterInfo['skip'] = true # string to boolean
					else
						editedChapterInfo.delete 'skip' # don't allow any values besides 'true'
					end
				end

				chapter.replace editedChapterInfo

				whisper "Accepted chapter edits: #{chapter}", 3
			else
				putsRealtime "There must be exactly two lines of chapter info (name & time). Discarding the edit."
			end
			chapter
		end

		def sortChapters chapters
			chapters.sort { |a, b|
				getSecondsFromDurationString(a['time']) <=> getSecondsFromDurationString(b['time'])
			}
		end

		def getInteractiveCommands modes = [], bindingGroupName
			# TODO: change any scoped variables referenced to trigger events with data, if needed, and move this into a static object on Player, or several (base, playing, editing)
			# - [x] bindingGroupName
			interactiveCommands = {
				'base' => {
					'wait' => {
						'description' => 'Wait some number of seconds to execute following chained commands',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)

							if inputParts[2] && inputParts[2].length > 0
								output = {
									:chainedInput => inputParts[2]
								}

								waitEvent = nil
								waitInput = inputParts[1].chomp.strip
								if waitInput.length > 0
									if waitInput.match(/^[0-9.]+\s*$/)
										waitTime = waitInput.to_f
										whisper "sleeping for #{waitTime} seconds", 3
										waitEvent = "timed_wait_in_player_#{@currentPlayerIndex}"
										Thread.new {
											sleep waitTime
											whisper "triggering #{waitEvent}", 3
											trigger waitEvent
										}
									else
										availableWaitEvents = [
											'chapter_change',
											'play_start',
											'play_end',
											'fade_start',
											'fade_end',
											'speed_ramp_start',
											'speed_ramp_end',
											'download_start',
											'download_end'
										]
										waitEvent = firstFuzzyMatchValue waitInput.strip.downcase, availableWaitEvents
										if !waitEvent
											putsRealtime "Unknown event '#{waitInput}'. Not waiting. Available events: #{availableWaitEvents.join ', '}"
										end
									end
								else
									putsRealtime "The /wait command expects either a number of seconds, or an event name"
								end
								if waitEvent
									output[:bindChainToEvent] = waitEvent
									output[:bindingGroupName] = bindingGroupName
								end
							else
								putsRealtime "Put another command after /wait"
								output = nil
							end

							output
						}
					},
					'clear' => {
						'description' => 'Clear current tracklist',
						'action' => Proc.new { |input|
							@useTracks []
							{:chainedInput => input}
						}
					},
					'all' => {
						'description' => "Load entire library.",
						'action' => Proc.new { |input|
							useEntireLibrary
							{:chainedInput => input}
						}
					},
					'rate' => {
						'description' => "Rate this track.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							newRating = inputParts[1] if (inputParts[1].length > 0) && (inputParts[1].match /^[0-9]/)
							if !newRating || newRating.length < 1
								putsRealtime "current rating: #{@currentTrack['rating']}"
							else
								@currentTrack['rating'] = newRating.to_i
								if !@currentTrack['unattached'] || @currentTrack['rating'] > 0
									loadLibrary
									addTrackToLibrary @currentTrack if @currentTrack['unattached']
									writeLibraryToFile
								end
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'bpm' => {
						'description' => "Interactively set the beats-per-minute of the track. Do '/bpm 0' to remove (not chainable)",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							commitBPM = false

							if inputParts[1].length > 0
								bpm = inputParts[1].to_f
								commitBPM = true
							else
								bpm = getUserInputBPM
								if bpm
									commitBPM = true
									bpm /= @speed
								end
							end

							if commitBPM
								loadLibrary
								if bpm == 0
									putsRealtime "Removing BPM from track."
									@currentTrack.delete 'bpm' if @currentTrack.has_key? 'bpm'
								else
									putsRealtime "Setting track BPM to #{bpm}."
									@currentTrack['bpm'] = bpm
								end
								writeLibraryToFile
							else
								putsRealtime "Canceling: leaving track BPM alone."
							end

							{:chainedInput => inputParts[2]}
						}
					},
					'tag' => {
						'description' => "Tag this track.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if !inputParts[1] || inputParts[1].length < 1
								putsRealtime "current tags: #{getTrackTags @currentTrack}"
							else
								tagsToAdd = inputParts[1].split(/[, ]+/)
								whisper "all tags given: #{tagsToAdd}", 2
								tagsToRemove = []
								tagsToRemove.replace(tagsToAdd).keep_if {|name| name.match(/^-/)}
								tagsToRemove.map! {|name| name.sub(/^-/, '')}
								tagsToAdd.delete_if {|name| name.match(/^-/)}

								loadLibrary
								addTrackToTags @currentTrack, tagsToAdd
								removeTagsFromTrack @currentTrack, tagsToRemove
								addTrackToLibrary @currentTrack if @currentTrack['unattached']
								writeLibraryToFile
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'tagall' => {
						'description' => "Tag all tracks in the current tracklist.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1] && inputParts[1].length > 0
								tagsToAdd = inputParts[1].split(/[, ]+/)
								tagsToRemove = []
								tagsToAdd.each { |tagName|
									if /^-/.match tagName
										tagsToRemove << tagName.gsub(/^-/, '')
										tagsToAdd.delete tagName
									end
								}
								loadLibrary
								@tracks.each { |t|
									addTrackToTags t, tagsToAdd
									removeTagsFromTrack t, tagsToRemove
									addTrackToLibrary t if t['unattached']
								}
								writeLibraryToFile
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'list' => {
						'description' => "Load a playlist. (not chainable)",
						'action' => Proc.new { |input|
							# TODO: generalized function to list playlists, their track count, and the average rating among rated tracks
							whisper "playlistQuery: #{input}", 4
							playlistNames = @library['playlists'].keys
							if input && input.length > 0
								match = firstFuzzyMatch input, playlistNames

								if match && match[:score] > 1 # FIXME: what's a good baseline score for a playlist match?
									playlistName = match[:value]
								end
							end

							if playlistName
								usePlaylist playlistName, true
							else
								putsRealtime playlistNames.join "\n"
							end
							nil
						}
					},
					'edit' => {
						'description' => 'Edit playing tracklist in Vim.',
						'action' => Proc.new { |input|
							editedTrackList = editTrackList @tracks
							useTracks editedTrackList, false
							putsRealtime "#{@tracks.length} tracks selected"
							{:chainedInput => input}
						}
					},
					'go' => {
						'description' => "Go to a track in the current list.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1] && inputParts[1].length > 0
								trackIndexOffset = getOffsetFromInputString inputParts[1]
								newTrackIndex = @trackIndex
								if trackIndexOffset
									newTrackIndex += trackIndexOffset
								elsif inputParts[1].to_i == 0
									newTrackIndex = findTrackIndex inputParts[1]
								else
									newTrackIndex = inputParts[1].to_i - 1 % @tracks.length
								end
								@trackIndex = newTrackIndex if newTrackIndex
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'more' => {
						'description' => "Play all tracks on this video's page.",
						'action' => Proc.new { |input|
							if @currentTrack['type'] == 'youtube'
								@shouldShowPlaybackInfo = false
								tracks = getYouTubeTracksFromPage(@currentTrack['link'] || @currentTrack['src'])
								@shouldShowPlaybackInfo = true
							elsif @currentTrack['type'] == 'soundcloud'
								@shouldShowPlaybackInfo = false
								tracks = getSoundcloudRecommendations(@currentTrack['link'] || @currentTrack['src'])
								@shouldShowPlaybackInfo = true
							else
								putsRealtime "The /more currently only supports YouTube and Soundcloud tracks."
							end

              if tracks
                tracks.shift # remove the first track, which will be the main video on the page
                @trackIndex = @tracks.length
                @trackFilters = nil
                useTracks tracks, true # and set track index to the first
              end
							{:chainedInput => input}
						}
					},
					'info' => {
						'description' => "Show track info. Track is: without input = currently playing track; with '>' = the track that will play next; with numeric input = the track at that position in the track list; any other input = the track with the title that best matches that input",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							index = inputParts[1]
							track = nil
							trackIndex = nil
							if inputParts[1] && inputParts[1].length > 0
								trackIndexOffset = getOffsetFromInputString inputParts[1]
								if trackIndexOffset
									whisper "trackIndexOffset: #{trackIndexOffset}", 3
									whisper "@trackIndex: #{@trackIndex}", 3
									trackIndex = @trackIndex + trackIndexOffset - 1 # @trackIndex is the _next_ track; subtract 1 from the offset so that '>' -> 0
								elsif inputParts[1].to_i == 0
									trackIndex = findTrackIndex(inputParts[1])
								else
									trackIndex = inputParts[1].to_i - 1
								end
								track = @tracks[trackIndex] if trackIndex
							else
								# the user may have altered the track list, so that it no longer includes the currently playing track
								trackIndex = @trackIndex if @tracks[@trackIndex] === @currentTrack
								track = @currentTrack
							end

							if track
								alreadyHas = {
									:title => track.has_key?('title'),
									:duration => track.has_key?('duration'),
									:description => track.has_key?('description'),
									:bpm => track.has_key?('bpm')
								}
								tagNames = getTrackTags track

								outputMessageLines = []
								outputMessageLines << "     index : #{trackIndex + 1}/#{@tracks.length}" if trackIndex
								outputMessageLines << "    volume : #{@currentVolume}/100"
								outputMessageLines << "------------------------------"
								outputMessageLines << "     title : #{track['title']}" if alreadyHas[:title]
								if track == @currentTrack
									timeMessage = "      time : #{getDurationStringFromSeconds @currentPlayerTime}"
									if !alreadyHas[:duration] || getSecondsFromDurationString(track['duration']) == 0
										durationResponseFromPlayer = getMplayerProperty('get_time_length', /^(ANS_LENGTH=)(.*?)(\?)?$/, 0.1)
										if durationResponseFromPlayer
											track['duration'] = getDurationStringFromSeconds durationResponseFromPlayer.to_f
										end
									end
									timeMessage += " / #{track['duration']}"
									timeMessage += " (#{@speed}x)" if @speed != 1
									if @currentTrack.has_key? 'chapters'
										chapterIndex = getChapterIndexAtTime @currentTrack, @currentPlayerTime
										timeMessage += "\n   chapter : #{@currentTrack['chapters'][chapterIndex]['name']}"
									end
									outputMessageLines << "#{timeMessage}"
								else
									outputMessageLines << "  duration : #{track['duration']}" if alreadyHas[:duration]
								end
								outputMessageLines << "      tags : #{tagNames.join ', '}" if tagNames.length > 0
								outputMessageLines << "    rating : #{track['rating']}" if track['rating']
								outputMessageLines << "       bpm : #{track['bpm']}" if alreadyHas[:bpm]
								outputMessageLines << "downloaded : #{trackFileExists? track}"
								outputMessageLines << "==============================\n#{track['description']}" if alreadyHas[:description]
								putsRealtime outputMessageLines.join "\n"

								outputMessageLines = []
								if !alreadyHas[:title] || !alreadyHas[:duration] || track['title'].length == 0 || @configuredVerbosity > 0
									info = nil
									if track['type'] === 'youtube'
										info = getYouTubeTrackInfo track['src']
									elsif track['type'] === 'soundcloud'
										info = getSoundcloudTrackInfo track['src']
									end
									updateTrackInfo track, info

									outputMessageLines << "     title : #{track['title']}" if !alreadyHas[:title]
									outputMessageLines << "  duration : #{track['duration']}" if !alreadyHas[:duration]
									outputMessageLines << "sourceTags : #{info['sourceTags']}" if info && info.has_key?('sourceTags')
									outputMessageLines << "==============================\n#{track['description']}" if !alreadyHas[:description] && track['description']
								end
								if not info
									info = {'link' => track['link'] || track['src']}
									if track['type'] === 'youtube'
										info['link'] = "http://youtu.be/#{track['src']}"
									end
								end

								outputMessageLines << "      link : #{info['link']}" if info

								if @configuredVerbosity > 0 && tagNames.length > 0
									whisper "about to loop through tagNames", 4
									tagNames.each { |tagName|
										whisper "digging up ancestors of #{tagName}", 4
										ancestorTags = getAncestorTagNames tagName
										whisper("ancestors of tag '#{tagName}': #{ancestorTags}", 1) if ancestorTags.length > 0
									}
								end

								outputMessageLines << "------------------------------"
								putsRealtime outputMessageLines.join "\n"
							else
								putsRealtime "Cannot show info. No track found."
							end

							{:chainedInput => inputParts[2]}
						}
					},
					'search' => {
						'description' => "<query> Search YouTube. (not chainable)",
						'action' => Proc.new { |input|
							if input and input.length > 1
								@shouldShowPlaybackInfo = false
								searchedTracks = searchYouTube(input)
								@shouldShowPlaybackInfo = true
								if searchedTracks
									@trackIndex = @tracks.length
									@trackFilters = nil
									useTracks searchedTracks
								end
							else
								putsRealtime "Enter a search term of at least 2 characters."
							end
							nil
						}
					},
					'shuffle' => {
						'description' => 'Toggle shuffle.',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1] && inputParts[1].length > 0
								@shuffle = !!((inputParts[1].match /^(y(es)?|o(n|[^f]))/i))
							else
								@shuffle = !@shuffle
							end
							shuffleIndex() if @shuffle
							putsRealtime "shuffle: #{@shuffle ? 'on' : 'off'}" if @configuredVerbosity >= 1
							{:chainedInput => inputParts[2]}
						}
					},
					'net' => {
						'description' => 'Toggle "no-network".',
						'action' => Proc.new { |input|
							@noNetwork = !@noNetwork
							putsRealtime "network: #{@noNetwork ? 'off' : 'on'}"
							{:chainedInput => input}
						}
					},
					'download' => {
						'description' => "Download the current track for faster play in the future. Optional 'get' parameter prints the download shell command instead.",
						'action' => Proc.new { |input|
							# TODO: getDownloadCommand, bind download_complete, etc.
							inputParts = input.match(/^([^\/]*)(.*)$/)

							if inputParts[1] == 'get'
								if trackFileExists? @currentTrack
									puts findTrackFiles(@currentTrack)[0]
								else
									putsRealtime getDownloadCommand @currentTrack
								end
							else
								if inputParts[1].length > 0 && inputParts[1].to_i == 0
									trackIndex = findTrackIndex inputParts[1]
									if trackIndex
										track = @tracks[trackIndex]
									else
										putsRealtime "could not find track #{inputParts[1]}"
									end
								elsif inputParts[1].to_i > 0
									track = @tracks[inputParts[1].to_i - 1 % @tracks.length]
								else
									track = @currentTrack
								end
								if trackFileExists? track
									putsRealtime "This file is already downloaded."
								else
									@shouldShowPlaybackInfo = false
									downloadTrack track
									@shouldShowPlaybackInfo = true
								end
							end

							{:chainedInput => inputParts[2]}
						}
					},
					'add' => {
						'description' => 'Add a new track to the play queue. Input: <urls> [<tags>] -- urls: comma-separated URLs or YouTube IDs (Some URLs will add multiple tracks, like a bandcamp album); tags: comma-separated tags to add to the tracks.',
						'action' => Proc.new { |input|
							whisper "input: '#{input}'", 3 # XXX
							inputParts = input.match(/^([^ ]*?)( .*?)?( \/.*)?$/)
							urls = inputParts[1].split ',' if inputParts[1]
							tags = inputParts[2].split ',' if inputParts[2]
							whisper "urls: #{urls}\ntags: #{tags}", 3
							if urls && urls.length > 0
								tracks = getTracksFromURLs urls
								putsRealtime "Adding #{tracks.length} tracks to queue. Playing next."
								if tracks.length && tags && tags.length > 0
									tracks.each { |t|
										addTrackToTags t, tags
									}
								end
								useTracks tracks

								@trackIndex = @tracks.length - tracks.length
							end
							{:chainedInput => inputParts[3]}
						}
					},
					'feed' => {
						'description' => 'Load a feed that has been saved with /add (currently only podcasts).',
						'action' => Proc.new { |input|
							inputParts = input.match(/^(.*?)( \/.*)?$/)

							feed = nil

							feedNames = @library['feeds'].map { |feed| feed['title'] }
							availableFeedsMessage = "Available feeds:\n  #{feedNames.join "\n  "}"
							if @library.has_key?('feeds') && @library['feeds'].length > 0
								if inputParts[1] && inputParts[1].length > 0
									match = firstFuzzyMatch inputParts[1], feedNames

									if match && match[:score] > 1
										feed = @library['feeds'][match[:index]]
										if @noNetwork
											putsRealtime "Found feed \"#{feed['title']}\". Network is disabled, not fetching feed contents."
										else
											putsRealtime "Loading podcast: \"#{feed['title']}\"..."
											feedTracks = loadPodcast feed['src']
											useTracks feedTracks if feedTracks
											putsRealtime "Loaded #{feedTracks.length} tracks. Playing oldest next."
											@trackIndex = @tracks.length - feedTracks.length
										end
									else
										putsRealtime "No matching feed found. #{availableFeedsMessage}"
									end
								else
									putsRealtime availableFeedsMessage
								end
							else
								putsRealtime "No feeds to choose from. Add one with /add."
								whisper "@library.keys: #{@library.keys}", 3
							end

							{:chainedInput => inputParts[2]}
						}
					},
					'chapter' => {
						'description' => 'Skip to a chapter, or show chapter list. Input: number or name of chapter; or "<" or ">" to go back or forward, multiples to go further.',
						'action' => Proc.new { |input|
							whisper "chapter command - input: #{input}", 3
							inputParts = input.match(/^([^\/]*)(.*)$/)
							fileExists = trackFileExists? @currentTrack
							if inputParts[1] && inputParts[1].length > 0
								chapterIndex = getChapterIndexByQuery inputParts[1]
								input = inputParts[2]
							else
								if @currentTrack['chapters']
									whisper "Prompting to select a chapter from the list...", 2

									chapterPromptMessage = nil

									@shouldShowPlaybackInfo = false
									chapterResponse = promptForChapterIndex @currentTrack['chapters'], interactiveCommands, chapterPromptMessage
									@shouldShowPlaybackInfo = true
									chapterIndex = chapterResponse[:index]
								else
									putsRealtime "No chapters on the current track."
								end
							end

							if chapterIndex && chapterIndex >= 0 && chapterIndex < @currentTrack['chapters'].length
								whisper "Done with chapter selection. Resulting chapter index: #{chapterIndex}", 3
								seekToChapter chapterIndex
							else
								putsRealtime "No chapter found."
							end

							{:chainedInput => input}
						}
					},
					'mkchapter' => {
						'description' => "Make a chapter at the current player time. Input: name.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							newChapter = {
								'time' => '0:00',
								'name' => inputParts[1]
							}
							if @currentTrack['chapters'] && @currentTrack['chapters'].length > 0
								currentPlayerTime = @currentPlayerTime
								newChapter['time'] = getDurationStringFromSeconds(currentPlayerTime)
							else
								whisper "Adding the first chapter", 2
								@currentTrack['chapters'] = []
							end
							if !newChapter['name'] || newChapter['name'].length == 0
								newChapter = editChapter newChapter
							end
							@currentTrack['chapters'] << newChapter
							@currentTrack['chapters'] = sortChapters @currentTrack['chapters']
							writeLibraryToFile
							whisper "New chapter written to library file", 3

							{:chainedInput => inputParts[2]}
						}
					},
					'rmchapter' => {
						'description' => "Remove the current chapter.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							chapterIndex = getChapterIndexAtTime @currentTrack, @currentPlayerTime
							if chapterIndex
								@currentTrack['chapters'].delete_at chapterIndex
								writeLibraryToFile
							end

							{:chainedInput => inputParts[2]}
						}
					},
					'editchapter' => {
						'description' => "Edit a chapter's name and/or time, or set it to be skipped. Input: the chapter name or number to be edited (defaults to current chapter)",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if @currentTrack['chapters']
								if inputParts[1].length > 0
									chapterIndex = getChapterIndexByQuery inputParts[1]
								else
									chapterIndex = getChapterIndexAtTime @currentTrack, @currentPlayerTime
									whisper "Current chapter is at index #{chapterIndex}", 3
								end
								if chapterIndex
									chapter = @currentTrack['chapters'][chapterIndex]
									whisper "About to edit chapter #{chapter}", 3
									chapter = editChapter chapter
									# TODO: check if editChapter was successful
									@currentTrack['chapters'][chapterIndex] = chapter
									@currentTrack['chapters'] = sortChapters @currentTrack['chapters']
									writeLibraryToFile
									whisper "Chapter changes written to library file", 3
								else
									putsRealtime "Unable to find the chapter you want to edit."
								end
							else
								putsRealtime "No chapters to edit. Use /mkchapter to create chapters." # TODO: it would be nice to make the chapter, if the intent is clear.
							end

							{:chainedInput => inputParts[2]}
						}
					},
					'filter' => {
						'description' => 'Edit filters.',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1] && inputParts[1].length > 0
								filters = parseOptionParameters inputParts[1]
							else
								filtersList = []
								filtersList += @trackFilters.map { |filter, rule| "#{filter}=#{rule}" } if @trackFilters
								filtersList += @trackExcludeFilters.map { |filter, rule| "-#{filter}=#{rule}" } if @trackExcludeFilters
								filterInstructions = []
								filterInstructions << Player::FILTER_HELP_1
								filterInstructions << Player::FILTER_HELP_2
								filterInstructions << Player::FILTER_HELP_3
								filterInstructions << '' # empty line
								filterInstructions << "Available tags: #{listAllTagsWithAliases.join ', '}"
								filterInstructions << "For music without words: -tag=verbal acapella visual live noise delete missing-source"
								instructions = filterInstructions.join "\n"
								filters = parseOptionParameters editListInVim(filtersList, instructions).join ','
							end

							@trackFilters = {}
							@trackExcludeFilters = {}
							filters.each { |name, filter|
								if name.match /^-/
									@trackExcludeFilters[name.sub(/^-/, '')] = filter
								else
									@trackFilters[name] = filter
								end
							}

							filterTracksOnDeck
							{:chainedInput => inputParts[2]}
						}
					},
					'exit' => {
						'description' => 'Exit tunewich when the current track finishes or is quit.',
						'action' => Proc.new { |input|
							trigger 'request_exit'
							{:chainedInput => input}
						}
					},
					'verbose' => {
						'description' => 'Set level of verbosity: -1 (silent) to 5 (extra debugging).',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1] && inputParts[1].length > 0
								@configuredVerbosity = inputParts[1].to_i
							end
							putsRealtime "verbosity set to #{@configuredVerbosity}"
							{:chainedInput => inputParts[2]}
						}
					},
					'format' => {
						'description' => 'Choose the file format to download (e.g. "mp4"; default "m4a").',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1].length > 0
								@preferredFileFormat = inputParts[1]
							else
								putsRealtime "preferred file format: #{@preferredFileFormat}"
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'commands' => {
						'description' => "List #{Player::PLAYER_APPLICATION} commands.",
						'action' => Proc.new { |input|
							system "#{Player::PLAYER_APPLICATION} -input cmdlist"
							{:chainedInput => input}
						}
					},
					'rm' => {
						'description' => 'remove selected tracks',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							editedTrackList = editTrackList @tracks
							initialLibraryLength = @library['tracks'].length
							editedTrackList.each do |track|
								removeTrackFromLibrary track['id']
							end
							checksum = initialLibraryLength - editedTrackList.length == @library['tracks'].length
							checksumString = "#{initialLibraryLength} - #{editedTrackList.length} == #{@library['tracks'].length}"
							if checksum
								writeLibraryToFile
							end
							putsRealtime "#{checksumString} ... #{checksum ? 'OK: changes written' : 'Mismatch: changes not written'}"
							{:chainedInput => inputParts[2]}
						}
					},
					'jointag' => {
						'description' => '(USAGE: /jointag A B) Join tracks from two tags, making tag B an alias of tag A',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							success = false

							if inputParts[1].length > 0
								tags = inputParts[1].split(Player::TAG_INPUT_SPLIT)
								if tags.length > 1
									success = combineTags tags
									if success
										writeLibraryToFile
									else
										putsRealtime "There was a problem with combining the tags. Your changes were not saved."
									end
								else
									putsRealtime "Please give at least two tags."
								end
							end

							putsRealtime "Tags: \n  #{@library['tags'].keys.sort.join(", ")}" if not success
							{:chainedInput => inputParts[2]}
						}
					},
					'rmfile' => {
						'description' => 'Remove files not referenced in the library.',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							filesToDelete = []
							filesToIgnore = ['.', '..']
							Dir.entries(@fileDirectory).each { |file|
								if !filesToIgnore.include? file
									id = getIdFromFileName file
									if !id || !@library['tracks'][id]
										filesToDelete << file
									end
								end
							}
							if filesToDelete.length > 0
								filesToDelete = editListInVim filesToDelete, "remove any files you don't want to delete"

								filesToDelete.each { |file|
									File.delete "#{@fileDirectory}/#{file.chomp}"
								}
								putsRealtime "#{filesToDelete.length} files deleted."
								writeLibraryToFile
							else
								putsRealtime "No orphaned files found."
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'rmlist' => {
						'description' => '<playlistName> remove a playlist.',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							if inputParts[1] && inputParts[1].length > 0
								playlistName = findPlaylistName inputParts[1]

								if playlistName
									@library['playlists'].delete playlistName
									writeLibraryToFile
									putsRealtime "removed playlist #{playlistName}"
								end

							else
								putsRealtime "#{@library['playlists'].map { |name, p| name } .join "\n"}\n\nPlease specify a playlist name (new or existing)."
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'loadlibrary' => {
						'description' => 'Load the latest version of the media library.',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							loadLibrary
							{:chainedInput => inputParts[2]}
						}
					}
				},
				'editing' => {
				},
				'playing' => {
					'' => {
						'description' => "Chainable player commands (empty command, i.e. '/').",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							output = {
								:chainedInput => inputParts[2]
							}
							if inputParts[1] && inputParts[1].length > 0
								whisper "Running player action (#{input})", 3
								output[:action] = inputParts[1]
							end

							output
						}
					},
					'note' => {
						'description' => "Make a note on this track, with a timestamp.",
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							notesChanged = false;

							loadLibrary
							@currentTrack = matchExistingLibraryTrack @currentTrack

							if !inputParts[1] || inputParts[1].length < 1
								if @currentTrack.has_key? 'notes'
									notesList = @currentTrack['notes'].map { |note| "#{note['time']} - #{note['text']}" }
									editedNotesList = editListInVim notesList
									editedNotes = []
									editedNotesList.each_with_index { |editedLine, index|
										lineMatches = editedLine.match /^([0-9:]+) - (.*)/
										if lineMatches
											editedNotes << {
												'time' => lineMatches[1],
												'text' => lineMatches[2]
											}
										else
											editedNotes.last['text'] += "\n#{editedLine}"
										end
									}
									@currentTrack['notes'] = editedNotes
									notesChanged = true
								else
									putsRealtime "No notes on the current track."
								end
							else
								@currentTrack['notes'] ||= []
								note = {
									'text' => inputParts[1],
									'time' => getDurationStringFromSeconds(@currentPlayerTime)
								}
								if note['text'].length < 1
									note['text'] = editListInVim([], 'Write your note').join "\n"
								end
								@currentTrack['notes'] << note
								@currentTrack['notes'].sort! { |a, b| getSecondsFromDurationString(a['time']) <=> getSecondsFromDurationString(b['time']) } # TODO: same as sortChapters, combine?
								notesChanged = true
							end

							if notesChanged
								@currentTrack['notes'].sort! { |a, b| getSecondsFromDurationString(a['time']) <=> getSecondsFromDurationString(b['time']) } # TODO: same as sortChapters, combine?
								addTrackToLibrary @currentTrack if @currentTrack['unattached']
								writeLibraryToFile
							end

							{:chainedInput => inputParts[2]}
						}
					},
					'eq' => {
						'description' => 'Fade volume (/fade VOLUME [DURATION])',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							userEQDefinition = inputParts[1]
							if userEQDefinition && userEQDefinition.length > 0
								eqPresets = {
									'bass' => '4:5:3:2:0:0:0:0:0:0',
									'earplugs' => '2:6:1:0:0:1:2:4:6:3'
								}
								if userEQDefinition == 'help'
									putsRealtime eqPresets.keys.join ", "
								else
									chosenEQPreset = firstFuzzyMatchValue userEQDefinition, eqPresets.keys
									if chosenEQPreset
										eqSetting = eqPresets[chosenEQPreset]
									else
										eqSetting = userEQDefinition
									end
									# FIXME: can I target `af_clr` at _just_ `equalizer`? I don't want to also remove scaletempo, for instance
									putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{@currentPlayerIndex}", "af_clr\nf_add equalizer=#{eqSetting}\n"
								end
							else
								putsRealtime "TODO: show the current EQ setting"
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'fade' => {
						'description' => 'Fade volume (/fade VOLUME [DURATION])',
						'action' => Proc.new { |input|
							output = nil
							fadeCommandMatch = /^(out|in|[0-9.]+x?)( [0-9.]+)?[^\/]*(.*)$/.match input
							if fadeCommandMatch
								output = {:chainedInput => fadeCommandMatch[3]}
								whisper "fade command", 4
								duration = fadeCommandMatch[2] && fadeCommandMatch[2].length > 0 ? fadeCommandMatch[2].to_f : 2.0
								targetFadeVolume = fadeCommandMatch[1]
								if output[:chainedInput] && output[:chainedInput].length > 0
									whisper "fade in main thread", 4
									fadeVolume targetFadeVolume, duration, @currentPlayerIndex
								else
									whisper "fade in separate thread", 4
									Thread.new {
										fadeVolume targetFadeVolume, duration, @currentPlayerIndex
									}
								end
							end
							output
						}
					},
					'ramp' => {
						'description' => 'Ramp speed (/ramp SPEED [DURATION])',
						'action' => Proc.new { |input|
							output = nil
							rampCommandMatch = /^(out|in|[0-9.]*(bpm)?)( [0-9.]+)?[^\/]*(.*)$/.match input
							#                    1              2      3          4
							if rampCommandMatch
								output = {:chainedInput => rampCommandMatch[4]}
								duration = rampCommandMatch[3] && rampCommandMatch[3].length > 0 ? rampCommandMatch[3].to_f : 0.3
								whisper 'without -af scaletempo[=speed=tempo], min and max limited by the system (~1/8 and ~4.5 on my Mac Mini)', 1
								targetRampSpeed = rampCommandMatch[1]
								if rampCommandMatch[1] == 'bpm'
									targetRampBPM = getUserInputBPM
									if targetRampBPM && targetRampBPM > 0
										targetRampSpeed = "#{targetRampBPM}bpm"
									else
										targetRampSpeed = nil
									end
								end
								if targetRampSpeed
									targetRampSpeed = determineRelativeSpeed targetRampSpeed, @currentTrack, true
									if rampCommandMatch[4] && rampCommandMatch[4].length > 0
										whisper "ramping speed in the main thread", 4
										rampSpeed targetRampSpeed, duration, @currentPlayerIndex
										whisper "Waiting 1 second for buffered sound to play", 2
										sleep 1.0
									else
										whisper "ramping speed in a separate thread", 4
										Thread.new {
											rampSpeed targetRampSpeed, duration, @currentPlayerIndex
										}
									end
								end
							end
							output
						}
					},
					'mark' => {
						'description' => 'Mark the point at which to play this track next time.',
						'action' => Proc.new { |input|
							loadLibrary
							editingTrack = matchExistingLibraryTrack @currentTrack
							editingTrack['mark'] = getDurationStringFromSeconds @currentPlayerTime
							writeLibraryToFile
							{:chainedInput => input}
						}
					},
					'unmark' => {
						'description' => 'Remove a "mark" from a track.',
						'action' => Proc.new { |input|
							loadLibrary
							editingTrack = matchExistingLibraryTrack @currentTrack
							if editingTrack.has_key? 'mark'
								editingTrack.delete 'mark'
								writeLibraryToFile
							end
							{:chainedInput => input}
						}
					},
					'turn' => {
						# TODO: use the 'turn' command to only sort tracks by their
						# similarity to the filter, rather than removing those that don't
						# match
						#
						# possible solutions:
						# - add a paramter to make `filterTracks` only sort, and not `keep_if`/`delete_if`
						# - compartmentalize sort and inclusion/exclusion aspects of different filters
						#		- make another function that uses only the sort parts
						#		- call this function in the 'turn' command
						'description' => "Use all this track's tags to populate the track list.",
						'action' => Proc.new { |input|
							trackTags = getTrackTags @currentTrack
							if trackTags.length > 0
								putsRealtime "Playing tracks with similar tags: #{trackTags.join ', '}"
								@trackFilters ||= {}
								@trackFilters['tag'] = "+#{trackTags.join ' +'}"
								useEntireLibrary
								@trackIndex = 1 # next track (current track will almost certainly be at index 0)
								if @shuffle
									@shuffle = false
									putsRealtime "shuffle: off"
								end
							else
								putsRealtime "Add some tags to this track to find similar tracks."
							end
							{:chainedInput => input}
						}
					},
					'loop' => {
						'description' => 'Toggle loop.',
						'action' => Proc.new { |input|
							@loop = !@loop
							putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{@currentPlayerIndex}", "loop #{@loop ? '0' : '-1'}\n"
							putsRealtime "loop: #{@loop ? 'on' : 'off'}"
							{:chainedInput => input}
						}
					},
					'seek' => {
						'description' => 'Seek to a time code. Prefix with "+" or "-" to seek relative to current play position."',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)

							seekInput = inputParts[1]
							if seekInput && seekInput.length > 0
								if seekInput == 'mark' && @currentTrack.has_key?('mark')
									seekInput = @currentTrack['mark']
								end

								relativeDirection = nil
								relativeDirectionMatch = seekInput.match /^[+-]/
								if relativeDirectionMatch
									whisper seekInput # XXX
									seekInput.sub! /^[+-]/, ''
									whisper seekInput # XXX
									relativeDirection = relativeDirectionMatch[0] == '-' ? -1 : 1
								end

								seekTimeInSeconds = getSecondsFromDurationString seekInput
								if seekTimeInSeconds
									if relativeDirection
										seekTimeInSeconds = @currentPlayerTime + relativeDirection * seekTimeInSeconds
									end
								else
									# TODO: seek to either a chapter or a note
									#		- make chapter functions generic
									#		- search among chapters and notes as a flat list
								end

								if seekTimeInSeconds
									putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{@currentPlayerIndex}", "seek #{seekTimeInSeconds} 2\n"
								end
							end
							{:chainedInput => inputParts[2]}
						}
					},
					'ab' => {
						'description' => 'Create or edit an A/B loop in this track.',
						'action' => Proc.new { |input|
							inputParts = input.match(/^([^\/]*)(.*)$/)
							whisper "inputParts: #{inputParts}", 3
							chunks = inputParts[1].split ' '
							testing = false

							loadLibrary
							track = matchExistingLibraryTrack @currentTrack

							if chunks.length > 0 && chunks[0] == 'test'
								putsRealtime "testing A/B loop"
								testing = true
								chunks.shift
							end
							if chunks.length > 0 && chunks[0].match(/beats?$/)
								if track['loop']
									if track['bpm']
										numberOfBeatsToShift = (chunks.shift.gsub(/[^0-9.+-]*/, '')).to_f
										beatShift = numberOfBeatsToShift * 60.0 / track['bpm'].to_f
										whisper "Shifting by #{beatShift} seconds (#{numberOfBeatsToShift} beats at #{track['bpm']} BPM).", 1
										track['loop'][0] += beatShift
										track['loop'][1] += beatShift
									else
										putsRealtime "No BPM on this track. Set with /bpm."
									end
								end
							elsif chunks.length > 1
								aTime = getSecondsFromDurationString chunks.shift
								bTime = getSecondsFromDurationString chunks.shift
								aTimeString = getDurationStringFromSeconds aTime
								bTimeString = getDurationStringFromSeconds bTime
							end
							if trackFileExists? track
								if aTime && bTime
									putsRealtime "Setting A/B (#{aTimeString}/#{bTimeString}) & seeking to the end to test."
									track['loop'] = [aTime, bTime]
									if not testing
										whisper "writing AB to track in library", 2
										writeLibraryToFile
									end
									testing = true
								elsif track['loop']
									putsRealtime "A: #{getDurationStringFromSeconds track['loop'][0]} B: #{getDurationStringFromSeconds track['loop'][1]}"
								else
									putsRealtime "No A/B loop on track."
								end
								if testing
									@loop = true
									@playerTemporaryInteractiveCommands << "seek #{track['loop'][1] - 3.0} 2"
								end
							else
								putsRealtime "Download the track before adding an A/B loop."
							end
							whisper "done with AB command", 3
							{:chainedInput => inputParts[2]}
						}
					},
					'log' => {
						'description' => 'Toggle logarithmic volume scale.',
						'action' => Proc.new { |input|
							@isVolumeAlreadyLogarithmic= !@isVolumeAlreadyLogarithmic
							putsRealtime "logarithmic volume scale: #{@isVolumeAlreadyLogarithmic ? 'off' : 'on'}"
							{:chainedInput => input}
						}
					},
					'fixbpm' => {
						'description' => "TODO: [Toggle ON/off] Change next track's playback speed to BPM of a current track. If either track does not have BPM metadata, then the curent playback speed is maintained.",
						'action' => Proc.new { |input|
							@fixbpm = !@fixbpm
							putsRealtime "TODO: fixbpm #{@fixbpm ? "on" : "off"}"
							{:chainedInput => input}
						}
					},
					'defvolume' => {
						'description' => "FIXME: save current volume relative to default in library.",
						'action' => Proc.new { |input|
							loadLibrary
							@currentTrack['loudness'] = getMplayerConfigNumericProperty('volume') / @currentVolume
							writeLibraryToFile
							{:chainedInput => input}
						}
					},
					'again' => {
						'description' => "Play the last track again.",
						'action' => Proc.new { |input|
							@trackIndex = @tracks.index @currentTrack
							if !@trackIndex
								useTracks [@currentTrack]
								@trackIndex = @tracks.length - 1
								# TODO: add @currentTrack to queue
							end
							{:chainedInput => input}
						}
					},
					'stream' => {
						'description' => "Ignore downloaded files.",
						'action' => Proc.new { |input|
							@forceStreaming = !@forceStreaming
							putsRealtime "force streaming: #{@forceStreaming ? 'on' : 'off'}"
							{:chainedInput => input}
						}
					},
					'player' => {
						'description' => 'Define player startup options. Takes effect on the next track being played',
						'action' => Proc.new { |input|
							samplePlayerCommands = [];
							samplePlayerCommands << 'Some sample options:';
							samplePlayerCommands << 'small video window in the corner: -geometry 100%:100% -xy 150';
							samplePlayerCommands << 'mix stereo to mono: -af pan=1:0.5:0.5';
							@playerOverrideCommands = editListInVim(@playerOverrideCommands, samplePlayerCommands.join("\n"))
							{:chainedInput => input}
						}
					}
				}
			}

			modes << 'base'
			modes.uniq!
			requestedCommandSet = {}

			modes.each { |modeName|
				requestedCommandSet.merge! interactiveCommands[modeName]
			}

			requestedCommandSet
		end

		def interactivePlayback
			bindingGroupName = 'interactivePlayback'

			shouldExitPlayerLoop = false
			bindOnce 'request_exit', Proc.new {
				shouldExitPlayerLoop = true
				putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{@currentPlayerIndex}", "q\n"
			}, bindingGroupName

			if @tracks && @tracks.length > 0
				titleBlock "Playing #{@tracks.length} tracks", '#'
			else
				useEntireLibrary
			end

			# TODO: catch SIGINT (ctrl+c) & prompt for playlist again
			playerOutput = nil
			commandCustomPlayerConfig = ''

			interactiveCommands = getInteractiveCommands [@userMode], bindingGroupName

			track = nil
			# chaptersNotPlayed = []

			while not playerOutput or playerOutput[:exit] do
				if @trackIndex && @tracks[@trackIndex]
					@currentTrack = matchExistingLibraryTrack @tracks[@trackIndex]

					titleBlock "[#{@trackIndex + 1}] - #{@currentTrack['title']}"

					nextTrack() # call nextTrack after @trackIndex is announced, but before play, so that the user can see which track will come next.

					if @updateAllPlayedTrackInfo && !@noNetwork
						printRepeat "Getting latest track information..."
						updateTrackInfo @currentTrack
					end

					fileExists = trackFileExists? @currentTrack

					if !fileExists && @noNetwork
						next
					end

					playerOutput = play @currentTrack, interactiveCommands

					trackDurationInSeconds = getSecondsFromDurationString(@currentTrack['duration'])

					if !@currentTrack['unattached']
						loadLibrary
						@currentTrack['playTime'] ||= 0
						@currentTrack['playTime'] += playerOutput[:playTime].to_i
						minimumPlayTime = [30, trackDurationInSeconds -10].min
						if playerOutput[:playTime] >= minimumPlayTime
							@currentTrack['lastPlayed'] = playerOutput[:endTime].to_i
							@currentTrack['playCount'] ||= 0
							@currentTrack['playCount'] += 1
						else
							@currentTrack['skipCount'] ||= 0
							@currentTrack['skipCount'] += 1
						end
						writeLibraryToFile
					end
				else
					whisper "Empty tracklist", 3
					emptyAction = Proc.new { |input| false } # break command loop after any non-command input
					commandPrompt "empty", interactiveCommands, emptyAction
				end

				if shouldExitPlayerLoop
					whisper "Exiting player loop", 3
					break
				end
			end

			unbindGroup bindingGroupName
		end

		def getChapterIndexAtTime track, seconds
			chapterIndex = nil
			whisper "Finding chapter at #{seconds} seconds on track: #{track['title']}", 5
			if track.has_key? 'chapters'
				whisper "Looping through chapters.", 5
				track['chapters'].each_with_index { |chapter, index|
					chapterSeconds = getSecondsFromDurationString chapter['time']
					if chapterSeconds <= seconds
						chapterIndex = index
					else
						break
					end
				}
			else
				whisper "This track has no chapters: #{track['title']}", 2
			end
			chapterIndex
		end

		def getOffsetFromInputString input
			offset = 0
			input.strip!
			if input.match /^>+$/
				offset += input.length
			elsif input.match /^<+$/
				offset -= input.length - 1
			else
				offset = false
			end

			offset
		end

		def getChapterIndexByQuery input, track = nil, referenceChapterIndex = nil
			chapterIndex = nil
			track = @currentTrack if !track

			if track['chapters']
				chapterIndex = input.to_i - 1
				if chapterIndex < 0
					if referenceChapterIndex
						chapterIndex = referenceChapterIndex
					else
						chapterIndex = getChapterIndexAtTime track, @currentPlayerTime
					end
					chapterIndexOffset = getOffsetFromInputString input
					if chapterIndexOffset
						chapterIndex += chapterIndexOffset
					else
						chapterList = track['chapters'].map { |chapter| "#{chapter['time']} - #{chapter['name']}" }
						chapterIndex = firstFuzzyMatchIndex input, chapterList
					end
				end
				whisper "Choosing chapter #{chapterIndex}", 2
			else
				putsRealtime "No chapters on the current track."
			end

			chapterIndex
		end
		
		def seekToChapter chapterIndex, fadeOutPeriod = 1.0, fadeInPeriod = 0.25
			currentPlaybackSeconds = @currentPlayerTime
			whisper "currentPlaybackSeconds: #{currentPlaybackSeconds}", 3
			chapterTime = @currentTrack['chapters'][chapterIndex]['time']
			chapterSeconds = getSecondsFromDurationString chapterTime
			whisper "chapterSeconds: #{chapterSeconds}", 3
			isAbleToSeek = trackFileExists?(@currentTrack) || chapterSeconds > currentPlaybackSeconds
			whisper "isAbleToSeek: #{isAbleToSeek}", 3
			if isAbleToSeek
				fadeVolume 'out', fadeOutPeriod, @currentPlayerIndex if fadeOutPeriod > 0
				playerInputStreamName = "#{Player::MPLAYER_INPUT_FIFO_NAME}#{@currentPlayerIndex}"
				putInTempFile playerInputStreamName, "seek #{chapterSeconds} 2\n"
				fadeVolume 'in', fadeInPeriod, @currentPlayerIndex if fadeInPeriod > 0
			else
				putsRealtime "Download the file to be able to seek backwards."
			end
		end

		def getUserInputBPM

			@shouldShowPlaybackInfo = false
			firstTimeInSeconds = nil
			lastTimeInSeconds = nil
			iterations = 0;
			bpm = @currentTrack['bpm'];
			outputMessageLines = []
			outputMessageLines << "Current BPM is #{bpm}." if bpm
			outputMessageLines << "Hit ENTER key on the beat. Type \"k\" to accept, \"r\" to accept the nearest whole number, or anything else to cancel setting the BPM."
			putsRealtime outputMessageLines.join "\n"
			while bpmInput = readCharacter
				if not /[\n\r]/.match(bpmInput)
					if bpmInput.match /^[kr]$/
						if bpmInput == 'r'
							bpm = bpm.round
						end
					else
						bpm = nil
					end
					break
				end

				iterations += 1
				now = Time.now.to_f
				firstTimeInSeconds ||= now
				lastTimeInSeconds = now
				if lastTimeInSeconds != firstTimeInSeconds
					bpm = ((iterations - 1).to_f / (lastTimeInSeconds - firstTimeInSeconds) * 60.0).round(1);
					printRepeat "BPM: #{bpm} "
				end
			end
			print "\n"

			@shouldShowPlaybackInfo = true

			return bpm
		end

		def fadeVolume targetFadeVolume, duration, playerIndex
			whisper "fadeVolume(targetFadeVolume:#{targetFadeVolume}, duration:#{duration}, playerIndex:#{playerIndex})", 4
			transitionVolume = @currentVolume
			if targetFadeVolume == 'out'
				whisper "fading out volume", 2
				targetFadeVolume = 0
			elsif targetFadeVolume == 'in'
				targetFadeVolume = @volume
				whisper "fading in volume (to #{targetFadeVolume})", 2
			elsif targetFadeVolume.match /x$/
				multiplier = targetFadeVolume.to_f
				targetFadeVolume = transitionVolume * multiplier
				@volume = targetFadeVolume
				whisper "fading volume #{multiplier}x (to #{targetFadeVolume})", 2
			else
				targetFadeVolume = targetFadeVolume.to_f
				@volume = targetFadeVolume
				whisper "fading to volume #{targetFadeVolume}", 2
			end
			whisper "fading from #{transitionVolume} to #{targetFadeVolume} in #{duration} seconds (playerIndex: #{playerIndex})", 4
			volumeFadeInterval = 0.02
			volumeFadeStepCount = (duration.to_f / volumeFadeInterval).to_i
			volumeSpan = targetFadeVolume - transitionVolume
			lowerVolume = [transitionVolume, targetFadeVolume].min
			if volumeSpan != 0
				absoluteVolumeSmap = volumeSpan.abs
				if @isVolumeAlreadyLogarithmic
					volumeStepStrategy = Proc.new { |stepIndex|
						transitionVolume = lowerVolume + volumeSpan.abs * (stepIndex.to_f / volumeFadeStepCount)
					}
				else
					volumeStepStrategy = Proc.new { |stepIndex|
						transitionVolume = lowerVolume + 10**(Math.log10(volumeSpan.abs + 1) / volumeFadeStepCount * stepIndex) - 1
					}
				end
				stepFade = Proc.new { |stepIndex|
					volumeStepStrategy.call(stepIndex)
					putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{playerIndex}", "volume #{transitionVolume} 1\n"
					@currentVolume = transitionVolume
					trigger 'volume_change'
					sleep volumeFadeInterval
				}
				if volumeSpan > 0
					1.upto(volumeFadeStepCount - 1) { |stepIndex| stepFade.call stepIndex }
				else
					(volumeFadeStepCount - 1).downto(1) { |stepIndex| stepFade.call stepIndex }
				end
				putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{playerIndex}", "volume #{targetFadeVolume} 1\n"
				@currentVolume = targetFadeVolume
				trigger 'volume_change'
			else
				whisper "fading to the same volume: doing nothing", 4
			end

			trigger 'fade_end'
		end

		def rampSpeed targetRampSpeed, duration, playerIndex
			isValidInput = false
			whisper "targetRampSpeed: #{targetRampSpeed}", 3
			if targetRampSpeed
				transitionSpeed = @currentSpeed
				if targetRampSpeed == 'out'
					targetRampSpeed = 0
					@speedBeforeRampingOut = transitionSpeed
				elsif targetRampSpeed == 'in'
					targetRampSpeed = @speedBeforeRampingOut
				else
					targetRampSpeed = targetRampSpeed.to_f
					@speed = targetRampSpeed
					# does this work? # @speed = targetRampSpeed.to_f!
				end
				speedRampInterval = 0.02
				speedRampStepCount = duration / speedRampInterval
				speedStep = (targetRampSpeed - transitionSpeed) / duration * speedRampInterval
				whisper "about to ramp speed by #{speedStep} every #{speedRampInterval} seconds", 3
				for stepIndex in 1..speedRampStepCount
					transitionSpeed += speedStep
					putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{playerIndex}", "speed_set #{transitionSpeed}\n"
					@currentSpeed = transitionSpeed
					trigger 'speed_change'
					sleep speedRampInterval
				end
				putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{playerIndex}", "speed_set #{targetRampSpeed}\n"
				@currentSpeed = targetRampSpeed
				trigger 'speed_change'
				isValidInput = true
			else
				putsRealtime "Bad speed format, or track has no bpm set."
			end

			trigger 'speed_ramp_end'

			isValidInput
		end

		def findTag(query)
			verifiedTagName = nil
			meansToFindTag = nil

			if @library['tags'].has_key? query
				meansToFindTag = 'name'
				verifiedTagName = query
			else
				@library['tags'].each { |name, t|
					if t['aliases'] && t['aliases'].include?(query)
						meansToFindTag = 'alias'
						verifiedTagName = name
					end
				}
			end

			if verifiedTagName
				whisper "found tag '#{verifiedTagName}' by #{meansToFindTag} '#{query}'", 2
				return @library['tags'][verifiedTagName]
			else
				whisper "no tag found by query '#{query}'", 2
				return false
			end
		end

		def addTrackToTags(track, tagNames)
			whisper "adding tags: #{tagNames}", 2
			tagNames.each { |tagName|
				whisper "about to add to tag '#{tagName}'", 4
				matchingTag = findTag(tagName) || createTag(tagName)
				whisper "matchingTag: #{matchingTag}", 4
				matchingTag['tracks'] ||= []
				whisper "adding track to tag #{tagName}", 4
				matchingTag['tracks'] << track['id']
				matchingTag['tracks'].uniq!
			}
		end

		def removeTagsFromTrack(track, tagNames)
			whisper "removing tags: #{tagNames}", 2
			tagNames.each { |tagName|
				matchingTag = findTag tagName
				if matchingTag && matchingTag['tracks']
					matchingTag['tracks'].delete track['id'] if matchingTag['tracks'].include? track['id']
				end
			}
		end

		def combineTags(tagNames)
			firstTagName = tagNames.shift
			firstTag = findTag firstTagName

			if firstTag && tagNames.length > 0
				whisper "merging #{tagNames.join ', '} into #{firstTagName}", 3
				tagNames.each { |collapsingTagName|
					collapsingTag = findTag collapsingTagName
					if collapsingTag && collapsingTag != firstTag
						firstTag['aliases'] ||= []
						firstTag['aliases'] << collapsingTagName
						if collapsingTag['tracks'] && collapsingTag['tracks'].length > 0
							firstTag['tracks'] ||= []
							firstTag['tracks'].concat collapsingTag['tracks']
						end
						deleteTag collapsingTagName
					end
				}

				firstTag['aliases'].uniq!
				firstTag['tracks'].uniq!
			else
				putsRealtime "provide 2 or more tags to join together"
			end

			firstTag
		end

		def createTag(tagName)
			whisper "creating tag '#{tagName}'", 2
			@library['tags'][tagName] = {}
			@library['tags'][tagName]
		end

		def deleteTag(tagName)
			@library['tags'].delete tagName if @library['tags'].has_key? tagName
		end

		def play(track, interactiveCommands)
			fileAlreadyExists = !@forceStreaming && trackFileExists?(track) # TODO: I shouldn't need to check twice
			streaming = @forceStreaming || (!fileAlreadyExists && !@enableDownload)

			if @noNetwork && !fileAlreadyExists
				puts "No local file to play: #{track['title']}"
				return response
			end

			trigger 'play_start'

			bindingGroupName = 'play'

			whisper "playing track: #{track}", 3
			@currentPlayerIndex = 1 - @currentPlayerIndex
			whisper "@currentPlayerIndex: #{@currentPlayerIndex}", 4
			response = {
				:exit => true,
				:playTime => 0
			}
			playerStartupOptions = []

			playerInputStreamName = "#{Player::MPLAYER_INPUT_FIFO_NAME}#{@currentPlayerIndex}"
			deleteStream playerInputStreamName
			playerInputFile = makeStream playerInputStreamName

			playerStdoutName = "#{Player::MPLAYER_STDOUT_BUFFER_NAME}#{@currentPlayerIndex}"
			playerStdoutFile = getTempFilePath playerStdoutName

			playerStartupOptions << "-slave -quiet -input file=#{playerInputFile}"
			playerStatus = nil
			playerAction = Proc.new { |command|
				tmpPath = putInTempFile playerInputStreamName, "#{command}\n"
				true
			}

			if track['mark']
				puts "Starting from mark at #{getDurationStringFromSeconds track['mark']} seconds."
				offsetSeconds = getSecondsFromDurationString track['mark']
				playerStartupOptions << "-ss #{offsetSeconds}"
				loadLibrary
				editingTrack = matchExistingLibraryTrack track
				editingTrack.delete 'mark'
				writeLibraryToFile
			elsif @loop && track['loop'].kind_of?(Array)
				whisper "ooh, this track has has an A/B loop!", 2

				if not streaming
					duration = track['loop'][1] - track['loop'][0]

					playerAction.call "seek 0 1"

					whisper "setting some player startup options", 4
					# loop back from B to A
					playerStartupOptions << "-ss #{track['loop'][0]}"
					playerStartupOptions << "-endpos #{duration}"
				else
					titleBlock "This track has an A/B loop, but looping is not supported while streaming. Add the -d option to enable downloading."
				end

			end

			if fileAlreadyExists
				mediaFilePath = firstTrackFile track
			else
				if streaming
          if @youtubeDLTrackTypes.include? track['type']
						whisper "streaming youtube track", 2
						streamName = 'youtube-stream'
						deleteStream streamName
						streamPath = mediaFilePath = makeStream streamName
						if not downloadTrack track, streamPath
							whisper "could not download/stream track", 1
							mediaFilePath = nil
						end
					else
						whisper "streaming other type of track (#{track['type']})", 2
						streamName = 'mp3-stream'
						# mplayer 4.2.1 on Mac OS Sierra unable to stream HTTPS
						if /^https:\/\//.match track['src']
							streamPath = mediaFilePath = makeStream streamName
							if not downloadTrack track, streamPath
								whisper "could not download/stream track", 1
								mediaFilePath = nil
							end
						else
							mediaFilePath = track['src']
						end
					end
				end
			end

			if not mediaFilePath
				puts "File not found for #{track['title']}."
				return response
			end

			if !streamName
				playerStartupOptions << "-loop 0" if @loop
			end

			@speed = 1 if @speed < 0.01
			speed = @speed
			if @playingBPM && @currentTrack['bpm']
				speed = @speed * @playingBPM / @currentTrack['bpm']
			end

			if @currentVolume != @volume
				@currentVolume = @volume # they may differ, but at this point, only @volume matters
				trigger 'volume_change'
			end
			playerStartupOptions += @playerOverrideCommands
			playerStartupOptions += ["-volume #{@volume}"]
			playerStartupOptions += ["-speed #{speed}"]

			if track['loudness']
				playerStartupOptions += ["-volume #{(getMplayerConfigNumericProperty('volume') / track['loudness']).round}"]
			end

			response[:startTime] = Time.now.to_f

			@inputThread.kill if @inputThread
			@inputThread = Thread.new {
				whisper "commandPrompt start (opening input thread)", 4
				commandPrompt Player::PLAYER_APPLICATION, interactiveCommands, playerAction
				whisper "commandPrompt end", 4
			}
			if @playerTemporaryInteractiveCommands.length > 0
				playerAction.call @playerTemporaryInteractiveCommands.join("\n")
				@playerTemporaryInteractiveCommands = []
			end
			@playerApplicationThreads[@currentPlayerIndex] = Thread.new {
				playerCommand = "#{Player::PLAYER_APPLICATION} \"#{mediaFilePath}\" #{playerStartupOptions.join ' '} > #{playerStdoutFile}"
				whisper playerCommand, 3
				playerStatus = `#{playerCommand} 2> /dev/null`
				whisper "#{Player::PLAYER_APPLICATION} is finished. killing user input thread", 4
				@inputThread.kill if @inputThread
			}

			@shouldShowPlaybackInfo = true # might have been set false if the player quit while realtime output was hidden
			bind('time_update', Proc.new {
				if @currentTrack.has_key?('chapters')
					newChapterIndex = getChapterIndexAtTime @currentTrack, @currentPlayerTime
					if newChapterIndex
						if @currentChapterIndex != newChapterIndex
							@currentChapterIndex = newChapterIndex
							trigger 'chapter_change'
						end
					end
				end
				showPlaybackInfo
			}, bindingGroupName)
			bind('chapter_change', Proc.new {
				# check if we need to skip this chapter
				if !@currentlySkippingChapter &&
						@currentTrack['chapters'][@currentChapterIndex].has_key?('skip') &&
						@currentTrack['chapters'][@currentChapterIndex]['skip'] == true
					@currentlySkippingChapter = @currentChapterIndex
					nextNonSkippingChapter = nil
					whisper @currentTrack['chapters'].slice(@currentChapterIndex + 1, -1), 3 # XXX
					@currentTrack['chapters'].each_with_index { |chapter, index|
						if !nextNonSkippingChapter && index > @currentChapterIndex && !chapter.has_key?('skip') || !chapter['skip']
							nextNonSkippingChapter = index
						end
					}
					if nextNonSkippingChapter
						seekToChapter nextNonSkippingChapter, 0.25, 0.25
					else
						# TODO: fade out and skip to next track (i.e. quit player)
					end
					@currentlySkippingChapter = nil
				end
			}, bindingGroupName)
			while @playerApplicationThreads[@currentPlayerIndex].alive?
				playerResponseDelay = 0.1
				playerTimeResponse = getMplayerProperty('get_time_pos', /^(ANS_TIME_POSITION=|.*Time: )(.*?)(\?)?$/, playerResponseDelay)
				if playerTimeResponse
					@currentPlayerTime = playerTimeResponse.to_f
					trigger 'time_update'
				end
			end
			# @playerApplicationThreads[@currentPlayerIndex].join
			whisper "killing user input thread (again)", 4
			@inputThread.kill if @inputThread # FIXME: overkill?

			response[:endTime] = Time.now.to_f

			deleteStream playerInputStreamName
			deleteTempFile playerStdoutName

			response[:playTime] = response[:endTime] - response[:startTime]

			deleteStream streamName if streamName
			 
			trigger 'play_end'

			unbindGroup bindingGroupName

			response[:exit] = playerStatus
			response
		end

		def showPlaybackInfo
			if @shouldShowPlaybackInfo && @configuredVerbosity > -1 && @configuredVerbosity < 5
				playbackInfo = []
				unicodeChars = {
					:speaker => "🔈",
					:timer => "⏲",
					:openBook => "📖",
					:label => "🏷",
					:star => "★",
					:crossArrows => "⤮",
					:parallelArrows => "⇉",
					:whiteStar => "☆",
					:floppyDisk => "💾"
				}

				# show shuffle or regular playback
				playbackInfo << "#{@shuffle ? unicodeChars[:crossArrows] : unicodeChars[:parallelArrows]}"

				# show volume
				volumeIndication = "█" * (@currentVolume / 10).to_i + ["", "▁", "▂", "▃", "▄", "▅", "▆", "▇"][(@currentVolume % 10 / 1.25).to_i]
				volumeIndication = "[#{volumeIndication}#{" " * (10 - volumeIndication.length)}]"
				playbackInfo << "#{unicodeChars[:speaker]} #{volumeIndication}"

				# show playback position
				timeMessage = "#{unicodeChars[:timer]}  #{getDurationStringFromSeconds @currentPlayerTime}"
				timeMessage += "/#{@currentTrack['duration']}" if @currentTrack.has_key?('duration')
				timeMessage += "(#{(@currentSpeed * 10).round / 10.0}x)" if @currentSpeed != 1
				playbackInfo << timeMessage

				# show if the track file is downloaded
				playbackInfo << "#{unicodeChars[:floppyDisk]}" if trackFileExists?(@currentTrack)

				# show track rating
				if @currentTrack.has_key? 'rating'
					playbackInfo << "#{unicodeChars[:star]} #{@currentTrack['rating']}"
				end

				# show current chapter name
				if @currentTrack.has_key?('chapters')
					if @currentChapterIndex
						playbackInfo << "#{unicodeChars[:openBook]}  #{@currentTrack['chapters'][@currentChapterIndex]['name']}" # undefined method `[]' for nil:NilClass (NoMethodError)
					end
				else
					@currentChapterIndex = nil
				end

				# show tags on this track
				currentTags = getTrackTags @currentTrack
				if currentTags && currentTags.length > 0
					playbackInfo << "#{unicodeChars[:label]}  #{currentTags.join ', '}"
				end

				# check again if realtime output has been disabled while were doing all this stuff
				if @shouldShowPlaybackInfo && @configuredVerbosity > -1 && @configuredVerbosity < 5
					printRepeat(playbackInfo.join(' '), true)
				end
			end
		end

		def putsRealtime message
			if @shouldShowPlaybackInfo
				print "\n#{message}\n"
			else
				puts message
			end
		end

		def getMplayerProperty property, pattern = nil, responseDelay = nil
			output = nil
			pattern ||= /^()(.*)$/
			command = "#{property}\n"
			command = "get_property #{command}" if not property.match(/^get_/)
			putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{@currentPlayerIndex}", command
			sleep responseDelay if responseDelay
			lastPlayerOutput = tailTempFile "#{Player::MPLAYER_STDOUT_BUFFER_NAME}#{@currentPlayerIndex}"
			if lastPlayerOutput
				whisper "read #{property} from player, output: #{lastPlayerOutput}", 5
				matches = lastPlayerOutput.match pattern
				output = matches[2] if matches
			end
			output
		end

		def getMplayerConfigNumericProperty(propertyName, defaultValue = 0.0)
			playerCommands = []
			playerCommands += @playerOverrideCommands if @playerOverrideCommands
			propertyValue = defaultValue

			playerCommands.each { |command|
				if command.include? propertyName
					propertyValue = command.match(/.*-#{propertyName} ([0-9.]+)/)[1].to_f
				end
			}

			propertyValue.to_f
		end

		def nextTrack
			whisper "next track", 2
			if @shuffle
				# FIXME: this should happen regardles of @shuffle, but it would mess with @trackIndex. With @shuffle == true, it doesn't matter.
				filterTracksOnDeck()
				shuffleIndex()
			else
				@trackIndex += 1

				if @trackIndex > @tracks.length - 1

					if @youtubeSearchPage && !@noNetwork
						@youtubeSearchPage += 1
						searchedTracks = searchYouTube(@youtubeSearch, (@youtubeSearchPage - 1) * 20)
						useTracks(searchedTracks, true) if searchedTracks
					else
						@trackIndex %= @tracks.length
					end

				end

			end
		end

		def useTracks tracks, append = true
			if append
				whisper "Adding #{tracks.length} tracks to the end of your play queue."
			else
				whisper "Replacing your play queue with #{tracks.length} tracks."
				@tracks = []
			end
			@tracks += tracks
			filterTracksOnDeck
			putInTempFile('tracks', listTrackTitles(@tracks).join("\n"), false)
			if @trackIndex && @trackIndex > @tracks.length - 1
				@trackIndex = 0
			end
		end

		def filterTracksOnDeck
			if @trackFilters
				@tracks = filterTracks @tracks, @trackFilters
			end

			if @trackExcludeFilters
				@tracks = filterTracks @tracks, @trackExcludeFilters, true
			end
		end

		def shuffleIndex
			@trackIndex = Random.rand(@tracks.length - 1) if @tracks.length > 1
		end

		def setLibraryPath libraryPath
			@tunewichDirectory = libraryPath
			if not Dir.exist? @tunewichDirectory
				puts "Please create the directory '#{@tunewichDirectory}'."
				exit
			end

			@fileDirectory = "#{@tunewichDirectory}/music"
			Dir.mkdir @fileDirectory if not Dir.exist? @fileDirectory

			@libraryFilePath = "#{@tunewichDirectory}/tunewich-library.json"
			if not File.exist? @libraryFilePath
				raise "TODO: create library file at #{@libraryFilePath}"
			end

			loadLibrary
		end

		def extendHash sourceTrack, overrideTrack
			overrideTrack.each { |property, value|
				sourceTrack[property] ||= value
			}
			sourceTrack
		end

		def matchExistingLibraryTrack track
			@library['tracks'].each { |id, t|
				if t['src'] === track['src']
					extendHash t, track
					track = t
					track.delete 'unattached' if track.has_key? 'unattached'
					break
				end
			}
			track
		end

		def getTrackTags track
			tags = []
			@library['tags'].each { |name, tag|
				tags << name if tag.has_key?('tracks') && tag['tracks'].include?(track['id'])
			}
			tags
		end

		def getTrackTitles tracks
			tracks.map{|t| t['title']}
		end

		def findTrackIndex(query)
			firstFuzzyMatchIndex query, getTrackTitles(@tracks)
		end

		def findPlaylistName(query)
			firstFuzzyMatchValue query, @library['playlists'].keys
		end

		def fuzzyStringSearchInList(query, list)
			queryPattern = Regexp.new(query + '|' + query.gsub(/\s+/, '').split('').join('.*'), Regexp::IGNORECASE)
			matches = []
			list.each_with_index do |value, index|
				matchedPortion = queryPattern.match(value)

				if matchedPortion
					match = {
						:index => index,
						:value => value,
						:matchLength => matchedPortion[0].length
					};
					match[:density] = query.length.to_f / match[:matchLength].to_f
					match[:breadth] = match[:matchLength].to_f / match[:value].length.to_f
					match[:score] = match[:density] * 10 + match[:breadth]
					whisper "match:score]: #{match}", 3 # XXX
					matches << match
				end

			end

			if matches.length > 1
				matches.sort! { |a,b| b[:score] <=> a[:score] }
			end

			matches
		end

		def firstFuzzyMatch(query, list)
			matches = fuzzyStringSearchInList query, list
			matches.length ? matches[0] : false
		end

		def firstFuzzyMatchValue(query, list)
			match = firstFuzzyMatch query, list
			match ? match[:value] : false
		end

		def firstFuzzyMatchIndex(query, list)
			match = firstFuzzyMatch query, list
			match ? match[:index] : false
		end

		def deleteTrackFile(track)
			`rm #{getTrackFilePrefix track}*`
		end

		def firstTrackFile(track)
			files = findTrackFiles(track)
			files.length ? files[0] : nil
		end

		def findTrackFiles(track)
			globString = "#{getTrackFilePrefix track}*"
			files = Dir.glob(globString)
			files.delete_if { |fileName| fileName.match /\.part$/ }
			files
		end

		def trackFileExists?(track)
			findTrackFiles(track).length > 0
		end

		def getIdFromFileName(fileName)
			id = fileName.gsub(/^tunewich-([A-Za-z0-9_-]{11}).*$/) {
				$1
			}
			id != fileName ? id : false
		end

		def getTrackFilePrefix(track)
			"#{@fileDirectory}/tunewich-#{track['id']}"
		end

		# @param hash track
		# @returns string download command
		def getDownloadCommand(track, downloadFeedbackFile = '/dev/null', streamPath = nil)
			downloadCommand = ''

      if @youtubeDLTrackTypes.include? track['type']
				# TODO: remove --Frag0, --Frag1, ..., --FragN files? Would this interfere with playback if downloading a playing track?
				youtubeDlCommandBegin = "youtube-dl -f #{@preferredFileFormat} -q"
				# youtubeDlCommandBegin = "youtube-dl -f #{@preferredFileFormat} --no-part --no-cache-dir --no-continue"
				youtubeDlCommandEnd = "-- #{track['src']}"
				if streamPath
					downloadCommand = "#{youtubeDlCommandBegin} -o - #{youtubeDlCommandEnd} > \"#{streamPath}\" 2> \"#{downloadFeedbackFile}\""
				else
					downloadCommand = "#{youtubeDlCommandBegin} -o \"#{getTrackFilePrefix track}-%(title)s.%(ext)s\" #{youtubeDlCommandEnd}"
				end
			else
				if streamPath
					downloadCommand = "curl -sL \"#{track['src']}\" > #{streamPath}"
				else
					downloadCommand = "curl -sL \"#{track['src']}\" > #{getTrackFilePrefix track}.mp3" #FIXME: don't assume mp3 file extension
				end
			end

			downloadCommand
		end

		# @param hash track
		# @param string/nil streamPath
		# @returns integer PID of download process, or nil if download failed
		def downloadTrack(track, streamPath = nil)
			if @noNetwork
				puts "not downloading --no-network"
				return
			end

			downloadPid = nil
			downloadFeedbackFileName = 'download-feedback'
			downloadFeedbackFile = createTempFile downloadFeedbackFileName
			downloadCommand = getDownloadCommand track, downloadFeedbackFile, streamPath

			if streamPath
				downloadPid = spawn(downloadCommand)
				trigger 'download_end', track
			else
        trigger 'download_begin', track
        downloadThread = Thread.new {
          downloadPid = spawn("#{downloadCommand} 2> \"#{downloadFeedbackFile}\"")

          if trackFileExists? track
            trigger 'download_complete', track
          else
            trigger 'download_fail', track
          end
          trigger 'download_end', track
        }
			end

			deleteTempFile downloadFeedbackFileName

			downloadPid
		end

		def notify(message)
			if @configuredVerbosity > 0
				if UNAME == 'Linux'
						`notify-send --expire-time=3000 --urgency=low tunewich "#{message}"`
				elsif UNAME == 'Darwin'
					clean_message = message.gsub /"/, '\\"'
					system "osascript -e 'display notification \"#{clean_message}\" with title \"tunewich\"' &>/dev/null"
				end
			end
		end

		def titleBlock(message, fill = '=')
			width = `tput cols`.chomp.to_i
			blockRow = fill * width
			padding = '  '
			marginSize = (width - message.length) / 2 - padding.length
			marginLeft = marginSize > 1 ? fill * marginSize : ''
			marginRight = marginLeft
			marginRight += fill if (width - message.length) % 2 == 1
			puts "\n#{blockRow}"
			puts "#{marginLeft}#{padding}#{message}#{padding}#{marginRight}"
			puts blockRow
			notify message
		end

		def updateRadioMetadata metadata
			if @streamingServerType == 'homebrew'
				serverUsername = 'admin'
				serverPassword = 'hackme'
				serverHost = 'localhost:8000'
				serverMountName = 'radio'
				# ruby 2.3.1 `open` doesn't support userinfo (user:password@host)
				`curl -s "http://#{serverUsername}:#{serverPassword}@#{serverHost}/admin/metadata?mount=/#{serverMountName}&mode=updinfo&song=#{URI::encode metadata}"`
			end
		end

		##
		# File Methods
		##

		def getTempFilePath(name, shouldIncludeSessionID = true)
			nameSegments = ["tunewich"]
			nameSegments << @sessionID if shouldIncludeSessionID
			nameSegments << name
			"#{$tunewichTmpDirectory}/#{nameSegments.join '-'}"
		end

		def createTempFile(name)
			whisper "make tmp #{name}", 4
			putInTempFile name, ''
		end

		def putInTempFile(name, value, shouldIncludeSessionID = true)
			path = getTempFilePath(name, shouldIncludeSessionID)
			# FIXME: why does this stall when writing to a FIFO before something is reading from it?
			Thread.new {
				# FIXME: trying to put it in a new thread...maybe won't fix the problem, but it will unblock the main thread.
				writeResult = File.write(path, value)
				whisper "#{name} << '#{value.chomp}' (#{writeResult})", 5
			}
			path
		end

		def readTempFile(name, shouldIncludeSessionID = true)
			whisper "read tmp #{name}", 5
			path = getTempFilePath(name, shouldIncludeSessionID)

			if File.exist? path
				whisper "read tmp #{name}: exists", 5
				contents = File.read path
				whisper "read tmp #{name}, contents: #{contents}", 5
				return contents
			else
				whisper "read tmp #{name}: missing", 5
				return ''
			end
		end

		def tailTempFile(name, shouldIncludeSessionID = true)
			whisper "tail tmp #{name}", 5
			content = readTempFile(name, shouldIncludeSessionID)
			lastLine = ''
			if content && content.length > 0
				lastLine = content.gsub("\r","\n").lines.pop.strip.chomp
			end
			lastLine
		end

		def deleteTempFile(name, shouldIncludeSessionID = true)
			whisper "delete tmp #{name}", 4
			path = getTempFilePath(name, shouldIncludeSessionID)

			if File.exist? path
				File.delete path
			end
		end

		def makeStream(name)
			path = getTempFilePath name
			whisper "mkfifo #{path}", 4

			if File.exist? path
				File.delete path
				# raise "The temp file '#{name}' already exists. (#{path})"
			end

			if not system "mkfifo \"#{path}\""
				raise "ERROR: Could not create the stream file (#{path})"
			end

			File.exist?(path) && path
		end

		alias deleteStream deleteTempFile

		##
		# Library Methods
		##

		def usePlaylist(name, append = false)
			@playlistName = name
			tracks = []

			if @library['playlists'][@playlistName]['tracks']
				@library['playlists'][@playlistName]['tracks'].each do |trackReference|
					tracks << @library['tracks'][trackReference]
				end
			end

			useTracks tracks, append
		end

		def useEntireLibrary
			tracks = []

			@library['tracks'].keys.each do |trackKey|
				tracks << @library['tracks'][trackKey]
			end

			useTracks tracks, false
		end

		def processLibraryJSON(json)
			{
				:json => json,
				:hash => Digest::MD5.hexdigest(json),
				:data => JSON.parse(json)
			}
		end

		def loadLibrary
			libraryInfo = processLibraryJSON File.read(@libraryFilePath)
			if libraryInfo
				@library = libraryInfo[:data]
				@libraryHash = libraryInfo[:hash]
				if @tracks && @tracks.length > 0
					@tracks.each_with_index { |track, index|
						@tracks[index] = matchExistingLibraryTrack(@tracks[index])
					}
				end
			end
		end

		# TODO: find places where stuff is not being saved, and do matchExistingLibraryTrack first
		def writeLibraryToFile shouldPrompt = false
			if shouldPrompt && !@writeEnabled
				return if !confirm("Write changes to library?")
			end
			libraryJSON = JSON.pretty_generate(@library)
			if not libraryJSON || libraryJSON == 'null' || libraryJSON.length < 1
				putsRealtime "Sorry! The loaded library has been corrupted. Please restart the player if you want to save any changes to your library."
				return
			end
			libraryOnFile = processLibraryJSON File.read(@libraryFilePath)
			if @libraryHash == libraryOnFile[:hash] || confirm("Library file has changed since last load. Overwrite?")
				libraryInfo = processLibraryJSON libraryJSON
				File.write(@libraryFilePath, libraryJSON)
				@libraryHash = libraryInfo[:hash]
				whisper "Saved change to library file.", 2
			end
		end

		def removeTrackFromLibrary(id)
			whisper "Removing track (#{id}) from library", 2
			@library['tracks'].delete id
			@library['playlists'].each { |playlistName, playlist|
				index = playlist['tracks'].index id
				if index
					playlist['tracks'].delete_at index
				end
			}
			@library['tags'].each { |tagName, tag|
				index = tag.has_key?('tracks') ? tag['tracks'].index(id) : nil
				if index
					tag['tracks'].delete_at index
				end
			}
		end

		def interactiveCleanup
			cleanupSelection = {}

			commands = {
			}

			confirmMsg = "Choose a command, or \"y\" to write changes to file"
			if confirm confirmMsg, commands
				writeLibraryToFile
			else
				puts "No changes saved."
			end

			puts "Cleanup finished."
		end

		def determineRelativeSpeed input, track, shouldSetPlayingBPM = false
			relativeSpeed = input.to_f
			whisper "relativeSpeed: #{input} -> #{relativeSpeed}", 3
			if input.to_s.match /bpm$/
				if track.has_key? 'bpm'
					inputBPM = relativeSpeed
					if shouldSetPlayingBPM
						@playingBPM = inputBPM
						whisper "Setting playing BPM to #{@playingBPM}", 1
					end
					relativeSpeed = inputBPM / track['bpm']
				else
					relativeSpeed = nil
				end
			end
			relativeSpeed
		end

		def matchPropertyWithRangeString rangeString, hash, property
			rangeParts = " #{rangeString} ".split('-')
			isAMatch = false
			if hash.has_key? property
				if rangeParts.length == 2
					lowerMatch = rangeParts[0] == " " || hash[property] >= rangeParts[0].to_i
					upperMatch = rangeParts[1] == " " || hash[property] <= rangeParts[1].to_i
					isAMatch = lowerMatch && upperMatch
				else
					isAMatch = rangeParts[0].to_i == hash[property].to_i
				end
			end
			isAMatch
		end

		def getDescendantTagNames ancestorTagName, depth = 0
			whisper "getDescendantTagNames: depth #{depth}", 4
			allDescendantTags = []
			@library['tags'].each { |tagName, tag|
				if tag.has_key?('parents') && tag['parents'].include?(ancestorTagName)
					allDescendantTags << tagName
					whisper "#{ancestorTagName} #{">" * (depth + 1)} #{tagName}", 2
					allDescendantTags += getDescendantTagNames tagName, (depth + 1)
				end
			}
			allDescendantTags
		end

		def getAncestorTagNames descendantTagName, depth = 0
			whisper "getAncestorTagNames(descendantTagName:#{descendantTagName}, depth:#{depth})", 4
			allAncestorTags = []
			if @library['tags'].has_key? descendantTagName
				whisper "tag #{descendantTagName} has a definition", 5
				thisTag = @library['tags'][descendantTagName]
				if thisTag && thisTag['parents']
					whisper "thisTag['parents'].each ", 5
					thisTag['parents'].each { |tagName|
						whisper "tagName: #{tagName}", 5
						allAncestorTags << tagName
						whisper "#{descendantTagName} #{"<" * (depth + 1)} #{tagName}", 2
						allAncestorTags += getAncestorTagNames tagName, (depth + 1)
					}
				end
			else
				whisper "tag #{descendantTagName} is referenced as a parent, but has no definition of its own", 5
			end
			whisper "allAncestorTags.uniq", 5
			allAncestorTags.uniq
		end

		def filterTracks tracks, filters, isExcludeFilter = false
			whisper 'filterTracks', 4
			action = isExcludeFilter ? 'delete_if' : 'keep_if'

			if filters.has_key? 'local'
				tracks.send(action) { |t|
					trackFileExists? t
				}
			end

			if filters.has_key? 'rating'
				if filters['rating'] && filters['rating'].length > 0
					tracks.send(action) { |t|
						matchPropertyWithRangeString filters['rating'], t, 'rating'
					}
				else
					tracks.send(action) { |t| t.has_key? 'rating' }
				end
			end

			if filters.has_key? 'tag'
				if filters['tag']
					# TODO: add a tag fuzzy factor: include tags of tracks that have the current tag (only 1 degree separation to start)
					selectedTags = []
					unionTagTracks = []
					filterTags = filters['tag'].split(' ')
					descendantFilterTags = []
					filterTags.each { |tagName| descendantFilterTags += getDescendantTagNames(tagName).map {|name| "+#{name}"} }
					filterTags += descendantFilterTags
					filterTags.each { |tagName|
						unionPattern = /^\+/
						isUnionTag = tagName.match unionPattern
						tagName.sub!(unionPattern, '') if isUnionTag
						if @library['tags'].has_key? tagName
							selectedTags << {:name => tagName, :tag => @library['tags'][tagName], :union => isUnionTag}
							if isUnionTag && @library['tags'][tagName]['tracks']
								unionTagTracks += @library['tags'][tagName]['tracks'];
							end
						else
							@library['tags'].each { |name, libraryTag|
								if libraryTag['aliases']
									libraryTag['aliases'].each { |tagAlias|
										if tagAlias == tagName
											selectedTags << {:name => name, :tag => libraryTag, :union => isUnionTag}
											if isUnionTag && @library['tags'][tagName]['tracks']
												unionTagTracks += @library['tags'][tagName]['tracks']
											end
										end
									}
								end
							}
						end
					}

					whisper "filtering for tags: #{selectedTags}", 4
					if selectedTags.length > 0
						# TODO: make a list of IDs and filter tracks against it once, rather than filtering separately for each tag
						selectedTags.each { |tagInfo|
							tracks.send(action) { |t| tagInfo[:tag]['tracks'] && tagInfo[:tag]['tracks'].index(t['id']) || unionTagTracks.index(t['id']) }
						}

						if unionTagTracks.length > 0
							tracks.sort! { |a, b| unionTagTracks.count(b['id']) <=> unionTagTracks.count(a['id']) }
						end
					else
						puts "No matches for \"#{filters['tag']}\". Available tags are: #{listAllTagsWithAliases.join ", "}"
					end
				else
					@library['tags'].each { |name, libraryTag|
						tracks.send(action) { |t|
							libraryTag['tracks'] && libraryTag['tracks'].index(t['id'])
						}
					}
				end
			end

			if filters.has_key? 'bpm'
				if filters['bpm'] && filters['bpm'].length > 0
					tracks.send(action) { |t|
						matchPropertyWithRangeString filters['bpm'], t, 'bpm'
					}
				else
					tracks.send(action) { |t| t.has_key? 'bpm' }
				end
			end

			if filters['title']
				matches = fuzzyStringSearchInList(filters['title'], getTrackTitles(tracks))
				matches.sort! { |a,b| b[:density] <=> a[:density] }
				matchedIds = []
				matchesByTrackTitle = {}
				matches.each { |match|
					track = tracks[match[:index]]
					matchedIds << track['id']
					matchesByTrackTitle[track['title']] = match
				}
				tracks.send(action) { |t| matchedIds.include? t['id'] }
				if !isExcludeFilter
					tracks.sort! { |a,b| matchesByTrackTitle[b['title']][:density] <=> matchesByTrackTitle[a['title']][:density] }
				end
			end

			if filters['last']
				now = Time.now.to_i
				watershed = now - getSecondsFromDurationString(filters['last']).to_i
				tracks.send(action) { |t|
					t['lastPlayed'] ? t['lastPlayed'].to_i >= watershed : false
				}
			end

			if filters['min-duration']
				minDuration = getSecondsFromDurationString filters['min-duration']
				tracks.send(action) { |t|
					t['duration'] ? getSecondsFromDurationString(t['duration']) > minDuration : false
				}
			end

			if filters.has_key? 'ab'
				tracks.send(action) { |track|
					if track
						track.has_key? 'loop'
					else
						false
					end
				}
			end

			if filters.has_key? 'chapters'
				tracks.send(action) { |track|
					if track
						track.has_key? 'chapters'
					else
						false
					end
				}
			end

			puts "#{tracks.length} matches for filters"

			tracks
		end

		def listAllTagsWithAliases
			allTagNames = []

			@library['tags'].each { |name, libraryTag|
				allTagNames << name
				if libraryTag['aliases']
					libraryTag['aliases'].each { |tagAlias| allTagNames << tagAlias }
				end
			}

			allTagNames.sort
		end

		def createPlaylist name, tracks = [], description = ''
			newPlaylist = {
				'description' => description,
				'public' => true,
				'tracks' => tracks
			}
			@library['playlists'][name] = newPlaylist
		end

		def createTrack url, type
      newTrack = {
				'type' => type,
				'unattached' => true
      }

			if type == 'youtube'
				newTrack['src'] = looksLikeAYouTubeID?(url) ? url : getYoutubeIdFromUrl(url)
				newTrack['id'] = newTrack['src']
			elsif type == 'ocremix'
				newTrack['src'] = url # TODO: getOCRemixSource url
				newTrack['id'] = getIDFromOCRemixURL url
			else
				newTrack['src'] = url
				newTrack['id'] = Digest::MD5.hexdigest(url).to_s
			end

      newTrack
		end

		def getYouTubeTrackInfo youtubeVideoID
			track = {
				'type' => 'youtube',
				'src' => youtubeVideoID,
				'id' => youtubeVideoID
			}
			if @noNetwork
				puts "no getYouTubeTrackInfo --no-network"
				return track
			end
			json = `youtube-dl -j -- #{youtubeVideoID} 2>/dev/null` # suppress errors
			return track if !json || json.length == 0

			trackInfo = JSON.parse(json)
			track['title'] = trackInfo['fulltitle']
			track['duration'] = getDurationStringFromSeconds(trackInfo['duration'])
			track['description'] = trackInfo['description']
			track['link'] = trackInfo['webpage_url'] || "https://youtu.be/#{youtubeVideoID}"
			track['type'] = trackInfo['extractor']
			track['sourceTags'] = trackInfo['tags'] if trackInfo['tags']
			whisper "sourceTags: #{trackInfo['tags']}", 4

			track
		end

		def getSoundcloudTrackInfo soundcloudURL
			track = {
				'type' => 'soundcloud',
				'src' => soundcloudURL,
				'id' => Digest::MD5.hexdigest(soundcloudURL).to_s
			}
			if @noNetwork
				puts "no getSoundcloudTrackInfo --no-network"
				return track
			end
			json = `youtube-dl -j -- #{soundcloudURL} 2>/dev/null` # suppress errors
			return track if !json || json.length == 0

			trackInfo = JSON.parse(json)
			track['title'] = trackInfo['fulltitle']
			track['duration'] = getDurationStringFromSeconds(trackInfo['duration'])
			track['description'] = trackInfo['description']
			track['link'] = trackInfo['webpage_url'] || soundcloudURL
			track['type'] = trackInfo['extractor']
			track['sourceTags'] = trackInfo['tags'] if trackInfo['tags']
			whisper "sourceTags: #{trackInfo['tags']}", 4

			track
		end

		def updateTrackInfo track, trackInfo = nil, force = false
			if track['type'] === 'youtube'
				trackInfo ||= getYouTubeTrackInfo track['id']
			elsif track['type'] === 'soundcloud'
				trackInfo ||= getSoundcloudTrackInfo track['src']
			end
			if trackInfo
				track['title'] = trackInfo['title'] if (!track['title'] || force) && trackInfo['title'] && trackInfo['title'].length > 0

				if (!track['description'] || force) && trackInfo['description'] && trackInfo['description'].length > 0
					if !track['chapters'] || force
						chapters = getChaptersFromDescription trackInfo['description'].lines
						track['chapters'] = chapters if chapters && chapters.length > 0
					end
				end

				track['duration'] = trackInfo['duration'] if trackInfo['duration']
				track['link'] = trackInfo['url'] if trackInfo['url']
				track['type'] = trackInfo['type'] if  trackInfo['type']
			end

			track
		end

		def getChaptersFromDescription description
			description.grep(/[0-9]+:[0-9:.]+/).map! do |line|
				matches = line.match(/^(.*?)[ (]*([0-9]+:[0-9:.]+)[ )]*(.*)$/)
				{
					'time' => matches[2],
					'name' => "#{matches[1]} #{matches[3]}".gsub(/^[^0-z]/, '').strip
				}
			end
		end

		def addTrackToLibrary track
			track.delete 'unattached' if track.has_key? 'unattached'
			trackReference = track['id']
			track['dateAdded'] = Time.now.to_i
			@library['tracks'][trackReference] ||= track

			trackReference
		end

		def addTrackReferenceToPlaylist trackReference, playlistName
			track = @library['tracks'][trackReference]

			if !@library['playlists'][playlistName].has_key?('tracks') || !@library['playlists'][playlistName]['tracks'].include?(trackReference)
				@library['playlists'][playlistName]['tracks'] ||= []
				@library['playlists'][playlistName]['tracks'] << trackReference
				puts "Saved '#{track['title']}' (#{trackReference}) to playlist '#{playlistName}'"
			else
				puts "Track '#{track['title']}' (#{trackReference}) is already in playlist '#{playlistName}'"
			end
		end

		##
		# YouTube Methods
		##

		def looksLikeAYouTubeID? string
			youtubeIdPattern = /^[A-Za-z0-9_-]{11}$/
			!! string.match(youtubeIdPattern)
		end

		def getYoutubeIdFromUrl url
			youtubeIDInURLPattern = /^.*youtu(\.be\/|be\.com.*v=)([^&\/]+)/
			matches = url.match(youtubeIDInURLPattern)
			matches ? matches[2] : false
		end

		def searchYouTube query, offset = 0, count = 20
			# FIXME: sometimes the STDIN is not editable after this
			puts "Searching YouTube for '#{query}'"
			resultsPerPage = 20
			page = (offset.to_f / resultsPerPage.to_f).to_i + 1
			queryParameter = URI::encode(query)
			queryUrl="https://www.youtube.com/results?search_query=#{queryParameter}&page=#{page}"
			getYouTubeTracksFromPage queryUrl
		end

		def getValidYouTubeURI uri
			looksLikeAYouTubeID?(uri) ? "https://www.youtube.com/watch?v=#{uri}" : uri
		end

		def getYouTubeTracksFromPage url
			if @noNetwork
				puts "no getYouTubeTracksFromPage --no-network"
				return false
			end
			url = getValidYouTubeURI url
			queryResultIds = []
			whisper "reading URL #{url}", 2
			open(url) do |handle|
				whisper "received URL #{url}", 4
				html = []
				handle.each_line { |line| html << line }

				queryResultIds = html.grep(/href="(.*youtube.*)?\/watch/).map! do |line|
					line.sub!(/^.*watch\?v=([^\"&<]+).*\n/, '\1')
				end

				queryResultIds.uniq!
			end

			threads = []
			resultTracks = []
			receivedCount = 0
			printRepeat "Getting track information (#{receivedCount}/#{queryResultIds.length})"

			queryResultIds.each_with_index do |id, index|
				track = matchExistingLibraryTrack createTrack(id, 'youtube')
				resultTracks << track
				whisper "starting a new thread to get track info for #{track['id']}", 4
				threads << Thread.new {
					if not updateTrackInfo track
						resultTracks.delete track
					end
					receivedCount += 1
					printRepeat "Getting track information (#{receivedCount}/#{queryResultIds.length})"
				}
			end

			whisper "joining 'update info' threads", 4
			threads.each { |thread| thread.join }
			print "\n"

			resultTracks
		end

		def getSoundcloudRecommendations url
			if @noNetwork
				puts "no getSoundcloudRecommendations --no-network"
				return false
			end
			url = "#{url}/recommended"
			queryResultURLs = []
			open(url) do |handle|
				html = []
				handle.each_line { |line| html << line }

				queryResultURLs = html.grep(/<h2.*itemprop="url"/).map! do |line|
          line.sub!(/^.*<h2.*itemprop="url".*href="([^\"]+)".*\n/, 'https://soundcloud.com\1')
				end

				queryResultURLs.uniq!
			end

      # FIXME: seems to be skipping the first recommended track

			threads = []
			resultTracks = []
			receivedCount = 0
			printRepeat "Getting track information (#{receivedCount}/#{queryResultURLs.length})"

			queryResultURLs.each_with_index do |recommendedURL, index|
				track = matchExistingLibraryTrack createTrack(recommendedURL, 'soundcloud')
				resultTracks << track
				whisper "starting a new thread to get track info for #{track['src']}", 4
				threads << Thread.new {
					if not updateTrackInfo track
						resultTracks.delete track
					end
					receivedCount += 1
					printRepeat "Getting track information (#{receivedCount}/#{queryResultURLs.length})"
				}
			end

			whisper "joining 'update info' threads", 4
			threads.each { |thread| thread.join }
			print "\n"

			resultTracks
		end

		def getOCRemixSource(url)
			source = nil
			if @noNetwork
				puts "no getOCRemixSource --no-network"
				return false
			end

			open(url) do |handle|
				sourcePattern = /^.*href="(https?:\/\/ocrmirror.org[^"]+)".*$/
				sourceLine = handle.lines.grep(sourcePattern)
				if sourceLine && sourceLine.length > 0
					match = sourceLine[0].match sourcePattern
					source = match[1]
					whisper "source: #{source}", 4
				end
			end

			source
		end

		def getIDFromOCRemixURL(url)
			url.sub(/^.*\/remix\/([^\/?]+).*/, '\1')
		end

		##
		# Utility Methods
		##

		def getDurationStringFromSeconds inputSeconds
			inputSeconds = inputSeconds.to_i
			seconds = inputSeconds % 60
			minutes = inputSeconds / 60 % 60
			hours = inputSeconds / 3600 % 24
			days = inputSeconds / 86400

			outputString = ''
			outputString += "#{days}" if days > 0
			outputString += ":#{hours < 10 ? "0#{hours}" : hours}" if hours > 0
			outputString += ":#{minutes < 10 ? "0#{minutes}" : minutes}"
			outputString += ":#{seconds < 10 ? "0#{seconds}" : seconds}"
			outputString.sub(/^:/, '')
		end

		def getSecondsFromDurationString durationString
			seconds = 0
			factor = 1
			factors = [1,60,60,24]

			timecodeRegExpPattern = /^[0-9:.]+$/
			if durationString && durationString.length > 0 && durationString.match(timecodeRegExpPattern)
				durationString.split(':').reverse.each_with_index { |unit, index|
					factor *= factors[index]
					seconds += unit.to_f * factor
				}
			else
				seconds = nil
			end

			seconds
		end

		##
		# UI Methods
		##

		def parseOptions
			output = {}

			parser = OptionParser.new

			parser.on("-a", "--add-track YOUTUBE_URLS", "Add tracks to the library, and to a playlist, if specified. Takes a comma-separated list of YouTube URLs or IDs.", " ") do |urls|
				output[:newTracks] = getTracksFromURLs urls.split(',')
			end

			parser.on("-d", "--download", "Enable downloading files when encountering a file that is not already download.", " ") do |keep|
				@enableDownload = true
			end

			parser.on("-f", "--filter RULES", Player::FILTER_HELP_1, Player::FILTER_HELP_2, Player::FILTER_HELP_3, " ") do |rules|
				@trackFilters = parseOptionParameters rules
			end

			parser.on("-h", "--help", "Show this help.", " ") do
				puts parser.help()
				exit
			end

			parser.on("-l", "--loop", "Loop, even if a track doesn't have an A/B loop defined.", " ") do
				@loop = true
			end

			parser.on("-p", "--playlist [NAME]", "Choose or create a playlist. If no NAME/QUERY is given, a name is guessed from other input, such as a -q query", " ") do |playlistQuery|
				output[:playlistQuery] = playlistQuery
			end

			parser.on("-q", "--query QUERY", "Search YouTube for a video.", " ") do |query|
				@youtubeSearch = query
			end

			parser.on("-r", "--rating-prompt [SECONDS]", "Prompt for a rating and tags after every track plays, waiting 5 (or the number given) seconds before continuing to the next track", " ") do |seconds|
				@ratingsPromptDuration = seconds ? seconds.to_i : 5
			end

			parser.on("-s", "--shuffle", "Enable shuffle.", " ") do
				@shuffle = true
			end

			parser.on("-t", "--track INDEX/QUERY", "Seek to the given track (either by its number in the list, or by its name).", " ") do |trackQuery|
				if trackQuery.to_i != 0
					@trackIndex = trackQuery.to_i - 1
				else
					@trackIndex = findTrackIndex(trackQuery) || nil
					puts "@trackIndex: #{@trackIndex}" # XXX
				end
			end

			parser.on("-v [LEVEL]", "--verbose", "Chatter about what's going on (more detailed or frequent messages are in levels 2 or 3.", " ") do |level|
				@configuredVerbosity = level ? level.to_i : 1
				whisper "Verbosity level: #{@configuredVerbosity}", 1
			end

			parser.on("-w", "--write [SECONDS]", "Save changes to the library. If SECONDS are given, only tracks played that many seconds will be written.", " ") do |seconds|
				@writeEnabled = true
				@writeAfterSecondsPlayed = seconds ? seconds.to_f : 0.0
			end

			parser.on("-x", "--exclude-filter RULES", "Excludes tracks matching the rules. See --filter", " ") do |rules|
				@trackExcludeFilters = parseOptionParameters rules
			end

			parser.on("-m MODE", "--mode MODE", "Choose a player mode: #{Player::MODES.keys.join ', '}", " ") do |modeName|
				if Player::MODES.has_key? modeName
					@userMode = modeName
				else
					putsRealtime "#{modeName} is not a valid player mode. Please use one of #{Player::MODES.keys.join ', '}"
				end
			end

			parser.on("--input-dir DIR", "Directory from which to read the playlist and files.", "NOTE: when used, this must be the first option. Recommended to define TUNEWICH_DIR instead.", " ") do |inputDir|
				# FIXME: always process this option first, even if it's provided last
				setLibraryPath inputDir
			end

			parser.on("--no-network", "Don't fetch any information or media from the internet. Use only local files.", " ") do
				@noNetwork = true
				@trackFilters ||= {}
				@trackFilters['local'] = ''
			end

			parser.on("--format FORMAT", "Set the file format to request for streaming or downloading.", " ") do |format|
				@preferredFileFormat = format
			end

			parser.on("--update-track-info", "Fetch updated track information for every track played.", " ") do
				@updateAllPlayedTrackInfo = true
			end

			parser.on("--player-opts OPTIONS", "Set player options. Set interactively with the /player command.", " ") do |options|
				# TODO: ruby probably has an easier way of getting an element index in an Array#map block
				isFirstElement = true
				@playerOverrideCommands += options.split(' -').map { |option|
					if isFirstElement
						isFirstElement = false
					else
						option = "-#{option}"
					end
					option
				}
			end

			parser.on("--radio [SERVER_TYPE]", "TODO: stream to a network radio service (SERVER_TYPE: default 'homebrew' or 'Nicecast'", " ") do |streamingServerType = 'homebrew'|
        if !streamingServerType || streamingServerType.length == 0
          streamingServerType = 'homebrew'
        end
				@streamingServerType = streamingServerType
        whisper "streamingServerType: #{streamingServerType}", 2
				serviceConfigDir = "#{$tunewichWorkingDirectory}/config"
				isRadioConfigured = true
        whisper "Preparing to start radio (#{streamingServerType}).", 0
        if streamingServerType == 'homebrew'
          puts "About to prompt you for your password, so that the darkice server can be run as root."
          `sudo ls &>/dev/null`
        end
				if UNAME == "Darwin"
					audioDeviceID = `say -a ? | grep 'Soundflower (2ch)'`.chomp.sub /^\s*(\d+).*/, '\1'
          if audioDeviceID && audioDeviceID.length > 0
            @playerOverrideCommands << "-ao coreaudio:device_id=#{audioDeviceID}"
            jackAudioDeviceAndOptions = "coreaudio -d SoundflowerEngine:0"
          else
            puts "Please install Soundflower (https://github.com/mattingalls/Soundflower)"
            isRadioConfigured = false
          end
				else
          whisper "Playing to jack server", 2
					@playerOverrideCommands << "-ao alsa"
          jackAudioDeviceAndOptions = "alsa"
				end

        if isRadioConfigured
					bind 'play_start', Proc.new {
						updateRadioMetadata @currentTrack['title']
					}
					bind 'chapter_change', Proc.new {
						updateRadioMetadata "#{@currentTrack['title']} (#{@currentTrack['chapters'][@currentChapterIndex]['name']})"
					}
          if streamingServerType == 'homebrew'
            icecastConfigFile = "#{serviceConfigDir}/icecast.xml"
            darkiceConfigFile = "#{serviceConfigDir}/darkice.cfg"

            if not File.exist? icecastConfigFile
              puts "Please create the icecast config file at #{icecastConfigFile}."
              isRadioConfigured = false
            elsif not File.exist? darkiceConfigFile
              puts "Please create the darkice config file at #{darkiceConfigFile}."
              isRadioConfigured = false
            end
          else
            whisper "Radio is configured. Ready to play.", 2
          end
        else
          whisper "Radio is NOT configured. Ready to play.", 2
        end

				# Currently 2 methods of doing radio:
				# Both have the same first step, using Soundflower.
				# a) Rogue Amoeba's Nicecast (functionaly, not free)
				#		1) mplayer plays to "Soundflower (2ch)" audio device
				#		2) Nicecast captures "Soundflower (2ch)" and streams with its built-in icecast server
				#			i) The capture is probably what's being paid for here, since their other capture tools are also paid.
				# b) jack + darkice + icecast (not currently working)
				#		1) mplayer plays to "Soundflower (2ch)" audio device
				#		2) jackd captures audio from "Soundflower (2ch)" (getting errors)
				# 	3) darkice pushes the jackd audio to the icecast2 server (might be working)
				# 	4) listeners stream music from the icecast2 server (seems to be working)
				#
				# This article from 2012 has some good info, but it may be outdated.
				# http://dzello.com/blog/2012/11/21/live-stream-audio-from-osx-mountain-lion-with-icecast-and-darkice/

				if isRadioConfigured
          if UNAME == 'Darwin'
            puts "#" * 40
            puts "## Open Soundflowerbed and make sure that the volume is all the way up on Soundflower (2ch)."
            puts "## If you mute your system audio, \"Soundflower (2ch)\" may also be muted, so take care not to do that. Open up Soundflowerbed \"Audio Setup\" and unmute \"Soundflower (2ch)\" if that happens."
            puts "#" * 40
          end
					if streamingServerType == 'homebrew'
						@services = []
						whisper "starting jackd (to capture audio)", 2
						@services << Thread.new { `sudo jackd -d #{jackAudioDeviceAndOptions}` }
						whisper "starting icecast (to stream audio to listeners)", 2
            if UNAME == 'Darwin'
              @services << Thread.new { `icecast -c "#{icecastConfigFile}"` }
            else
              @services << Thread.new { `icecast2 -c "#{icecastConfigFile}"` }
            end
						darkiceStartDelay = 5.0
						whisper "waiting #{darkiceStartDelay} seconds to start darkice", 2
						sleep darkiceStartDelay
						whisper "starting darkice (to encode and push audio to streaming server)", 2
						@services << Thread.new { `sudo darkice -v 10 -c "#{darkiceConfigFile}"` }
          else
            whisper "continue to Nicecast server", 2
					end
        else
          puts "Unable to configure radio server."
				end
			end

			unparsedOptions = parser.parse(ARGV)
			whisper "unparsed options: #{unparsedOptions}", 4

			output
		end

		def doOptionSecondaryActions optionsOutput

			if not @fileDirectory
				puts "please specify an input directory with -i"
				exit
			end

			if @youtubeSearch && !@noNetwork
				@youtubeSearchPage = 1
				searchedTracks = searchYouTube @youtubeSearch
				useTracks searchedTracks if searchedTracks
			end

			if optionsOutput.has_key? :playlistQuery
				if optionsOutput[:playlistQuery]
					match = firstFuzzyMatch optionsOutput[:playlistQuery], @library['playlists'].keys

					if match && match[:score] > 1 # FIXME: what's a good baseline score for a playlist match?
						playlistName = match[:value]
					elsif confirm("Create new playlist #{optionsOutput[:playlistQuery]}?")
						playlistName = optionsOutput[:playlistQuery]
					end
				elsif @youtubeSearch
					playlistName = @youtubeSearch
				end

				if playlistName
					if not @library['playlists'].has_key? playlistName
						puts "Creating new playlist: #{playlistName}"
						createPlaylist playlistName
						writeLibraryToFile
					end

					usePlaylist playlistName, true
				end
			end

			if optionsOutput.has_key? :newTracks
				optionsOutput[:newTracks].each { |newTrack|
					if 0 == @writeAfterSecondsPlayed
						trackReference = addTrackToLibrary newTrack
						addTrackReferenceToPlaylist trackReference, @playlistName if @playlistName
					end
					@tracks << newTrack
				}
				writeLibraryToFile true
			end
		end

		def getTracksFromURLs(urls)
			tracks = []

			def getHTTPHeaderByPattern(head, pattern)
				value = nil
				if head
					matchingLines = head.lines.keep_if { |line| line.match(pattern) }
					if matchingLines && matchingLines.length > 0
						value = matchingLines.last.chomp.sub pattern, '\1'
					end
				end
				value
			end

			urls.each { |url|
				urlCanBeScraped = true # assuming this for now
				if url.match(/ocremix\.org\/remix/)
					tracks << matchExistingLibraryTrack(createTrack(url, 'ocremix'))
					puts "This URL contains an OC Remix ID. Adding."
				elsif looksLikeAYouTubeID? url
					youtubeId = url
				else
					youtubeId = getYoutubeIdFromUrl url
				end

				if youtubeId
					tracks << updateTrackInfo(matchExistingLibraryTrack(createTrack(youtubeId, 'youtube')))
					puts "This URL contains a YouTube ID. Adding."
				else
          urlHTTPHead = `curl -sL --head "#{url}"`
					urlContentType = getHTTPHeaderByPattern urlHTTPHead, /^Content-Type: ([^;]*).*/i
					cookieDomain = getHTTPHeaderByPattern urlHTTPHead, /^Set-Cookie:.*domain=([^;]*).*/i
					whisper "urlContentType: #{urlContentType}, cookieDomain: #{cookieDomain}", 3
					if 'text/html' == urlContentType && (cookieDomain == '.bandcamp.com' || url.match(/(https?:\/\/)([^\.]+)\.bandcamp\.com.*/))
            whisper "WIP: scraping bandcamp page"
						urlCanBeScraped = false
						bandcampTracks = loadBandcamp url
						tracks += bandcampTracks if bandcampTracks
					elsif 'text/html' == urlContentType && cookieDomain == '.soundcloud.com'
            whisper "WIP: getting soundcloud track"
						urlCanBeScraped = false
						soundcloudTracks = loadSoundcloud url
						tracks += soundcloudTracks if soundcloudTracks
					elsif urlContentType && ['text/xml', 'application/rss+xml'].include?(urlContentType) # TODO: application/rss+xml, application/rdf+xml;q=0.8, application/atom+xml;q=0.6, application/xml;q=0.4, text/xml;q=0.4
            whisper "WIP: try to load podcast feed"
						urlCanBeScraped = false
						podcastTracks = loadPodcast url
						tracks += podcastTracks if podcastTracks
					else
						urlCanBeScraped = false
						whisper "assuming that URL is an audio file. Adding as a track", 3
						track = createTrack(url, urlContentType)
						whisper "track: #{track}", 3
						track = matchExistingLibraryTrack(track)
						whisper "track (after matching existing): #{track}", 3
						tracks << track
						whisper "added: #{tracks.last}", 3
					end
				end

				if urlCanBeScraped && confirm("Look for all tracks on this page?")
					youTubeTracks = getYouTubeTracksFromPage url
					tracks.concat youTubeTracks if youTubeTracks
				end
			}

			tracks
		end

		def loadPodcast url
			feedAlreadyInLibrary = false
			@library['feeds'] ||= []
			@library['feeds'].each { |feed|
				if feed['src'] == url
					feedAlreadyInLibrary = true
					podcastFeed = feed 
					break
				end
			}
			feedXML = `curl -sL "#{url}"`
			feedDoc = REXML::Document.new(feedXML)
			if not feedDoc
				whisper "bad feed XML", 3
				whisper feedXML, 4
				return nil
			end
			channel = REXML::XPath.first(feedDoc, '//rss/channel')
			if not feedAlreadyInLibrary
				podcastFeed = {
					'title' => REXML::XPath.first(channel, 'title').text,
					'description' => REXML::XPath.first(channel, 'description').text,
					'src' => url,
					'type' => 'podcast',
					'dateAdded' => Time.now.to_i
				}
			end
			podcastTracks = []
			REXML::XPath.each(channel, 'item') { |itemElement|
				whisper "itemElement: #{itemElement}", 4
				enclosure = REXML::XPath.first(itemElement, 'enclosure')
				if enclosure
					newTrack = createTrack(enclosure.attribute('url').to_s.gsub('&amp;', '&'), enclosure.attribute('type').to_s || 'audio/mpeg')
					newTrack['title'] = REXML::XPath.first(itemElement, 'title').text.chomp
					descriptionElement = REXML::XPath.first(itemElement, 'itunes:summary') || REXML::XPath.first(itemElement, 'description')
					newTrack['description'] = descriptionElement.text.chomp
					durationElement = REXML::XPath.first(itemElement, 'itunes:duration')
					newTrack['duration'] = durationElement.text.chomp if durationElement
					linkElement = REXML::XPath.first(itemElement, 'link')
					newTrack['link'] = linkElement.text.chomp if linkElement
					whisper "newTrack: #{newTrack}", 4
					podcastTracks << newTrack
				else
					whisper "This RSS item does not have an enclosure, i.e. no link to the audio", 3
				end
			}
			if not feedAlreadyInLibrary
				@library['feeds'] << podcastFeed
				writeLibraryToFile
			end
			podcastTracks.reverse # put the oldest ones first
		end

		def loadBandcamp url
			whisper "loadBandcamp #{url}", 3
			tracks = []
			open(url) do |handle|
				handle.each_line { |line|
					matchResults = line.match /^\s*trackinfo: (.*?),?$/
					if matchResults
						whisper "loadBandcamp: found trackinfo: #{matchResults[1]}", 3
						trackinfo = JSON.parse matchResults[1]
						if trackinfo
							whisper "loadBandcamp: trackinfo is valid JSON", 3
							trackinfo.each { |bandcampTrack|
								if bandcampTrack.has_key?('file') && bandcampTrack['file'].has_key?('mp3-128')
									whisper "loadBandcamp: found track file #{bandcampTrack['file']['mp3-128']}", 3
									fileURL = bandcampTrack['file']['mp3-128']
									fileURL = "http:#{fileURL}" if fileURL.match(/^\/\//)
									track = createTrack(fileURL, 'audio/mpeg')
									track['title'] = bandcampTrack['title'] if bandcampTrack.has_key?('title')
									if bandcampTrack.has_key?('title_link')
										urlDomain = url.sub(/((^(https?:)?\/\/)?[^\/]+).*/, '\1')
										track['link'] = "#{urlDomain}#{bandcampTrack['title_link']}"
									end
									tracks << track
								end
							}
						end
					end
				}
			end
			tracks
		end

		def loadSoundcloud url
			whisper "loadSoundcloud #{url}", 3
			tracks = [createTrack(url, 'soundcloud')]
      whisper "tracks: #{tracks}", 3 # XXX
			tracks
		end

		def encodeOptionParameters hash
			clumps = []
			hash.each { |key, value|
				clumps << "#{key}=#{value}"
			}
			clumps.join ','
		end

		def parseOptionParameters serialized
			hash = {}
			# TODO: parse normal & negated options from one list
			# hash = {
			# 	:normal => [],
			# 	:negate => []
			# }

			serialized.split(',').each { |clump|
				pair = clump.split '='
				hash[pair[0]] = pair[1]
			}

			hash
		end

		def printRepeat message, shouldReturnCursorToBeginning = false
			message = message.to_s if message.respond_to? 'to_s'
			outputMessage = "  #{message}"
			print "\r#{$clearLineCharacter}#{$disableWrapCharacter}#{outputMessage}#{$enableWrapCharacter}"
			print "\r" if shouldReturnCursorToBeginning
		end

		def cliRotate
			if not @cliRotateIndex
				@cliRotateIndex = 0
				@cliRotateCharacters = ['==', '\\\\', '||', '//']
			else
				@cliRotateIndex = (@cliRotateIndex + 1) % @cliRotateCharacters.length
			end

			@cliRotateCharacters[@cliRotateIndex]
		end

		def editListInVim list, instructions = nil
			scopedShouldShowRealtimeOutput = @shouldShowPlaybackInfo
			@shouldShowPlaybackInfo = false
			instructions ||= "edit"
			fileDirections = "##\n#{instructions.gsub(/^/, '# ')}\n##"

			editListName = 'edit-list'
			deleteTempFile editListName
			putInTempFile editListName, list.join("\n") + "\n\n" + fileDirections

			system "vim #{getTempFilePath editListName}"

			list = readTempFile(editListName).strip.lines
			list.map! { |line|
				line.sub(/\n/, '')
			}
			list.delete_if { |line| # remove empty and comment lines from the list
				line.match(/^(#.*|\s*)$/)
			}

			deleteTempFile editListName

			whisper list, 4

			@shouldShowPlaybackInfo = scopedShouldShowRealtimeOutput

			list
		end

		def editHashInVim map, instructions = nil
			editableList = map.map { |name, value|
				"#{name}: #{value}"
			}
			editedOutput = editListInVim editableList, instructions
			outputHash = {}
			editedOutput.each { |line|
				parts = line.match(/^([^:]+): (.*)/)
				whisper "edited map line: name='#{parts[1]}',  value='#{parts[2]}'", 3
				outputHash[parts[1]] = parts[2]
			}
			outputHash
		end

		def editTrackList tracks
			editedList = editListInVim(listTrackTitles(tracks), "remove or comment with # any tracks you want to deselect")
			getTracksFromTitleList editedList, tracks
		end

		def commandPrompt message = nil, commands = nil, action = nil
			shouldBreakCommandLoop = false
			bindOnce 'request_exit', Proc.new {
				shouldBreakCommandLoop = true
			}
			whisper "opening command prompt", 3
			if commands
				commands['?'] = {
					'description' => 'Show interactive command info (like this). Not chainable.',
					'action' => Proc.new {
						commandInfo = []
						maxCommandNameLength = 0
						sortedCommandList = []
						whisper "gathering command info", 3
						commands.each { |name, command|
							sortedCommandList << {:name => name, :command => command}
							maxCommandNameLength = name.length if name.length > maxCommandNameLength
						}
						sortedCommandList.sort! { |a,b| a[:name] <=> b[:name] }
						sortedCommandList.each { |commandMeta|
							info = "/#{commandMeta[:name]}"
							info += " " * (maxCommandNameLength - info.length + 1)
							info += " : #{commandMeta[:command]['description']}" if commandMeta[:command]['description']
							commandInfo << info
						}
						putsRealtime commandInfo.join "\n"

						nil
					}
				}
			end

			prompt = Proc.new {
				print "#{message} " if message
				print "$ "
			}
			prompt.call

			response = {
				:input => nil,
				:commands => []
			}

			whisper "waiting for user input on STDIN", 3
			input = nil
			commandHistoryIndex = nil
			while inputCharacter = readCharacter
				if inputCharacter == "" # control-c character
					whisper "interrupt character, is that you?", 3
					@shouldShowPlaybackInfo = true
					break
				elsif inputCharacter == "" # backspace
					if input
						input = input[0,input.length - 1]
						if input.length > 0
							printRepeat input
						else
							input = nil
							@shouldShowPlaybackInfo = true;
						end
					end
				elsif inputCharacter == "" # stop job
					Process.kill("STOP", Process.pid)
					# TODO: also stop mplayer
				elsif inputCharacter == "" # clear line
					if input
						@commandInputTyped = nil
						input = ''
						printRepeat input
					end
					@commandInputTyped = nil
				elsif /[\n\r]/.match inputCharacter
					@commandHistory.unshift input
					@shouldShowPlaybackInfo = true
					response[:input] = input
					whisper "received input: #{input}", 3
					if commands
						processCommandsWithInput = Proc.new { |commandLoopInput|
							while commandLoopInput && !commandLoopInput.empty? && commandLoopInput[0] == '/'
								whisper "parsing commands", 3
								commandParts = commandLoopInput.match(/^\/([^\s]*)\s*(.*)/)
								if commandParts
									commandName = commandParts[1]
									commandInput = commandParts[2]

									if !commands.has_key? commandName
										possibleCommands = []
										commands.each { |name, command|
											if name.start_with? commandName
												possibleCommands << name
											end
										}
										if possibleCommands.length == 1
											whisper "matched #{commandName} -> #{possibleCommands[0]}", 1
											commandName = possibleCommands[0]
										else
											commandName = ''
											commandLoopInput = nil
											putsRealtime "Did you mean #{possibleCommands.join ", or "}?" if possibleCommands.length > 1
										end
									end
								else
									commandName = ''
								end

								if commands.has_key? commandName
									commandInfo = {
										:name => commandName,
										:commandLoopInput => commandInput,
										:output => nil
									}
									begin
										commandInfo[:output] = commands[commandName]['action'].call(commandInput)
									rescue Exception => e
										putsRealtime "There was a problem running '#{commandName}' with input '#{commandInput}'"
										whisper "Exception: #{e.message}\nbacktrace: #{e.backtrace.join "\n"}", 3
									end
									response[:commands] << commandInfo
									whisper "command info: #{commandInfo}", 3
									if commandInfo[:output] && commandInfo[:output][:action]
										whisper "chained command calling action (#{commandInfo[:output][:action]})", 3
										actionResponse = action.call commandInfo[:output][:action]
									end
									if commandInfo[:output] && commandInfo[:output][:chainedInput] && commandInfo[:output][:chainedInput].length > 0
										whisper "chained commandLoopInput: #{commandInfo[:output][:chainedInput]}", 3
										if commandInfo[:output][:bindChainToEvent]
											commandLoopInput = nil
											whisper "binding deferred chained commands to event '#{commandInfo[:output][:bindChainToEvent]}'", 3
											bindOnce commandInfo[:output][:bindChainToEvent], Proc.new {
												whisper "running deferred chained commands", 1
												whisper "deferred commands: #{commandInfo[:output][:chainedInput]}", 2
												commandLoopInput = processCommandsWithInput.call commandInfo[:output][:chainedInput]
											}, commandInfo[:output][:bindingGroupName]
											break
										else
											commandLoopInput = commandInfo[:output][:chainedInput]
										end
									else
										whisper "no chained commandLoopInput", 3
										commandLoopInput = nil
										break
									end
								end

								break if shouldBreakCommandLoop
							end

							whisper "no more commands to execute (for now)", 3

							commandLoopInput
						}
						input = processCommandsWithInput.call input
					end

					if action && input && input.length > 0
						whisper "input left over after commands: passing to action (#{input})", 3
						actionResponse = action.call input
					end

					input = nil

					if actionResponse == false
						whisper "action returned false: breaking command loop", 3
						break
					end

					prompt.call
				else
					if not input
						input = ''
						@shouldShowPlaybackInfo = false
					end

					if inputCharacter == "\e[A" # up arrow
						if @commandInputTyped
							matchingCommands = @commandHistory.select { |command|
								command.start_with? @commandInputTyped
							}
							if matchingCommands && matchingCommands.length > 0
								input = matchingCommands.last
							end
						else
							commandHistoryIndex = (commandHistoryIndex ? commandHistoryIndex + 1 : 0) % @commandHistory.length
							input = @commandHistory[commandHistoryIndex]
						end

						printRepeat input
					elsif inputCharacter == "\e[B" # down arrow
						if @commandInputTyped
							matchingCommands = @commandHistory.select { |command|
								command.start_with? @commandInputTyped
							}
							if matchingCommands && matchingCommands.length > 0
								input = matchingCommands.first
							end
						else
							commandHistoryIndex = (commandHistoryIndex ? commandHistoryIndex - 1 : 0) % @commandHistory.length
							input = @commandHistory[commandHistoryIndex]
						end

						printRepeat input
					elsif inputCharacter == "\e[C" # right arrow
						whisper "TODO: move cursor right", 3
					elsif inputCharacter == "\e[D" # left arrow
						whisper "TODO: move cursor left", 3
					else
						input += inputCharacter
						@commandInputTyped = input
					end

					printRepeat input
				end

				break if shouldBreakCommandLoop
			end

			whisper "closing command \"#{message}\" prompt (response #{response})", 3

			response
		end

		def confirm message, commands = nil
			confirmMessage = "#{message} (y/N): "
			confirmed = false
			confirmAction = Proc.new { |input|
				confirmed = input.match(/^[Yy]/)
				!input
			}
			scopedShouldShowRealtimeOutput = @shouldShowPlaybackInfo
			@shouldShowPlaybackInfo = false
			commandResponse = commandPrompt(confirmMessage, commands, confirmAction)
			@shouldShowPlaybackInfo = scopedShouldShowRealtimeOutput
			confirmed
		end

		def promptForPlaylist
			puts "Please choose a playlist (leave blank to play all):\n  #{@library['playlists'].keys.join "\n  "}"
			selectedListName = nil
			while !selectedListName do
				playlistQuery = commandPrompt[:input]

				if not playlistQuery or playlistQuery.length === 0
					useEntireLibrary
					break
				end

				selectedListName = findPlaylistName playlistQuery

				if not selectedListName
					puts "No matches. Try again"
				end

			end

			selectedListName
		end

		def promptForChapterIndex chapters, commands = nil, message = nil
			whisper "prompting for chapter selection", 3
			selectedChapterIndex = nil

			chapterList = chapters.map { |chapter| "#{chapter['time']} - #{chapter['name']}" }
			prePromptMessage = "  #{chapterList.join "\n  "}"
			prePromptMessage += "\n#{message}" if message
			promptMessage = "Please choose a chapter (leave blank to play first):"

			while not selectedChapterIndex do
				puts prePromptMessage
				emptyAction = Proc.new { |input| false }
				chapterQuery = commandPrompt(promptMessage, commands, emptyAction)[:input]
				break if not chapterQuery or chapterQuery.length === 0

				selectedChapterIndex = firstFuzzyMatchIndex chapterQuery, chapterList

				if selectedChapterIndex
					break
				else
					puts "No matches. Try again."
				end

			end

			whisper "Selected chapter #{selectedChapterIndex}", 4

			{
				:index => selectedChapterIndex
			}
		end

		def listTrackTitles(tracks)
			tracks.map { |t| "#{t['title']} [#{t['type']}::#{t['src']}]" }
		end

		def getTracksFromTitleList(titleList, referenceTracks = nil)
			referenceTracks ||= @library['tracks'].values
			tracks = []
			titleList.each { |line|
				matches = line.match(/^(.*) \[(.*)::(.*)\]$/)
				if matches
					trackType = matches[2]
					trackSource = matches[3]
					track = nil
					referenceTracks.each { |referenceTrack|
						if referenceTrack['src'] == trackSource
							track = referenceTrack
							break
						end
					}
					track = createTrack(trackSource, trackType) if not track
					tracks << track if track
				end
			}

			tracks
		end

		def cloneTracks inputTracks
			tracks = []
			inputTracks.each { |id, t| tracks <<  t }
			tracks
		end

		def cloneLibraryToTracks inputLibrary
			tracks = []
			inputLibrary.each { |id, t| tracks << t }
			tracks
		end

		def cloneLibrary inputLibrary
			library = {}
			inputLibrary.each { |id, t| library[t['id']] = t }
			library
		end

		def cloneTracksToLibrary inputTracks
			library = {}
			inputTracks.each { |t| library[t['id']] = t }
			library
		end

	end

end

Tunewich::Player.new
