#!/usr/bin/env ruby

require "io/console" # STDIN.getch
require "open-uri" # URI
require "optparse" # OptionParser
require "json" # JSON
require "digest" # Digest

$clearLineCharacter = "\033[0K"

module Tunewich

	class UI

	end

	class Library

	end

	class Playlist

	end

	class YouTubeClient

	end

	class Player

		PROMPT_TIMEOUT_RESPONSE = 'prompt_timeout_response'
		FILTER_HELP_1 = "Filter tracks by rules, in the format 'key=value,key=value 2,key'."
		FILTER_HELP_2 = "Available rules are: [min-,max-]rating=<#0-5>,title=<query>,tag=<tag>,chapters,last=<[[[DD:]HH:]MM:]SS>,ab."
		FILTER_HELP_3 = "Prepend an '-' to your rule to add it to exclude matches (e.g. '-tag=' vs 'tag=')."
		TAG_INPUT_SPLIT = /[,\s]+/
		PLAYER_APPLICATION = 'mplayer'
		MPLAYER_STDOUT_BUFFER_NAME = 'mplayer-stdout'
		MPLAYER_INPUT_FIFO_NAME = 'mplayer-input'
		UNAME = `uname`.chomp

		def initialize
			@library = nil
			@libraryHash = nil
			@sessionID = Random.rand(1024)
			@currentTrack = nil
			@trackIndex = nil
			@tracks = []
			@configuredVerbosity = 0
			@shouldShowRealtimeOutput = true
			@trackFilters = nil
			@trackExcludeFilters = nil
			@noNetwork = false
			@playlistName = nil
			@volume = 25
			@currentVolume = 25
			@enableDownload = false
			@preferredFileFormat = 'bestaudio'
			@keepUnattachedDownload = false
			@playerTemporaryInteractiveCommands = []
			@playerOverrideCommands = []
			@currentPlayerIndex = 0
			@volumeBeforeFadingOut = 10 # FIXME: better initial default
			@speedBeforeRampingOut = 1
			@playerThreads = []
			@inputThread = nil
			@playerApplicationThreads = []
			@forceStreaming = false

			getEnvironmentConfig

			doOptionSecondaryActions parseOptions

			trackTitleListFromLastSession = readTempFile('tracks', false)
			if trackTitleListFromLastSession && trackTitleListFromLastSession.length > 0
				whisper "Using tracks from last session.", 1
				useTracks(getTracksFromTitleList(trackTitleListFromLastSession.strip.lines))
			end

			@volume = getMplayerConfigNumericProperty('volume')
			@currentVolume = @volume
			@speed = getMplayerConfigNumericProperty('speed', 1.0)
			@currentSpeed = @speed

			interactivePlayback
		end

		private

		def whisper message, verbosity = 1
			# 1: verbose user output
			# 2: very verbose user output
			# 3: errors
			# 4: debug
			puts "  #{"-" * verbosity} #{message}" if @configuredVerbosity >= verbosity
		end

		def getEnvironmentConfig
			if ENV.key? 'TUNEWICH_PLAYER_OPTS'
				@playerOverrideCommands << ENV['TUNEWICH_PLAYER_OPTS']
			else
				puts "You can add `export TUNEWICH_PLAYER_OPTS=\"<player options>\"` to your ~/.profile or similar file. Default player is #{Player::PLAYER_APPLICATION}."
			end

			if ENV.key? 'TUNEWICH_DIR'
				setLibraryPath ENV['TUNEWICH_DIR']
			else
				puts "Please add `export TUNEWICH_DIR=\"<path/to/your/music/directory>\"` to your ~/.profile or similar file."
			end

			# assume volume is not logarithmic for player on Mac
			@isVolumeAlreadyLogarithmic = !(UNAME == "Darwin")
		end

		def findBPMRatio firstTrack, secondTrack
			# TODO: optionally use common factors or time signatures to find other
			# good ratios
			ratio = 1
			if not firstTrack.has_key? 'bpm'
				whisper "The first track being compared doesn't have BPM set.", 2
			elsif secondTrack.has_key? 'bpm'
				whisper "The second track being compared doesn't have BPM set.", 2
			else
				ratio = secondTrack['bpm'].to_f / firstTrack['bpm'].to_f
				if ratio >= 2.0
					ratio /= 2.0
				elsif ratio <= 0.5
					ratio *= 2.0
				end
			end
			ratio
		end

		def interactivePlayback
			if @tracks && @tracks.length > 0
				titleBlock "Playing #{@tracks.length} tracks", '#'
			else
				useEntireLibrary
			end

			if @trackIndex == nil
				if @shuffle
					shuffleIndex()
				else
					@trackIndex = 0
				end
			elsif @trackIndex.is_a? String and @trackIndex != '0'
				@trackIndex = findTrackIndex @trackIndex
			else
				@trackIndex = @trackIndex.to_i
			end

			# TODO: catch SIGINT (ctrl+c) & prompt for playlist again
			playerOutput = nil
			commandRequiresBreak = false
			commandRequiresNext = false
			commandCustomPlayerConfig = ''
			commandRequiresExit = false

			interactiveCommands = {
				'' => {
					'description' => "Chainable player commands (empty command, i.e. '/').",
					'action' => Proc.new { |input, output|
						inputParts = input.match(/^([^\/]*)(.*)$/)
						output = {
							:chainedInput => inputParts[2]
						}
						if inputParts[1] && inputParts[1].length > 0
							whisper "Running player action (#{input})", 3
							output[:action] = inputParts[1]
						end

						output
					}
				},

				'rate' => {
					'description' => "Rate this track.",
					'action' => Proc.new { |input, output|
						chunks = input.split ' '
						newRating = chunks.shift if (chunks.length > 0) && (chunks[0].match /^[0-9]/)
						if !newRating || newRating.length < 1
							output.call "current rating: #{@currentTrack['rating']}"
						else
							@currentTrack['rating'] = newRating.to_i
							if !@currentTrack['unattached'] || @currentTrack['rating'] > 0
								loadLibrary
								addTrackToLibrary @currentTrack if @currentTrack['unattached']
								writeLibraryToFile true
							end
						end
						{:chainedInput => chunks.join(' ')}
					}
				},
				'bpm' => {
					'description' => "Interactively set the beats-per-minute of the track. Do '/bpm 0' to remove (not chainable)",
					'action' => Proc.new { |input, output|
						commitBPM = false

						if input.length > 0
							bpm = input.to_f
							commitBPM = true
						else
							firstTimeInSeconds = nil
							lastTimeInSeconds = nil
							iterations = 0;
							bpm = @currentTrack['bpm'];
							outputMessageLines = []
							outputMessageLines << "Current BPM is #{bpm}." if bpm
							outputMessageLines << "Hit enter on the beat. Type \"k\" to accept, or anything else to cancel setting the BPM."
							output.call outputMessageLines.join "\n"
							while true
								input = STDIN.gets.chomp
								if input.length > 0
									commitBPM = input == 'k'
									break
								end

								iterations += 1
								now = Time.now.to_f
								firstTimeInSeconds ||= now
								lastTimeInSeconds = now
								if lastTimeInSeconds != firstTimeInSeconds
									bpm = ((iterations - 1).to_f / (lastTimeInSeconds - firstTimeInSeconds) * 60.0).round(1);
									printRepeat "BPM: #{bpm} "
								end
							end
							print "\n"
						end

						if commitBPM
							loadLibrary
							if bpm == 0
								output.call "Removing BPM from track."
								@currentTrack.delete 'bpm' if @currentTrack.has_key? 'bpm'
							else
								output.call "Setting track BPM to #{bpm}."
								@currentTrack['bpm'] = bpm
							end
							writeLibraryToFile true
						else
							output.call "Canceling: leaving track BPM alone."
						end
						nil
					}
				},
				'tag' => {
					'description' => "Tag this track.",
					'action' => Proc.new { |input, output|
						inputParts = input.match(/^([^\/]*)(.*)$/)
						if !inputParts[1] || inputParts[1].length < 1
							output.call "current tags: #{getTrackTags @currentTrack}"
						else
							tagsToAdd = inputParts[1].split(/[, ]+/)
							whisper "all tags given: #{tagsToAdd}", 2
							tagsToRemove = []
							tagsToRemove.replace(tagsToAdd).keep_if {|name| name.match(/^-/)}
							tagsToRemove.map! {|name| name.sub(/^-/, '')}
							tagsToAdd.delete_if {|name| name.match(/^-/)}

							loadLibrary
							addTrackToTags @currentTrack, tagsToAdd
							removeTagsFromTrack @currentTrack, tagsToRemove
							addTrackToLibrary @currentTrack if @currentTrack['unattached']
							writeLibraryToFile true
						end
						{:chainedInput => inputParts[2]}
					}
				},
				'tagall' => {
					'description' => "Tag all tracks in the current tracklist.",
					'action' => Proc.new { |input, output|
						inputParts = input.match(/^([^\/]*)(.*)$/)
						if inputParts[1] && inputParts[1].length > 0
							tagsToAdd = inputParts[1].split(/[, ]+/)
							tagsToRemove = []
							tagsToAdd.each { |tagName|
								if /^-/.match tagName
									tagsToRemove << tagName.gsub(/^-/, '')
									tagsToAdd.delete tagName
								end
							}
							loadLibrary
							@tracks.each { |t|
								addTrackToTags t, tagsToAdd
								removeTagsFromTrack t, tagsToRemove
								addTrackToLibrary t if t['unattached']
							}
							writeLibraryToFile true
						end
						{:chainedInput => inputParts[2]}
					}
				},
				'go' => {
					'description' => "Go to a track in the current list.",
					'action' => Proc.new { |input, output|
						inputParts = input.match(/^([^\/]*)(.*)$/)
						trackIndex = inputParts[1]
						if trackIndex && trackIndex.length
							if trackIndex.to_i == 0
								@trackIndex = findTrackIndex trackIndex
							else
								@trackIndex = trackIndex.to_i - 1 % @tracks.length
							end
							commandRequiresNext = true
						end
						{:chainedInput => inputParts[2]}
					}
				},
				'clear' => {
					'description' => 'Clear current tracklist',
					'action' => Proc.new { |input, output|
						@useTracks []
						{:chainedInput => input}
					}
				},
				'all' => {
					'description' => "Load entire library.",
					'action' => Proc.new { |input, output|
						useEntireLibrary
						{:chainedInput => input}
					}
				},
				'fade' => {
					'description' => 'Fade volume (/fade VOLUME [DURATION])',
					'action' => Proc.new { |input, output|
						output = {}
						fadeCommandMatch = /^(out|in|[0-9.]+x?)( [0-9.]+)?( .+)?$/.match input
						if fadeCommandMatch
							whisper "fade command", 4
							duration = fadeCommandMatch[2] && fadeCommandMatch[2].length > 0 ? fadeCommandMatch[2].to_f : 2.0
							output[:chainedInput] = fadeCommandMatch[3] && fadeCommandMatch[3].length > 0 ? fadeCommandMatch[3].strip : nil
							targetFadeVolume = fadeCommandMatch[1]
							fadeVolume targetFadeVolume, duration, @currentPlayerIndex
						end
						output
					}
				},
				'ramp' => {
					'description' => 'Ramp speed (/ramp SPEED [DURATION])',
					'action' => Proc.new { |input, output|
						rampCommandMatch = /^(out|in|[0-9.]+(bpm)?)( [0-9.]+)?( .+)?$/.match input
						#                    1              2      3          4
						output = {}
						if rampCommandMatch
							duration = rampCommandMatch[3] && rampCommandMatch[3].length > 0 ? rampCommandMatch[3].to_f : 0.3
							output[:chainedInput] = rampCommandMatch[4] && rampCommandMatch[4].length > 0 ? rampCommandMatch[4].strip : nil
							whisper 'without -af scaletempo[=speed=tempo], min and max limited by the system (~1/8 and ~4.5 on my Mac Mini)', 1
							targetRampSpeed = determineRelativeSpeed rampCommandMatch[1], @currentTrack, true
							rampSuccess = rampSpeed targetRampSpeed, duration, @currentPlayerIndex
							if rampSuccess && output[:chainedInput] && output[:chainedInput].length > 0
								whisper "Waiting 1 second for buffered sound to play", 1
								sleep 1.0
							end
						end
						output
					}
				},
				'mark' => {
					'description' => 'Mark the point at which to play this track next time.',
					'action' => Proc.new { |input, output|
						loadLibrary
						@currentTrack['mark'] = getCurrentMplayerTimePosition
						writeLibraryToFile true
						{:chainedInput => input}
					}
				},
				'wait' => {
					'description' => 'Wait some number of seconds to execute following chained commands',
					'action' => Proc.new { |input, output|
						chunks = input.split ' '
						if chunks.length > 0 && chunks[0].match(/^[0-9.]+$/)
							sleep chunks.shift.to_f
						end
						{:chainedInput => chunks.join(' ')}
					}
				},
				'list' => {
					'description' => "Load a playlist. (not chainable)",
					'action' => Proc.new { |input, output|
						# TODO: generalized function to list playlists, their track count, and the average rating among rated tracks
						whisper "playlistQuery: #{input}", 4
						playlistNames = @library['playlists'].keys
						if input && input.length > 0
							match = firstFuzzyMatch input, playlistNames

							if match && match[:score] > 1 # FIXME: what's a good baseline score for a playlist match?
								playlistName = match[:value]
							end
						end

						if playlistName
							usePlaylist playlistName, true
						else
							output.call playlistNames.join "\n"
						end
						commandRequiresNext = true
						nil
					}
				},
				'edit' => {
					'description' => 'Edit playing tracklist in Vim.',
					'action' => Proc.new { |input, output|
						editedTracklisit = getTracksFromTitleList editListInVim(listTrackTitles(@tracks), "remove or comment with # any tracks you want to deselect")
						useTracks editedTracklisit, false
						output.call "#{@tracks.length} tracks selected"
						{:chainedInput => input}
					}
				},
				'turn' => {
					'description' => "Use all this track's tags to populate the track list.",
					'action' => Proc.new { |input, output|
						trackTags = getTrackTags @currentTrack
						if trackTags.length > 0
							output.call "Playing tracks with similar tags: #{trackTags.join ', '}"
							@trackFilters ||= {}
							@trackFilters['tag'] = "+#{trackTags.join ' +'}"
							useEntireLibrary
							@trackIndex = 1 # next track (current track will almost certainly be at index 0)
							if @shuffle
								@shuffle = false
								output.call "shuffle: off"
							end
							commandRequiresNext = true
						else
							output.call "Add some tags to this track to find similar tracks."
						end
						{:chainedInput => input}
					}
				},
				'more' => {
					'description' => "Play all tracks on this video's page.",
					'action' => Proc.new { |input, output|
						# FIXME: diagnose: I updated youtube-dl, and I still get errors all the time, and it'll quit afterward (2016 Feb 29 Mon 11:37:51)
						tracks = getYouTubeTracksFromPage(@currentTrack['src'])
						if tracks
							tracks.shift # remove the first track, which will be the main video on the page
							@trackIndex = @tracks.length
							@trackFilters = nil
							useTracks tracks, true # and set track index to the first
							commandRequiresNext = true
						end
						{:chainedInput => input}
					}
				},
				'info' => {
					'description' => "Show track info",
					'action' => Proc.new { |input, output|
						chunks = input.split ' '
						index = chunks.shift
						if index && index.length > 0
							track = @tracks[index.to_i - 1]
						else
							track = @currentTrack
						end
						alreadyHas = {
							:title => track.has_key?('title'),
							:duration => track.has_key?('duration'),
							:description => track.has_key?('description'),
							:bpm => track.has_key?('bpm')
						}
						tagNames = getTrackTags track

						outputMessageLines = []
						outputMessageLines << "    volume : #{getCurrentMplayerVolume}/100"
						outputMessageLines << "------------------------------"
						outputMessageLines << "     title : #{track['title']}" if alreadyHas[:title]
						if track == @currentTrack
							timeMessage = "      time : #{getDurationStringFromSeconds getCurrentMplayerTimePosition}"
							timeMessage += " / #{track['duration']}" if alreadyHas[:duration]
							timeMessage += " (#{@speed}x)" if @speed != 1
							if @currentTrack.has_key? 'chapters'
								chapterIndex = getChapterIndexAtTime @currentTrack, getCurrentMplayerTimePosition
								timeMessage += "\n   chapter : #{@currentTrack['chapters'][chapterIndex]['name']}"
							end
							outputMessageLines << "#{timeMessage}"
						else
							outputMessageLines << "  duration : #{track['duration']}" if alreadyHas[:duration]
						end
						outputMessageLines << "      tags : #{tagNames.join ', '}" if tagNames.length > 0
						outputMessageLines << "    rating : #{track['rating']}" if track['rating']
						outputMessageLines << "       bpm : #{track['bpm']}" if alreadyHas[:bpm]
						outputMessageLines << "downloaded : #{trackFileExists? track}"
						outputMessageLines << "==============================\n#{track['description']}" if alreadyHas[:description]
						output.call outputMessageLines.join "\n"

						outputMessageLines = []
						if !alreadyHas[:title] || !alreadyHas[:duration] || track['title'].length == 0 || @configuredVerbosity > 0
							info = getTrackInfo track['src']
							updateTrackInfo track, info

							outputMessageLines << "     title : #{track['title']}" if !alreadyHas[:title]
							outputMessageLines << "  duration : #{track['duration']}" if !alreadyHas[:duration]
							outputMessageLines << "sourceTags : #{info['sourceTags']}" if info['sourceTags']
							outputMessageLines << "==============================\n#{track['description']}" if !alreadyHas[:description] && track['description']
						else
							info = {'url' => "http://youtu.be/#{track['src']}"}
						end

						outputMessageLines << "       url : #{info['url']}"

						if @configuredVerbosity > 0 && tagNames.length > 0
							whisper "about to loop through tagNames", 4
							tagNames.each { |tagName|
								whisper "digging up ancestors of #{tagName}", 4
								ancestorTags = getAncestorTagNames tagName
								whisper("ancestors of tag '#{tagName}': #{ancestorTags}", 1) if ancestorTags.length > 0
							}
						end

						outputMessageLines << "------------------------------"
						output.call outputMessageLines.join "\n"

						{:chainedInput => chunks.join(' ')}
					}
				},
				'search' => {
					'description' => "<query> Search YouTube. (not chainable)",
					'action' => Proc.new { |input, output|
						if input and input.length > 1
							searchedTracks = searchYouTube(input)
							if searchedTracks
								@trackIndex = @tracks.length
								@trackFilters = nil
								useTracks searchedTracks
								commandRequiresNext = true
							end
						else
							output.call "Enter a search term of at least 2 characters."
						end
						nil
					}
				},
				'loop' => {
					'description' => 'Toggle loop.',
					'action' => Proc.new { |input, output|
						@loop = !@loop
						commandRequiresNext = true if @loop
						output.call "loop: #{@loop ? 'on' : 'off'}"
						{:chainedInput => input}
					}
				},
				'shuffle' => {
					'description' => 'Toggle shuffle.',
					'action' => Proc.new { |input, output|
						@shuffle = !@shuffle
						output.call "shuffle: #{@shuffle ? 'on' : 'off'}" if @configuredVerbosity >= 1
						{:chainedInput => input}
					}
				},
				'ab' => {
					'description' => 'Create or edit an A/B loop in this track.',
					'action' => Proc.new { |input, output|
						chunks = input.split ' '
						testing = false

						loadLibrary

						if chunks.length > 0 && chunks[0] == 'test'
							output.call "testing A/B loop"
							testing = true
							chunks.shift
						end
						if chunks.length > 0 && chunks[0].match(/beats?$/)
							if @currentTrack['loop']
								if @currentTrack['bpm']
									numberOfBeatsToShift = (chunks.shift.gsub(/[^0-9.+-]*/, '')).to_f
									beatShift = numberOfBeatsToShift * 60.0 / @currentTrack['bpm'].to_f
									whisper "Shifting by #{beatShift} seconds (#{numberOfBeatsToShift} beats at #{@currentTrack['bpm']} BPM).", 1
									@currentTrack['loop'][0] += beatShift
									@currentTrack['loop'][1] += beatShift
								else
									output.call "No BPM on this track. Set with /bpm."
								end
							end
						elsif chunks.length > 1
							aTime = chunks.shift.to_f
							bTime = chunks.shift.to_f
						end
						if trackFileExists? @currentTrack
							if aTime && bTime
								output.call "Setting A/B (#{aTime}/#{bTime}) & seeking to the end to test."
								@currentTrack['loop'] = [aTime, bTime]
								if not testing
									writeLibraryToFile true
								end
								testing = true
							elsif @currentTrack['loop']
								output.call "A: #{@currentTrack['loop'][0]} B: #{@currentTrack['loop'][1]}"
							else
								output.call "No A/B loop on track."
							end
							if testing
								@playerTemporaryInteractiveCommands << "seek #{@currentTrack['loop'][1] - 3.0} 2"
								commandRequiresNext = true
							end
						else
							output.call "Download the track before adding an A/B loop."
						end
						{:chainedInput => chunks.join(' ')}
					}
				},
				'log' => {
					'description' => 'Toggle logarithmic volume scale.',
					'action' => Proc.new { |input, output|
						@isVolumeAlreadyLogarithmic= !@isVolumeAlreadyLogarithmic
						output.call "logarithmic volume scale: #{@isVolumeAlreadyLogarithmic ? 'off' : 'on'}"
						{:chainedInput => input}
					}
				},
				'net' => {
					'description' => 'Toggle "no-network".',
					'action' => Proc.new { |input, output|
						@noNetwork = !@noNetwork
						output.call "network: #{@noNetwork ? 'off' : 'on'}"
						{:chainedInput => input}
					}
				},
				'fixbpm' => {
					'description' => "TODO: [Toggle ON/off] Change next track's playback speed to BPM of a current track. If either track does not have BPM metadata, then the curent playback speed is maintained.",
					'action' => Proc.new { |input, output|
						@fixbpm = !@fixbpm
						output.call "TODO: fixbpm #{@fixbpm ? "on" : "off"}"
						{:chainedInput => input}
					}
				},
				'defvolume' => {
					'description' => "FIXME: save current volume relative to default in library.",
					'action' => Proc.new { |input, output|
						loadLibrary
						@currentTrack['loudness'] = getMplayerConfigNumericProperty('volume') / getCurrentMplayerVolume
						writeLibraryToFile true
						{:chainedInput => input}
					}
				},
				'download' => {
					'description' => "Download the current track for faster play in the future. Optional 'get' parameter prints the download shell command instead.",
					'action' => Proc.new { |input, output|
						inputParts = input.match(/^([^\/]*)(.*)$/)
						shouldOutputCommand = inputParts[1] == 'get'
						if not trackFileExists? @currentTrack
							downloadOutput = downloadTrack @currentTrack, nil, shouldOutputCommand
							output.call downloadOutput if shouldOutputCommand
						else
							output.call "This file is already downloaded."
							if shouldOutputCommand
								puts findTrackFiles(@currentTrack)[0]
							end
						end
						{:chainedInput => inputParts[2]}
					}
				},
				'add' => {
					'description' => 'Add a track by id.',
					'action' => Proc.new { |input, output|
						chunks = input.split ' '
						if chunks.length > 0
							videoID = chunks.shift
							tracks = getTracksFromURLs videoID
							output.call "Adding #{videoID} to track list. Playing next."
							@tracks << matchExistingLibraryTrack(createTrack(videoID, 'youtube'))

							# FIXME: I don't necessarily want to go to the track next, but it's better than not being able to find the track
							@trackIndex = @tracks.length - 1
							commandRequiresNext = true
						end
						{:chainedInput => chunks.join(' ')}
					}
				},
				'again' => {
					'description' => "Play the last track again.",
					'action' => Proc.new { |input, output|
						commandRequiresNext = true
						{:chainedInput => input}
					}
				},
				'stream' => {
					'description' => "Ignore downloaded files.",
					'action' => Proc.new { |input, output|
						@forceStreaming = !@forceStreaming
						output.call "force streaming: #{@forceStreaming ? 'on' : 'off'}"
						{:chainedInput => input}
					}
				},
				'chapter' => {
					'description' => 'Skip to a chapter, or show chapter list.',
					'action' => Proc.new { |input, output|
						whisper "chapter command - input: #{input}", 3
						inputParts = input.match(/^([^\/]*)(.*)$/)
						fileExists = trackFileExists? @currentTrack
						if inputParts[1] && inputParts[1].length > 0
							if @currentTrack['chapters']
								chapterIndex = inputParts[1].to_i - 1
								if chapterIndex < 0
									chapterIndex = getChapterIndexAtTime @currentTrack, getCurrentMplayerTimePosition
									if inputParts[1] == '>'
										chapterIndex +=1
									elsif inputParts[1] == '<'
										chapterIndex -= 1
									else
										chapterList = @currentTrack['chapters'].map { |chapter| "#{chapter['time']} - #{chapter['name']}" }
										selectedChapter = firstFuzzyMatch inputParts[1], chapterList
										chapterIndex = selectedChapter[:index] if selectedChapter
									end
								end
								whisper "Choosing chapter #{chapterIndex}", 2
							else
								output.call "No chapters on the current track."
							end
							input = inputParts[2]
						else
							if @currentTrack['chapters']
								whisper "Prompting to select a chapter from the list...", 2
								commandRequiresBreak = false
								commandRequiresNext = false

								chapterPromptMessage = nil

								chapterResponse = promptForChapterIndex @currentTrack['chapters'], interactiveCommands, chapterPromptMessage
								chapterIndex = chapterResponse[:index]

								next if commandRequiresNext
								break if commandRequiresBreak
							else
								output.call "No chapters on the current track."
							end
						end

						whisper "Done with chapter selection. Resulting chapter index: #{chapterIndex}", 3

						if chapterIndex
							currentPlaybackSeconds = getCurrentMplayerTimePosition
							whisper "currentPlaybackSeconds: #{currentPlaybackSeconds}", 3
							chapterTime = @currentTrack['chapters'][chapterIndex]['time']
							chapterSeconds = getSecondsFromDurationString chapterTime
							whisper "chapterSeconds: #{chapterSeconds}", 3
							isAbleToSeek = fileExists || chapterSeconds > currentPlaybackSeconds
							whisper "isAbleToSeek: #{isAbleToSeek}", 3
							if isAbleToSeek
								fadeVolume 'out', 1, @currentPlayerIndex
								playerInputStreamName = "#{Player::MPLAYER_INPUT_FIFO_NAME}#{@currentPlayerIndex}"
								putInTempFile playerInputStreamName, "seek #{chapterSeconds} 2\n"
								fadeVolume 'in', 0, @currentPlayerIndex
							else
								output.call "Download the file to be able to seek backwards."
								commandRequiresNext = true
							end
						end

						{:chainedInput => input}
					}
				},
				'player' => {
					'description' => 'Define player startup options. Takes effect on the next track being played',
					'action' => Proc.new { |input, output|
						samplePlayerCommands = [];
						samplePlayerCommands << 'Some sample options:';
						samplePlayerCommands << 'EQ for earplugs: -af equalizer=2:6:1:0:0:1:2:4:6:3';
						samplePlayerCommands << 'small video window in the corner: -geometry 100%:100% -xy 150';
						samplePlayerCommands << 'mix stereo to mono: -af pan=1:0.5:0.5';
						@playerOverrideCommands = editListInVim(@playerOverrideCommands, samplePlayerCommands.join("\n"))
						{:chainedInput => input}
					}
				},
				'filter' => {
					'description' => 'Edit filters.',
					'action' => Proc.new { |input, output|
						inputParts = input.match(/^([^\/]*)(.*)$/)
						if inputParts[1] && inputParts[1].length > 0
							filters = parseOptionParameters inputParts[1]
						else
							filtersList = []
							filtersList += @trackFilters.map { |filter, rule| "#{filter}=#{rule}" } if @trackFilters
							filtersList += @trackExcludeFilters.map { |filter, rule| "-#{filter}=#{rule}" } if @trackExcludeFilters
							filterInstructions = []
							filterInstructions << Player::FILTER_HELP_1
							filterInstructions << Player::FILTER_HELP_2
							filterInstructions << Player::FILTER_HELP_3
							filterInstructions << '' # empty line
							filterInstructions << "Available tags: #{listAllTagsWithAliases.join ', '}"
							filterInstructions << "For music without words: -tag=verbal acapella visual live noise delete missing-source"
							instructions = filterInstructions.join "\n"
							filters = parseOptionParameters editListInVim(filtersList, instructions).join ','
						end

						@trackFilters = {}
						@trackExcludeFilters = {}
						filters.each { |name, filter|
							if name.match /^-/
								@trackExcludeFilters[name.sub(/^-/, '')] = filter
							else
								@trackFilters[name] = filter
							end
						}

						filterTracksOnDeck
						{:chainedInput => inputParts[2]}
					}
				},
				'exit' => {
					'description' => 'Exit tunewich when the current track finishes or is quit.',
					'action' => Proc.new { |input, output|
						commandRequiresExit = true
						{:chainedInput => input}
					}
				},
				'verbose' => {
					'description' => 'Set level of verbosity: -1 (silent) to 5 (extra debugging).',
					'action' => Proc.new { |input, output|
						inputParts = input.match(/^([^\/]*)(.*)$/)
						if inputParts[1] && inputParts[1].length > 0
							@configuredVerbosity = inputParts[1].to_i
							input = inputParts[2]
						end
						output.call "verbosity set to #{@configuredVerbosity}"
						{:chainedInput => input}
					}
				},
				'format' => {
					'description' => 'Choose the file format to download (e.g. "mp4"; default "m4a").',
					'action' => Proc.new { |input, output|
						chunks = input.split ' '
						if chunks.length > 0
							@preferredFileFormat = chunks.shift
						else
							output.call "preferred file format: #{@preferredFileFormat}"
						end
						{:chainedInput => chunks.join(' ')}
					}
				},
				'commands' => {
					'description' => "List #{Player::PLAYER_APPLICATION} commands.",
					'action' => Proc.new { |input, output|
						system "#{Player::PLAYER_APPLICATION} -input cmdlist"
						{:chainedInput => input}
					}
				}
			}

			track = nil
			# chaptersNotPlayed = []

			while not playerOutput or playerOutput[:exit] do
				if @trackIndex && @tracks[@trackIndex]
					commandRequiresBreak = false
					commandRequiresNext = false

					@currentTrack = matchExistingLibraryTrack @tracks[@trackIndex]

					titleBlock "[#{@trackIndex + 1}] - #{@currentTrack['title']} (#{@currentTrack['duration']})"

					if @updateAllPlayedTrackInfo && !@noNetwork
						printRepeat "Getting latest track information..."
						updateTrackInfo @currentTrack
					end

					fileExists = trackFileExists? @currentTrack

					if !fileExists && @noNetwork
						nextTrack
						next
					end

					playerOutput = play @currentTrack, interactiveCommands

					trackDurationInSeconds = getSecondsFromDurationString(@currentTrack['duration'])

					if !@currentTrack['unattached']
						loadLibrary
						@currentTrack['playTime'] ||= 0
						@currentTrack['playTime'] += playerOutput[:playTime].to_i
						minimumPlayTime = [30, trackDurationInSeconds -10].min
						if playerOutput[:playTime] >= minimumPlayTime
							@currentTrack['lastPlayed'] = playerOutput[:endTime].to_i
							@currentTrack['playCount'] ||= 0
							@currentTrack['playCount'] += 1
						else
							@currentTrack['skipCount'] ||= 0
							@currentTrack['skipCount'] += 1
						end
						writeLibraryToFile true
					end

					whisper "I've been asked to exit", 4 if commandRequiresExit
					return if commandRequiresExit
					whisper "I've been asked to break", 4 if commandRequiresBreak
					break if commandRequiresBreak
					whisper "I've been asked to skip to next", 4 if commandRequiresNext
					next if commandRequiresNext

					nextTrack()
				else
					whisper "Empty tracklist", 3
					commandPrompt "empty", interactiveCommands
				end
			end
		end

		def getChapterIndexAtTime track, seconds
			chapterIndex = nil
			whisper "Finding chapter at #{seconds} seconds on track: #{track['title']}", 4
			if track.has_key? 'chapters'
				whisper "Looping through chapters.", 4
				track['chapters'].each_with_index { |chapter, index|
					chapterSeconds = getSecondsFromDurationString chapter['time']
					whisper "chapterSeconds: #{chapterSeconds}", 4
					if chapterSeconds <= seconds
						chapterIndex = index
					else
						break
					end
				}
			else
				whisper "This track has no chapters: #{track['title']}", 2
			end
			chapterIndex
		end

		def fadeVolume targetFadeVolume, duration, playerIndex
			whisper "fadeVolume(targetFadeVolume:#{targetFadeVolume}, duration:#{duration}, playerIndex:#{playerIndex})", 4
			volume = getCurrentMplayerVolume
			@currentVolume = volume
			whisper "got volume: #{volume}", 4
			if targetFadeVolume == 'out'
				whisper "fading out volume", 2
				targetFadeVolume = 0
				@volumeBeforeFadingOut = volume
			elsif targetFadeVolume == 'in'
				targetFadeVolume = @volumeBeforeFadingOut
				whisper "fading in volume (to #{targetFadeVolume})", 2
			elsif targetFadeVolume.match /x$/
				multiplier = targetFadeVolume.to_f
				targetFadeVolume = volume * multiplier
				@volume = targetFadeVolume
				whisper "fading volume #{multiplier}x (to #{targetFadeVolume})", 2
			else
				targetFadeVolume = targetFadeVolume.to_f
				@volume = targetFadeVolume
				whisper "fading to volume #{targetFadeVolume}", 2
			end
			whisper "fading from #{volume} to #{targetFadeVolume} in #{duration} seconds (playerIndex: #{playerIndex})", 4
			volumeFadeInterval = 0.02
			volumeFadeStepCount = (duration.to_f / volumeFadeInterval).to_i
			volumeSpan = targetFadeVolume - volume
			lowerVolume = [volume, targetFadeVolume].min
			if volumeSpan != 0
				absoluteVolumeSmap = volumeSpan.abs
				if @isVolumeAlreadyLogarithmic
					volumeStepStrategy = Proc.new { |stepIndex|
						volume = lowerVolume + volumeSpan.abs * (stepIndex.to_f / volumeFadeStepCount)
					}
				else
					volumeStepStrategy = Proc.new { |stepIndex|
						volume = lowerVolume + 10**(Math.log10(volumeSpan.abs + 1) / volumeFadeStepCount * stepIndex) - 1
					}
				end
				stepFade = Proc.new { |stepIndex|
					volumeStepStrategy.call(stepIndex)
					@currentVolume = volume
					showPlaybackInfo true
					putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{playerIndex}", "volume #{volume} 1\n"
					sleep volumeFadeInterval
				}
				if volumeSpan > 0
					1.upto(volumeFadeStepCount - 1) { |stepIndex| stepFade.call stepIndex }
				else
					(volumeFadeStepCount - 1).downto(1) { |stepIndex| stepFade.call stepIndex }
				end
				@currentVolume = targetFadeVolume
				putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{playerIndex}", "volume #{targetFadeVolume} 1\n"
			else
				whisper "fading to the same volume: doing nothing", 4
			end
		end

		def rampSpeed targetRampSpeed, duration, playerIndex
			if targetRampSpeed
				speed = getCurrentMplayerSpeed
				@currentSpeed = speed
				if targetRampSpeed == 'out'
					targetRampSpeed = 0
					@speedBeforeRampingOut = speed
				elsif targetRampSpeed == 'in'
					targetRampSpeed = @speedBeforeRampingOut
				else
					targetRampSpeed = targetRampSpeed.to_f
					@speed = targetRampSpeed
					# does this work? # @speed = targetRampSpeed.to_f!
				end
				speedRampInterval = 0.02
				speedRampStepCount = duration / speedRampInterval
				speedStep = (targetRampSpeed - speed) / duration * speedRampInterval
				whisper "about to ramp speed by #{speedStep} every #{speedRampInterval} seconds", 4
				for stepIndex in 1..speedRampStepCount
					speed += speedStep
					@currentSpeed = speed
					showPlaybackInfo true
					putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{playerIndex}", "speed_set #{speed}\n"
					sleep speedRampInterval
				end
				@currentSpeed = targetRampSpeed
				putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{playerIndex}", "speed_set #{targetRampSpeed}\n"
				return true
			else
				puts "Bad speed format, or track has no bpm set."
			end
			return false
		end

		def findTag(query)
			whisper "about to search for tag by query '#{query}'", 4
			tag = nil

			if @library['tags'].has_key? query
				whisper "found tag '#{query}' by name", 1
				tag = @library['tags'][query]
			else
				whisper "no tag by that name, checking aliases for '#{query}'", 1
				@library['tags'].each { |name, t|
					if t['aliases'] && t['aliases'].include?(query)
						whisper "found tag '#{name}' by alias '#{query}'", 1
						tag = t
					end
				}
			end
			whisper "no tag found by query '#{query}'", 1 if !tag

			tag
		end

		def addTrackToTags(track, tagNames)
			whisper "adding tags: #{tagNames}", 2
			tagNames.each { |tagName|
				whisper "about to add to tag '#{tagName}'", 4
				matchingTag = findTag(tagName) || createTag(tagName)
				whisper "matchingTag: #{matchingTag}", 4
				matchingTag['tracks'] ||= []
				whisper "adding track to tag #{tagName}", 4
				matchingTag['tracks'] << track['id']
				matchingTag['tracks'].uniq!
			}
		end

		def removeTagsFromTrack(track, tagNames)
			whisper "removing tags: #{tagNames}", 2
			tagNames.each { |tagName|
				matchingTag = findTag tagName
				if matchingTag
					matchingTag['tracks'].delete track['id'] if matchingTag['tracks'].include? track['id']
				end
			}
		end

		def combineTags(tagNames)
			firstTag = findTag tagNames.shift

			if firstTag
				tagNames.each { |collapsingTagName|
					tag = findTag collapsingTagName
					if tag && tag != firstTag
						firstTag['aliases'] << collapsingTagName
						firstTag['tracks'].concat tag['tracks']
						deleteTag collapsingTagName
					end
				}

				firstTag['aliases'].uniq!
				firstTag['tracks'].uniq!
			end

			firstTag
		end

		def createTag(tagName)
			whisper "creating tag '#{tagName}'", 2
			@library['tags'][tagName] = {}
			@library['tags'][tagName]
		end

		def deleteTag(tagName)
			@library['tags'].delete tagName if @library['tags'][tagName]
		end

		def play(track, interactiveCommands)
			@currentPlayerIndex = 1 - @currentPlayerIndex
			whisper "@currentPlayerIndex: #{@currentPlayerIndex}", 4
			response = {
				:exit => true,
				:playTime => 0
			}
			playerStartupOptions = []
			playerInputStreamName = "#{Player::MPLAYER_INPUT_FIFO_NAME}#{@currentPlayerIndex}"
			deleteStream playerInputStreamName
			playerInputFile = makeStream playerInputStreamName
			playerStartupOptions << "-slave -quiet -input file=#{playerInputFile}"
			playerStatus = nil
			playerAction = Proc.new { |command|
				whisper "playerAction: begin", 4
				putInTempFile playerInputStreamName, "#{command}\n"
				if /^vol/.match command
					whisper "playerAction: found a volume command", 4
					@currentVolume = getCurrentMplayerVolume
					@volume = @currentVolume
					puts "volume: #{@volume}"
				end
				whisper "playerAction: done", 4

				true
			}
			# TODO: I shouldn't need to check twice
			fileAlreadyExists = !@forceStreaming && trackFileExists?(track)
			streaming = @forceStreaming || (!fileAlreadyExists && !@enableDownload)

			if @noNetwork && !fileAlreadyExists
				puts "No local file to play: #{track['title']}"
				return response
			end

			if track['mark']

				if not streaming
					puts "Starting from mark at #{getDurationStringFromSeconds track['mark']} seconds."
					offsetSeconds = track['mark']
					playerStartupOptions << "-ss #{offsetSeconds}"
					loadLibrary
					track.delete 'mark'
					writeLibraryToFile true
				else
					puts "This track has a mark at #{getDurationStringFromSeconds track['mark']} seconds. Download the track to seek to it."
				end

			elsif @loop && track['loop'].kind_of?(Array)
				whisper "ooh, this track has has an A/B loop!", 2

				if not streaming
					duration = track['loop'][1] - track['loop'][0]

					playerAction.call "seek 0 1"

					whisper "setting some player startup options", 4
					# loop back from B to A
					playerStartupOptions << "-ss #{track['loop'][0]}"
					playerStartupOptions << "-endpos #{duration}"
				else
					titleBlock "This track has an A/B loop, but looping is not supported while streaming. Add the -d option to enable downloading."
				end

			end

			if fileAlreadyExists
				mediaFilePath = firstTrackFile track
			else
				if streaming
					streamName = 'youtube-stream'
					deleteStream streamName
					streamPath = mediaFilePath = makeStream streamName
				end

				if not downloadTrack track, streamPath
					return response
				end
			end

			if not mediaFilePath
				puts "File not found for #{track['title']}."
				return response
			end

			if !streamName
				playerStartupOptions << "-loop 0" if @loop
			end

			@speed = 1 if @speed < 0.01
			speed = @speed
			if @playingBPM && @currentTrack['bpm']
				speed = @speed * @playingBPM / @currentTrack['bpm']
			end

			@currentVolume = @volume # they may differ, but at this point, only @volume matters
			playerStartupOptions += @playerOverrideCommands
			playerStartupOptions += ["-volume #{@volume}"]
			playerStartupOptions += ["-speed #{speed}"]

			if track['loudness']
				playerStartupOptions += ["-volume #{(getMplayerConfigNumericProperty('volume') / track['loudness']).round}"]
			end

			response[:startTime] = Time.now.to_f

			playerStdoutName = "#{Player::MPLAYER_STDOUT_BUFFER_NAME}#{@currentPlayerIndex}"
			playerStdoutFile = getTempFilePath playerStdoutName

			@inputThread.kill if @inputThread
			@inputThread = Thread.new {
				whisper "commandPrompt start (opening input thread)", 4
				commandPrompt Player::PLAYER_APPLICATION, interactiveCommands, playerAction
				whisper "commandPrompt end", 4
			}
			if @playerTemporaryInteractiveCommands.length > 0
				playerAction.call @playerTemporaryInteractiveCommands.join("\n")
				@playerTemporaryInteractiveCommands = []
			end
			@playerApplicationThreads[@currentPlayerIndex] = Thread.new {
				playerCommand = "#{Player::PLAYER_APPLICATION} \"#{mediaFilePath}\" #{playerStartupOptions.join ' '} > #{playerStdoutFile}"
				whisper playerCommand, 4
				playerStatus = `#{playerCommand} 2> /dev/null`
				whisper "#{Player::PLAYER_APPLICATION} is finished. killing user input thread", 4
				@inputThread.kill if @inputThread
			}

			# TODO: show chapters changing
			@shouldShowRealtimeOutput = true # might have been set false if the player quit while realtime output was hidden
			while @playerApplicationThreads[@currentPlayerIndex].alive?
				sleep 0.1
				showPlaybackInfo
			end
			# @playerApplicationThreads[@currentPlayerIndex].join
			whisper "killing user input thread (again)", 4
			@inputThread.kill if @inputThread # FIXME: overkill?

			response[:endTime] = Time.now.to_f

			deleteStream playerInputStreamName
			deleteTempFile playerStdoutName

			response[:playTime] = response[:endTime] - response[:startTime]

			if streaming
				deleteStream streamName
			elsif !@keepUnattachedDownload && !fileAlreadyExists && track['unattached']
				deleteTrackFile track
				titleBlock "UNATTACHED DOWNLOAD DELETED", 'X'
			end

			response[:exit] = playerStatus
			response
		end

		def showPlaybackInfo force = false
			if force || (@shouldShowRealtimeOutput && @configuredVerbosity > -1)
				playbackInfo = []
				unicodeChars = {
					:speaker => "ðŸ”ˆ",
					:timer => "â²",
					:openBook => "ðŸ“–",
					:label => "ðŸ·",
					:star => "â˜…",
					:crossArrows => "â¤®",
					:parallelArrows => "â‡‰",
					:whiteStar => "â˜†",
					:floppyDisk => "ðŸ’¾"
				}

				# show shuffle or regular playback
				playbackInfo << "#{@shuffle ? unicodeChars[:crossArrows] : unicodeChars[:parallelArrows]}"

				# show volume
				volumeIndication = "â–ˆ" * (@currentVolume / 10).to_i + ["", "â–", "â–‚", "â–ƒ", "â–„", "â–…", "â–†", "â–‡"][(@currentVolume % 10 / 1.25).to_i]
				volumeIndication = "[#{volumeIndication}#{" " * (10 - volumeIndication.length)}]"
				playbackInfo << "#{unicodeChars[:speaker]} #{volumeIndication}"

				# show playback position
				currentPlayerTimePosition = getCurrentMplayerTimePosition
				timeMessage = "#{unicodeChars[:timer]}  #{getDurationStringFromSeconds currentPlayerTimePosition}"
				timeMessage += "/#{@currentTrack['duration']}" if @currentTrack.has_key?('duration')
				timeMessage += "(#{(@currentSpeed * 10).round / 10.0}x)" if @currentSpeed != 1
				playbackInfo << timeMessage

				# show if the track file is downloaded
				playbackInfo << "#{unicodeChars[:floppyDisk]}" if trackFileExists?(@currentTrack)

				# show track rating
				if @currentTrack.has_key? 'rating'
					playbackInfo << "#{unicodeChars[:star]} #{@currentTrack['rating']}"
				end

				# show current chapter name
				if @currentTrack.has_key?('chapters')
					chapterIndex = getChapterIndexAtTime @currentTrack, currentPlayerTimePosition
					if chapterIndex
						playbackInfo << "#{unicodeChars[:openBook]}  #{@currentTrack['chapters'][chapterIndex]['name']}"
					end
				end

				# show tags on this track
				currentTags = getTrackTags @currentTrack
				if currentTags && currentTags.length > 0
					playbackInfo << "#{unicodeChars[:label]}  #{currentTags.join ', '}"
				end

				# check again if realtime output has been disabled while were doing all this stuff
				if force || (@shouldShowRealtimeOutput && @configuredVerbosity > -1)
					printRepeat(playbackInfo.join(' '), true)
				end
			end
		end

		def getMplayerProperty property, pattern = nil
			pattern ||= /^()(.*)$/
			command = "#{property}\n"
			command = "get_property #{command}" if not property.match(/^get_/)
			responseWait = 0.1
			putInTempFile "#{Player::MPLAYER_INPUT_FIFO_NAME}#{@currentPlayerIndex}", command
			sleep responseWait
			lastPlayerOutput = tailTempFile "#{Player::MPLAYER_STDOUT_BUFFER_NAME}#{@currentPlayerIndex}"
			if lastPlayerOutput
				whisper "read #{property} from player, output: #{lastPlayerOutput}", 4
				matches = lastPlayerOutput.match pattern
				return matches[2] if matches
			end
			return nil
		end

		def getCurrentMplayerTimePosition
			now = Time.now.to_f
			if !@lastPlayerTimeGetTime || now - @lastPlayerTimeGetTime > 0.5
				@playerCurrentTime = getMplayerProperty('get_time_pos', /^(ANS_TIME_POSITION=|.*Time: )(.*?)(\?)?$/).to_f
				@lastPlayerTimeGetTime = Time.now.to_f # set current time after get, since it takes a significant fraction of a second
			end
			@playerCurrentTime
		end

		def getCurrentMplayerVolume
			getMplayerProperty('volume', /^(ANS_volume=|.*Volume: )(.*?)(\?)?$/).to_f
		end

		def getCurrentMplayerSpeed
			getMplayerProperty('speed', /^(ANS_speed=|.*Speed: )(.*?)(\?)?$/).to_f
		end

		def getMplayerConfigNumericProperty(propertyName, defaultValue = 0.0)
			playerCommands = []
			playerCommands += @playerOverrideCommands if @playerOverrideCommands
			propertyValue = defaultValue

			playerCommands.each { |command|
				if command.include? propertyName
					propertyValue = command.match(/.*-#{propertyName} ([0-9.]+)/)[1].to_f
				end
			}

			propertyValue.to_f
		end

		def nextTrack
			whisper "next track", 2
			if @shuffle
				# FIXME: this should happen regardles of @shuffle, but it would mess with @trackIndex. With @shuffle == true, it doesn't matter.
				filterTracksOnDeck()
				shuffleIndex()
			else
				@trackIndex += 1

				if @trackIndex > @tracks.length - 1

					if @youtubeSearchPage && !@noNetwork
						@youtubeSearchPage += 1
						searchedTracks = searchYouTube(@youtubeSearch, (@youtubeSearchPage - 1) * 20)
						useTracks(searchedTracks, true) if searchedTracks
					else
						@trackIndex %= @tracks.length
					end

				end

			end
		end

		def useTracks tracks, append = true
			if append
				whisper "Adding #{tracks.length} tracks to the end of your play queue."
			else
				whisper "Replacing your play queue with #{tracks.length} tracks."
				@tracks = []
			end
			@tracks += tracks
			filterTracksOnDeck
			putInTempFile('tracks', listTrackTitles(@tracks).join("\n"), false)
			if @trackIndex && @trackIndex > @tracks.length - 1
				@trackIndex = 0
			end
		end

		def filterTracksOnDeck
			if @trackFilters
				@tracks = filterTracks @tracks, @trackFilters
			end

			if @trackExcludeFilters
				@tracks = filterTracks @tracks, @trackExcludeFilters, true
			end
		end

		def shuffleIndex
			@trackIndex = Random.rand(@tracks.length - 1) if @tracks.length > 1
		end

		def setLibraryPath libraryPath
			@tunewichDirectory = libraryPath
			if not Dir.exist? @tunewichDirectory
				puts "Please create the directory '#{@tunewichDirectory}'."
				exit
			end

			@fileDirectory = "#{@tunewichDirectory}/music"
			Dir.mkdir @fileDirectory if not Dir.exist? @fileDirectory

			@libraryFilePath = "#{@tunewichDirectory}/tunewich-library.json"
			if not File.exist? @libraryFilePath
				raise "TODO: create library file at #{@libraryFilePath}"
			end

			loadLibrary
		end

		def extendHash sourceTrack, overrideTrack
			overrideTrack.each { |property, value|
				sourceTrack[property] ||= value
			}
			sourceTrack
		end

		def matchExistingLibraryTrack track
			@library['library'].each { |id, t|
				if t['src'] === track['src']
					extendHash t, track
					track = t
					track.delete 'unattached' if track.has_key? 'unattached'
					break
				end
			}
			track
		end

		def getTrackTags track
			tags = []
			@library['tags'].each { |name, tag|
				tags << name if tag['tracks'].include? track['id']
			}
			tags
		end

		def getTrackTitles tracks
			tracks.map{|t| t['title']}
		end

		def findTrackIndex(query)
			match = firstFuzzyMatch query, getTrackTitles(@tracks)
			match ? match[:index] : false
		end

		def findPlaylistName(query)
			match = firstFuzzyMatch query, @library['playlists'].keys
			match ? match[:value] : false
		end

		def fuzzyStringSearchInList(query, list)
			queryPattern = Regexp.new(query + '|' + query.gsub(/\s+/, '').split('').join('.*'), Regexp::IGNORECASE)
			matches = []
			list.each_with_index do |value, index|
				matchedPortion = queryPattern.match(value)

				if matchedPortion
					match = {
						:index => index,
						:value => value,
						:matchLength => matchedPortion[0].length
					};
					match[:density] = query.length.to_f / match[:matchLength].to_f
					match[:breadth] = match[:matchLength].to_f / match[:value].length.to_f
					match[:score] = match[:density] * 10 + match[:breadth]
					whisper "match[:score]: #{match[:score]}", 3 # XXX
					matches << match
				end

			end

			if matches.length > 1
				matches.sort! { |a,b| b[:score] <=> a[:score] }
			end

			matches
		end

		def firstFuzzyMatch(query, list)
			matches = fuzzyStringSearchInList query, list
			matches.length ? matches[0] : false
		end

		def deleteTrackFile(track)
			`rm #{getTrackFilePrefix track}*`
		end

		def firstTrackFile(track)
			files = findTrackFiles(track)
			files.length ? files[0] : nil
		end

		def findTrackFiles(track)
			globString = "#{getTrackFilePrefix track}*"
			files = Dir.glob(globString)
			files.delete_if { |fileName| fileName.match /\.part$/ }
			files
		end

		def trackFileExists?(track)
			findTrackFiles(track).length > 0
		end

		def getIdFromFileName(fileName)
			id = fileName.gsub(/^tunewich-([A-Za-z0-9_-]{11}).*$/) {
				$1
			}
			id != fileName ? id : false
		end

		def getTrackFilePrefix(track)
			"#{@fileDirectory}/tunewich-#{track['id']}"
		end

		# @param hash track
		# @param string/nil streamPath
		# @param boolean shouldOutputCommand
		# @returns integer PID of download process, or string download command, if streamPath = nill && shouldOutputCommand = true
		def downloadTrack(track, streamPath = nil, shouldOutputCommand = false)
			if @noNetwork
				puts "not downloading --no-network"
				return
			end

			# TODO: remove --Frag0, --Frag1, ..., --FragN files? Would this interfere with playback if downloading a playing track?
			youtubeDlCommandBegin = "youtube-dl -f #{@preferredFileFormat}"
			# youtubeDlCommandBegin = "youtube-dl -f #{@preferredFileFormat} --no-part --no-cache-dir --no-continue"
			youtubeDlCommandEnd = "-- #{track['src']}"

			downloadPid = nil
			downloadFeedbackFileName = 'download-feedback'
			downloadFeedbackFile = createTempFile downloadFeedbackFileName

			if streamPath
				downloadPid = spawn("#{youtubeDlCommandBegin} -o - #{youtubeDlCommandEnd} > \"#{streamPath}\" 2> \"#{downloadFeedbackFile}\"")
			else
				# status = system "#{youtubeDlCommandBegin} -o \"#{getTrackFilePrefix track}-%(title)s.%(ext)s\" #{youtubeDlCommandEnd}"
				downloadCommand = "#{youtubeDlCommandBegin} -o \"#{getTrackFilePrefix track}-%(title)s.%(ext)s\" #{youtubeDlCommandEnd}"
				if shouldOutputCommand
					return downloadCommand
				else
					downloadPid = spawn("#{downloadCommand} &> \"#{downloadFeedbackFile}\"")
					Process.detach(downloadPid)

					while not trackFileExists? track # FIXME: event driven approach to waiting for a file?
						printRepeat "Fetching video information for download (#{cliRotate})"
						sleep 0.1
					end

					# TODO: see FIXME below
					# if track.has_key? 'duration'
					# 	trackDuration = getSecondsFromDurationString track['duration']
					# 	bufferDuration = trackDuration / 2
					# end

					while true
						output = tailTempFile downloadFeedbackFileName
						# FIXME: get player to play the whole file, even if only part is downloaded when it starts
						# if trackDuration
						# 	etaMatch = output.match(/ETA ([0-9:]+)/)
						# 	if etaMatch
						# 		eta = getSecondsFromDurationString etaMatch[1]
						# 		if eta < bufferDuration
						# 			printRepeat "ETA (#{eta}) is less than #{bufferDuration}. Ready to play.\n"
						# 			break
						# 		end
						# 	end
						# end
						if output.match(/#{track['src']}|100(\.0)?%|ERROR/)
							whisper "downloadTrack: #{output}", 2
							break
						end
						printRepeat "(#{cliRotate}) #{output}"
						sleep 0.1
					end

					# delayForFileToExist = 5
					# puts "Waiting #{delayForFileToExist} seconds to be sure the file is ready..."
					# sleep delayForFileToExist # FIXME: remove `sleep` in favor of checking if the right file exists yet
				end
			end

			deleteTempFile downloadFeedbackFileName

			downloadPid
		end

		def notify(message)
			if UNAME == 'Linux'
				if @configuredVerbosity > 0
					`notify-send --expire-time=3000 --urgency=low tunewich "#{message}"`
				end
			elsif UNAME == 'Darwin'
				whisper message, 1
			end
		end

		def titleBlock(message, fill = '=', width = 80)
			blockRow = fill * width
			padding = '  '
			marginSize = (width - message.length) / 2 - padding.length
			marginLeft = marginSize > 1 ? fill * marginSize : ''
			marginRight = marginLeft
			marginRight += fill if message.length % 2 == 1
			puts "\n#{blockRow}"
			puts "#{marginLeft}#{padding}#{message}#{padding}#{marginRight}"
			puts blockRow
			notify message
		end

		##
		# File Methods
		##

		def getTempFilePath(name, shouldIncludeSessionID = true)
			nameSegments = ["tunewich"]
			nameSegments << @sessionID if shouldIncludeSessionID
			nameSegments << name
			"/tmp/#{nameSegments.join '-'}"
		end

		def createTempFile(name)
			whisper "make tmp #{name}", 4
			putInTempFile name, ''
		end

		def putInTempFile(name, value, shouldIncludeSessionID = true)
			path = getTempFilePath(name, shouldIncludeSessionID)
			# FIXME: why does this stall when writing to a FIFO before something is reading from it?
			Thread.new {
				# FIXME: trying to put it in a new thread...maybe won't fix the problem, but it will unblock the main thread.
				writeResult = File.write(path, value)
				whisper "#{name} << '#{value.chomp}' (#{writeResult})", 4
			}
			path
		end

		def readTempFile(name, shouldIncludeSessionID = true)
			whisper "read tmp #{name}", 4
			path = getTempFilePath(name, shouldIncludeSessionID)

			if File.exist? path
				whisper "read tmp #{name}: exists", 4
				contents = File.read path
				whisper "read tmp #{name}, contents: #{contents}", 4
				return contents
			else
				whisper "read tmp #{name}: missing", 4
				return ''
			end
		end

		def tailTempFile(name, shouldIncludeSessionID = true)
			whisper "tail tmp #{name}", 4
			content = readTempFile(name, shouldIncludeSessionID)
			lastLine = ''
			if content && content.length > 0
				lastLine = content.gsub("\r","\n").lines.pop.strip.chomp
			end
			lastLine
		end

		def deleteTempFile(name, shouldIncludeSessionID = true)
			whisper "delete tmp #{name}", 4
			path = getTempFilePath(name, shouldIncludeSessionID)

			if File.exist? path
				File.delete path
			end
		end

		def makeStream(name)
			path = getTempFilePath name
			whisper "mkfifo #{path}", 4

			if File.exist? path
				File.delete path
				# raise "The temp file '#{name}' already exists. (#{path})"
			end

			if not system "mkfifo \"#{path}\""
				raise "ERROR: Could not create the stream file (#{path})"
			end

			File.exist?(path) && path
		end

		alias deleteStream deleteTempFile

		##
		# Library Methods
		##

		def usePlaylist(name, append = false)
			@playlistName = name
			tracks = []

			@library['playlists'][@playlistName]['tracks'].each do |trackReference|
				tracks << @library['library'][trackReference]
			end

			useTracks tracks, append
		end

		def useEntireLibrary
			tracks = []

			@library['library'].keys.each do |trackKey|
				tracks << @library['library'][trackKey]
			end

			useTracks tracks, false
		end

		def processLibraryJSON(json)
			{
				:json => json,
				:hash => Digest::MD5.digest(json),
				:data => JSON.parse(json)
			}
		end

		def loadLibrary
			libraryInfo = processLibraryJSON File.read(@libraryFilePath)
			if libraryInfo
				@library = libraryInfo[:data]
				@libraryHash = libraryInfo[:hash]
				if @tracks && @tracks.length > 0
					@tracks.each_with_index { |track, index|
						@tracks[index] = matchExistingLibraryTrack(@tracks[index])
					}
				end
			end
		end

		def writeLibraryToFile forceWritable = nil
			if !forceWritable && !@writeEnabled
				return if forceWritable == false || !confirm("Write changes to library?")
			end
			libraryJSON = JSON.pretty_generate(@library)
			libraryOnFile = processLibraryJSON File.read(@libraryFilePath)
			if @libraryHash == libraryOnFile[:hash] || confirm("Library file has changed since last load. Overwrite?")
				libraryInfo = processLibraryJSON libraryJSON
				File.write(@libraryFilePath, libraryJSON)
				@libraryHash = libraryInfo[:hash]
				whisper "Saved change to library file.", 2
			end
		end

		def removeTrackFromLibrary(id)
			@library['library'].delete id
			@library['playlists'].each { |playlistName, p|
				index = p['tracks'].index id
				if index
					p['tracks'].delete_at index
				end
			}
			@library['tags'].each { |tagName, t|
				index = t['tracks'].index id
				if index
					t['tracks'].delete_at index
				end
			}
		end

		def interactiveCleanup
			cleanupSelection = {}

			commands = {
				'ul' => {
					'description' => '"unlisted", select all tracks not in any playlist',
					'action' => Proc.new {

						unattachedTracks = {}

						@library['library'].map { |id, t| unattachedTracks[id] = t }

						@library['playlists'].each do |name, playlist|
							playlist['tracks'].each do |id|
								unattachedTracks.delete id if unattachedTracks.has_key? id
							end
						end

						if unattachedTracks.length > 0
							unattachedTracks.each { |id, track| cleanupSelection[id] = track }
							puts "#{listTrackTitles cleanupSelection}\n\n(#{cleanupSelection.length} tracks selected)"
						else
							puts "Every track is assigned to a playlist. No suggestions for cleanup."
						end

					}
				},
				'all' => {
					'description' => 'select all tracks in the library',
					'action' => Proc.new {
						cleanupSelection = cloneLibrary @library['library']
						puts "All tracks selected (#{cleanupSelection.length})"
					}
				},
				'add' => {
					'description' => '<playlistName> add selection to a playlist.',
					'action' => Proc.new { |playlistQuery|
						if playlistQuery && playlistQuery.length > 0
							playlistName = findPlaylistName playlistQuery

							if playlistName
								cleanupSelection.keys.each { |id| addTrackReferenceToPlaylist id, playlistName }
							elsif confirm "No existing playlist matching '#{playlistQuery}'. Create one?"
								createPlaylist playlistQuery, cleanupSelection.keys
							else
								playlistName = nil
							end

							if playlistName
								cleanupSelection = {}
								puts "Added #{cleanupSelection.length} tracks to playlist '#{playlistName}'"
							else
								puts "No change"
							end
						else
							puts "#{@library['playlists'].map { |name, p| name } .join "\n"}\n\nPlease specify a playlist name (new or existing)."
						end
					}
				},
				'keep' => {
					'description' => "#{Player::FILTER_HELP_1}\n#{Player::FILTER_HELP_2}\n#{Player::FILTER_HELP_3}",
					'action' => Proc.new { |filterString|
						cleanupSelection = cloneLibrary @library['library'] if cleanupSelection.length == 0
						# FIXME: lots of back and forth from arrays to hashes here. Want to pick one?
						cleanupSelection = cloneTracksToLibrary filterTracks cloneLibraryToTracks(cleanupSelection), parseOptionParameters(filterString)
						puts "#{cleanupSelection.length} tracks selected"
					}
				},
				'drop' => {
					'description' => "Excludes tracks matching the rules. #{Player::FILTER_HELP_1}\n#{Player::FILTER_HELP_2}",
					'action' => Proc.new { |filterString|
						cleanupSelection = cloneLibrary @library['library'] if cleanupSelection.length == 0
						# FIXME: lots of back and forth from arrays to hashes here. Want to pick one?
						cleanupSelection = cloneTracksToLibrary filterTracks cloneLibraryToTracks(cleanupSelection), parseOptionParameters(filterString), true
						puts "#{cleanupSelection.length} tracks selected"
					}
				},
				'edit' => {
					'description' => 'edit selection in Vim',
					'action' => Proc.new {
						whisper "FIXME: this may be broken, while listTrackTitles and getTracksFromTitleList are changing for interactive use", 4
						cleanupSelection = getTracksFromTitleList editListInVim(listTrackTitles(cleanupSelection), "remove or comment any tracks you want to deselect")
						puts "#{listTrackTitles(cleanupSelection).join "\n"}\n\n(#{cleanupSelection.length} tracks selected)"
					}
				},
				'clear' => {
					'description' => 'clear the selection',
					'action' => Proc.new {
						cleanupSelection = {}
						puts "0 tracks selected"
					}
				},
				'rm' => {
					'description' => 'remove selected tracks',
					'action' => Proc.new {
						initialLibraryLength = @library['library'].length
						cleanupSelection.each do |id, track|
							removeTrackFromLibrary id
						end
						checksum = initialLibraryLength - cleanupSelection.length == @library['library'].length
						checksumString = "#{initialLibraryLength} - #{cleanupSelection.length} == #{@library['library'].length}"
						puts "#{checksumString} ... #{checksum ? 'OK' : 'Mismatch'}"
						cleanupSelection = {}
					}
				},
				'jointag' => {
					'description' => '<playlistName> remove a playlist.',
					'action' => Proc.new { |tagsString|
						success = false

						if tagsString.length > 0
							tags = tagsString.split(Player::TAG_INPUT_SPLIT)
							if tags.length > 1
								success = combineTags tags
							else
								puts "Please give at least two tags."
							end
						end

						puts "Tags: \n  #{@library['tags'].keys.sort.join(", ")}" if not success
					}
				},
				'rmfile' => {
					'description' => 'Remove files not referenced in the library.',
					'action' => Proc.new {
						filesToDelete = []
						filesToIgnore = ['.', '..']
						Dir.entries(@fileDirectory).each { |file|
							if !filesToIgnore.include? file
								id = getIdFromFileName file
								if !id || !@library['library'][id]
									filesToDelete << file
								end
							end
						}
						if filesToDelete.length > 0
							filesToDelete = editListInVim filesToDelete, "remove any files you don't want to delete"

							filesToDelete.each { |file|
								File.delete "#{@fileDirectory}/#{file.chomp}"
							}
							puts "#{filesToDelete.length} files deleted."
						else
							puts "No orphaned files found."
						end
					}
				},
				'rmlist' => {
					'description' => '<playlistName> remove a playlist.',
					'action' => Proc.new { |playlistQuery|
						if playlistQuery && playlistQuery.length > 0
							playlistName = findPlaylistName playlistQuery

							if playlistName
								@library['playlists'].delete playlistName
								puts "removed playlist #{playlistName}"
							end

						else
							puts "#{@library['playlists'].map { |name, p| name } .join "\n"}\n\nPlease specify a playlist name (new or existing)."
						end
					}
				}
			}

			confirmMsg = "Choose a command, or \"y\" to write changes to file"
			if confirm confirmMsg, commands
				writeLibraryToFile true
			else
				puts "No changes saved."
			end

			puts "Cleanup finished."
		end

		def determineRelativeSpeed input, track, shouldSetPlayingBPM = false
			relativeSpeed = input.to_f
			if input.to_s.match /bpm$/
				if track.has_key? 'bpm'
					inputBPM = relativeSpeed
					if shouldSetPlayingBPM
						@playingBPM = inputBPM
						whisper "Setting playing BPM to #{@playingBPM}", 1
					end
					relativeSpeed = inputBPM / track['bpm']
				else
					relativeSpeed = nil
				end
			end
			relativeSpeed
		end

		def matchPropertyWithRangeString rangeString, hash, property
			rangeParts = " #{rangeString} ".split('-')
			isAMatch = false
			if hash.has_key? property
				if rangeParts.length == 2
					lowerMatch = rangeParts[0] == " " || hash[property] >= rangeParts[0].to_i
					upperMatch = rangeParts[1] == " " || hash[property] <= rangeParts[1].to_i
					isAMatch = lowerMatch && upperMatch
				else
					isAMatch = rangeParts[0].to_i == hash[property].to_i
				end
			end
			isAMatch
		end

		def getDescendantTagNames ancestorTagName, depth = 0
			whisper "getDescendantTagNames: depth #{depth}", 4
			allDescendantTags = []
			@library['tags'].each { |tagName, tag|
				if tag.has_key?('parents') && tag['parents'].include?(ancestorTagName)
					allDescendantTags << tagName
					whisper "#{ancestorTagName} #{">" * (depth + 1)} #{tagName}", 2
					allDescendantTags += getDescendantTagNames tagName, (depth + 1)
				end
			}
			allDescendantTags
		end

		def getAncestorTagNames descendantTagName, depth = 0
			whisper "getAncestorTagNames(descendantTagName:#{descendantTagName}, depth:#{depth})", 4
			allAncestorTags = []
			if @library['tags'].has_key? descendantTagName
				whisper "tag #{descendantTagName} has a definition", 5
				thisTag = @library['tags'][descendantTagName]
				if thisTag && thisTag['parents']
					whisper "thisTag['parents'].each ", 5
					thisTag['parents'].each { |tagName|
						whisper "tagName: #{tagName}", 5
						allAncestorTags << tagName
						whisper "#{descendantTagName} #{"<" * (depth + 1)} #{tagName}", 2
						allAncestorTags += getAncestorTagNames tagName, (depth + 1)
					}
				end
			else
				whisper "tag #{descendantTagName} is referenced as a parent, but has no definition of its own", 5
			end
			whisper "allAncestorTags.uniq", 5
			allAncestorTags.uniq
		end

		def filterTracks tracks, filters, isExcludeFilter = false
			whisper 'filterTracks', 4
			action = isExcludeFilter ? 'delete_if' : 'keep_if'

			if filters.has_key? 'local'
				tracks.send(action) { |t|
					trackFileExists? t
				}
			end

			if filters.has_key? 'rating'
				if filters['rating'] && filters['rating'].length > 0
					tracks.send(action) { |t|
						matchPropertyWithRangeString filters['rating'], t, 'rating'
					}
				else
					tracks.send(action) { |t| t.has_key? 'rating' }
				end
			end

			if filters.has_key? 'tag'
				if filters['tag']
					# TODO: add a tag fuzzy factor: include tags of tracks that have the current tag (only 1 degree separation to start)
					selectedTags = []
					unionTagTracks = []
					filterTags = filters['tag'].split(' ')
					descendantFilterTags = []
					filterTags.each { |tagName| descendantFilterTags += getDescendantTagNames(tagName).map {|name| "+#{name}"} }
					filterTags += descendantFilterTags
					filterTags.each { |tagName|
						unionPattern = /^\+/
						isUnionTag = tagName.match unionPattern
						tagName.sub!(unionPattern, '') if isUnionTag
						if @library['tags'][tagName]
							selectedTags << {:name => tagName, :tag => @library['tags'][tagName], :union => isUnionTag}
							if isUnionTag
								unionTagTracks += @library['tags'][tagName]['tracks'];
							end
						else
							@library['tags'].each { |name, libraryTag|
								if libraryTag['aliases']
									libraryTag['aliases'].each { |tagAlias|
										if tagAlias == tagName
											selectedTags << {:name => name, :tag => libraryTag, :union => isUnionTag}
											if isUnionTag
												unionTagTracks += @library['tags'][tagName]['tracks'];
											end
										end
									}
								end
							}
						end
					}

					if selectedTags.length > 0
						# TODO: make a list of IDs and filter tracks against it once, rather than filtering separately for each tag
						selectedTags.each { |tagInfo|
							foundTagName = "\"#{tagInfo[:name]}\""
							if tagInfo[:tag]['aliases'] && tagInfo[:tag]['aliases'].length > 0
								foundTagName = "#{foundTagName} (aliases \"#{tagInfo[:tag]['aliases'].join '", "'}\")"
							end
							tracks.send(action) { |t| tagInfo[:tag]['tracks'].index(t['id']) || unionTagTracks.index(t['id']) }
						}

						if unionTagTracks.length > 0
							tracks.sort! { |a, b| unionTagTracks.count(b['id']) <=> unionTagTracks.count(a['id']) }
						end
					else
						puts "No matches for \"#{filters['tag']}\". Available tags are: #{listAllTagsWithAliases.join ", "}"
					end
				else
					@library['tags'].each { |name, libraryTag|
						tracks.send(action) { |t|
							libraryTag['tracks'].index(t['id'])
						}
					}
				end
			end

			if filters.has_key? 'bpm'
				if filters['bpm'] && filters['bpm'].length > 0
					tracks.send(action) { |t|
						matchPropertyWithRangeString filters['bpm'], t, 'bpm'
					}
				else
					tracks.send(action) { |t| t.has_key? 'bpm' }
				end
			end

			if filters['title']
				matches = fuzzyStringSearchInList(filters['title'], getTrackTitles(tracks))
				matches.sort! { |a,b| b[:density] <=> a[:density] }
				matchedIds = []
				matchesByTrackTitle = {}
				matches.each { |match|
					track = tracks[match[:index]]
					matchedIds << track['id']
					matchesByTrackTitle[track['title']] = match
				}
				tracks.send(action) { |t| matchedIds.include? t['id'] }
				if !isExcludeFilter
					tracks.sort! { |a,b| matchesByTrackTitle[b['title']][:density] <=> matchesByTrackTitle[a['title']][:density] }
				end
			end

			if filters['last']
				now = Time.now.to_i
				watershed = now - getSecondsFromDurationString(filters['last']).to_i
				tracks.send(action) { |t|
					t['lastPlayed'] ? t['lastPlayed'].to_i >= watershed : false
				}
			end

			if filters['min-duration']
				minDuration = getSecondsFromDurationString filters['min-duration']
				tracks.send(action) { |t|
					t['duration'] ? getSecondsFromDurationString(t['duration']) > minDuration : false
				}
			end

			if filters.has_key? 'ab'
				tracks.send(action) { |track|
					if track
						track.has_key? 'loop'
					else
						false
					end
				}
			end

			if filters.has_key? 'chapters'
				tracks.send(action) { |track|
					if track
						track.has_key? 'chapters'
					else
						false
					end
				}
			end

			puts "#{tracks.length} matches for filters"

			tracks
		end

		def listAllTagsWithAliases
			allTagNames = []

			@library['tags'].each { |name, libraryTag|
				allTagNames << name
				if libraryTag['aliases']
					libraryTag['aliases'].each { |tagAlias| allTagNames << tagAlias }
				end
			}

			allTagNames.sort
		end

		def createPlaylist name, tracks = [], description = ''
			newPlaylist = {
				'description' => description,
				'public' => true,
				'tracks' => tracks
			}
			@library['playlists'][name] = newPlaylist
		end

		def createTrack url, type = 'youtube'
			if type == 'youtube'
				src = looksLikeAYouTubeID?(url) ? url : getYoutubeIdFromUrl(url)
				id = src
			elsif type == 'ocremix'
				src = getOCRemixSource url
				id = getIDFromOCRemixURL url
			end
			{
				'id' => id,
				'type' => type,
				'src' => src,
				'unattached' => true
			}
		end

		def getTrackInfo id
			track = {
				'id' => id
			}
			if @noNetwork
				puts "no getTrackInfo --no-network"
				return track
			end
			json = `youtube-dl -j -- #{id} 2>/dev/null` # suppress errors
			return track if !json || json.length == 0

			trackInfo = JSON.parse(json)
			track['title'] = trackInfo['fulltitle']
			track['duration'] = getDurationStringFromSeconds(trackInfo['duration'])
			track['description'] = trackInfo['description']
			track['url'] = trackInfo['webpage_url']
			track['type'] = trackInfo['extractor']
			track['sourceTags'] = trackInfo['tags'] if trackInfo['tags']
			whisper "sourceTags: #{trackInfo['tags']}", 4

			track
		end

		def updateTrackInfo track, trackInfo = nil, force = false
			trackInfo ||= getTrackInfo track['id']
			return track if !trackInfo

			track['title'] = trackInfo['title'] if (!track['title'] || force) && trackInfo['title'] && trackInfo['title'].length > 0

			if (!track['description'] || force) && trackInfo['description'] && trackInfo['description'].length > 0
				if !track['chapters'] || force
					chapters = getChaptersFromDescription trackInfo['description'].lines
					track['chapters'] = chapters if chapters && chapters.length > 0
				end
			end

			track['duration'] = trackInfo['duration'] if trackInfo['duration']
			track['url'] = trackInfo['url'] if trackInfo['url']
			track['type'] = trackInfo['type'] if  trackInfo['type']

			track
		end

		def getChaptersFromDescription description
			description.grep(/[0-9]+:[0-9:.]+/).map! do |line|
				matches = line.match(/^(.*?)[ (]*([0-9]+:[0-9:.]+)[ )]*(.*)$/)
				{
					'time' => matches[2],
					'name' => "#{matches[1]} #{matches[3]}".gsub(/^[^0-z]/, '').strip
				}
			end
		end

		def addTrackToLibrary track
			track.delete 'unattached' if track.has_key? 'unattached'
			trackReference = track['id']
			track['dateAdded'] = Time.now.to_i
			@library['library'][trackReference] ||= track

			trackReference
		end

		def addTrackReferenceToPlaylist trackReference, playlistName
			playlistTracks = @library['playlists'][playlistName]['tracks']
			track = @library['library'][trackReference]

			if not playlistTracks.include? trackReference
				playlistTracks << trackReference
				puts "Saved '#{track['title']}' (#{trackReference}) to playlist '#{playlistName}'"
			else
				puts "Track '#{track['title']}' (#{trackReference}) is already in playlist '#{playlistName}'"
			end
		end

		##
		# YouTube Methods
		##

		def looksLikeAYouTubeID? string
			youtubeIdPattern = /^[A-Za-z0-9_-]+$/
			!! string.match(youtubeIdPattern)
		end

		def getYoutubeIdFromUrl url
			youtubeIDInURLPattern = /^.*youtu(\.be\/|be\.com.*v=)([^&\/]+)/
			matches = url.match(youtubeIDInURLPattern)
			matches ? matches[2] : false
		end

		def searchYouTube query, offset = 0, count = 20
			# FIXME: sometimes the STDIN is not editable after this
			puts "Searching YouTube for '#{query}'"
			resultsPerPage = 20
			page = (offset.to_f / resultsPerPage.to_f).to_i + 1
			queryParameter = URI::encode(query)
			queryUrl="https://www.youtube.com/results?search_query=#{queryParameter}&page=#{page}"
			getYouTubeTracksFromPage queryUrl
		end

		def getValidYouTubeURI uri
			looksLikeAYouTubeID?(uri) ? "https://www.youtube.com/watch?v=#{uri}" : uri
		end

		def getYouTubeTracksFromPage url
			if @noNetwork
				puts "no getYouTubeTracksFromPage --no-network"
				return false
			end
			url = getValidYouTubeURI url
			queryResultIds = []
			whisper "reading URL #{url}", 2
			open(url) do |handle|
				whisper "received URL #{url}", 4
				html = []
				handle.each_line { |line| html << line }

				queryResultIds = html.grep(/href="(.*youtube.*)?\/watch/).map! do |line|
					line.sub!(/^.*watch\?v=([^\"&<]+).*\n/, '\1')
				end

				queryResultIds.uniq!
			end

			threads = []
			resultTracks = []
			receivedCount = 0
			printRepeat "Getting track information (#{receivedCount}/#{queryResultIds.length})"

			queryResultIds.each_with_index do |id, index|
				track = matchExistingLibraryTrack createTrack id, 'youtube'
				resultTracks << track
				whisper "starting a new thread to get track info for #{track['id']}", 4
				threads << Thread.new {
					if not updateTrackInfo track
						resultTracks.delete track
					end
					receivedCount += 1
					printRepeat "Getting track information (#{receivedCount}/#{queryResultIds.length})"
				}
			end

			whisper "joining 'update info' threads", 4
			threads.each { |thr| thr.join }
			print "\n"

			resultTracks
		end

		def getOCRemixSource(url)
			source = nil
			if @noNetwork
				puts "no getOCRemixSource --no-network"
				return false
			end

			open(url) do |handle|
				sourcePattern = /^.*href="(https?:\/\/ocrmirror.org[^"]+)".*$/
				sourceLine = handle.lines.grep(sourcePattern)
				if sourceLine && sourceLine.length > 0
					match = sourceLine[0].match sourcePattern
					source = match[1]
					whisper "source: #{source}", 4
				end
			end

			source
		end

		def getIDFromOCRemixURL(url)
			url.sub(/^.*\/remix\/([^\/?]+).*/, '\1')
		end

		##
		# Utility Methods
		##

		def getDurationStringFromSeconds inputSeconds
			inputSeconds = inputSeconds.to_i
			seconds = inputSeconds % 60
			minutes = inputSeconds / 60 % 60
			hours = inputSeconds / 3600 % 24
			days = inputSeconds / 86400

			outputString = ''
			outputString += "#{days}" if days > 0
			outputString += ":#{hours < 10 ? "0#{hours}" : hours}" if hours > 0
			outputString += ":#{minutes < 10 ? "0#{minutes}" : minutes}"
			outputString += ":#{seconds < 10 ? "0#{seconds}" : seconds}"
			outputString.sub(/^:/, '')
		end

		def getSecondsFromDurationString durationString
			seconds = 0
			factor = 1
			factors = [1,60,60,24]

			whisper "getting seconds from duration string: '#{durationString}'", 5
			if durationString && durationString.length > 0
				durationString.split(':').reverse.each_with_index { |unit, index|
					whisper "unit: '#{unit}', index: '#{index}'", 5
					factor *= factors[index]
					seconds += unit.to_f * factor
				}
			end

			seconds
		end

		##
		# UI Methods
		##

		def parseOptions
			output = {}

			parser = OptionParser.new

			parser.on("-a", "--add-track YOUTUBE_URLS", "Add tracks to the library, and to a playlist, if specified. Takes a comma-separated list of YouTube URLs or IDs.", " ") do |urls|
				output[:newTracks] = getTracksFromURLs urls.split(',')
			end

			parser.on("-c", "--clean", "Enter an interactive cleanup mode, to remove unwanted items from the library.", " ") do
				output[:interactiveCleanup] = true
			end

			parser.on("-d", "--[keep-]download", "Enable downloading files when encountering a playlist file without a cached file already download.", "Files not added to the library will be deleted after playback, unless --keep-download is used.", " ") do |keep|
				@enableDownload = true
				@keepUnattachedDownload = keep
			end

			parser.on("-f", "--filter RULES", Player::FILTER_HELP_1, Player::FILTER_HELP_2, Player::FILTER_HELP_3, " ") do |rules|
				@trackFilters = parseOptionParameters rules
			end

			parser.on("-h", "--help", "Show this help.", " ") do
				puts parser.help()
				exit
			end

			parser.on("-l", "--loop", "Loop, even if a track doesn't have an A/B loop defined.", " ") do
				@loop = true
			end

			parser.on("-p", "--playlist [NAME]", "Choose or create a playlist. If no NAME/QUERY is given, a name is guessed from other input, such as a -q query", " ") do |playlistQuery|
				output[:playlistQuery] = playlistQuery
			end

			parser.on("-q", "--query QUERY", "Search YouTube for a video.", " ") do |query|
				@youtubeSearch = query
			end

			parser.on("-r", "--rating-prompt [SECONDS]", "Prompt for a rating and tags after every track plays, waiting 5 (or the number given) seconds before continuing to the next track", " ") do |seconds|
				@ratingsPromptDuration = seconds ? seconds.to_i : 5
			end

			parser.on("-s", "--shuffle", "Enable shuffle.", " ") do
				@shuffle = true
			end

			parser.on("-t", "--track INDEX/QUERY", "Seek to the given track (either by its number in the list, or by its name).", " ") do |trackQuery|
				if trackQuery.to_i != 0
					@trackIndex = trackQuery.to_i - 1
				else
					@trackIndex = findTrackIndex(trackQuery) || nil
					puts "@trackIndex: #{@trackIndex}" # XXX
				end
			end

			parser.on("-v [LEVEL]", "--verbose", "Chatter about what's going on (more detailed or frequent messages are in levels 2 or 3.", " ") do |level|
				@configuredVerbosity = level ? level.to_i : 1
				whisper "Verbosity level: #{@configuredVerbosity}", 1
			end

			parser.on("-w", "--write [SECONDS]", "Save changes to the library. If SECONDS are given, only tracks played that many seconds will be written.", " ") do |seconds|
				@writeEnabled = true
				@writeAfterSecondsPlayed = seconds ? seconds.to_f : 0.0
			end

			parser.on("-x", "--exclude-filter RULES", "Excludes tracks matching the rules. See --filter", " ") do |rules|
				@trackExcludeFilters = parseOptionParameters rules
			end

			parser.on("--input-dir DIR", "Directory from which to read the playlist and files.", "NOTE: when used, this must be the first option. Recommended to define TUNEWICH_DIR instead.", " ") do |inputDir|
				# FIXME: always process this option first, even if it's provided last
				setLibraryPath inputDir
			end

			parser.on("--no-network", "Don't fetch any information or media from the internet. Use only local files.", " ") do
				@noNetwork = true
				@trackFilters ||= {}
				@trackFilters['local'] = ''
			end

			parser.on("--format FORMAT", "Set the file format to request for streaming or downloading.", " ") do |format|
				@preferredFileFormat = format
			end

			parser.on("--update-track-info", "Fetch updated track information for every track played.", " ") do
				@updateAllPlayedTrackInfo = true
			end

			parser.on("--player-opts OPTIONS", "Set player options. Set interactively with the /player command.", " ") do |options|
				# TODO: ruby probably has an easier way of getting an element index in an Array#map block
				isFirstElement = true
				@playerOverrideCommands += options.split(' -').map { |option|
					if isFirstElement
						isFirstElement = false
					else
						option = "-#{option}"
					end
					option
				}
			end

			parser.on("--radio", "TODO: stream to a network radio service", " ") do
				serviceConfigDir = "#{File.dirname(__FILE__)}/config"
				isGoodToBeginServingRadio = true
				if UNAME == "Darwin"
					audioDevice = "coreaudio"
					audioDeviceID = `say -a ? | grep 'Soundflower (2ch)' | perl -pe 's/^\s+(\d+).*$/$1/'`
					if audioDeviceID && audioDeviceID.length > 0
						icecastConfigFile = "#{serviceConfigDir}/icecast.xml"
						darkiceConfigFile = "#{serviceConfigDir}/darkice.cfg"

						if not File.exist? icecastConfigFile
							puts "Please create the icecast config file at #{icecastConfigFile}."
							isGoodToBeginServingRadio = false
						elsif not File.exist? darkiceConfigFile
							puts "Please create the darkice config file at #{darkiceConfigFile}."
							isGoodToBeginServingRadio = false
						end
					else
						puts "Please install Soundflower (https://github.com/mattingalls/Soundflower)"
						isGoodToBeginServingRadio = false
					end
				else
					isGoodToBeginServingRadio = false
					puts "Radio is currently only implemented on Mac. Want to help fix it for other platforms? Get in touch!"
				end

				if isGoodToBeginServingRadio
					@services = []
					@services << Thread.new { `jackd -d #{audioDevice}` }
					@services << Thread.new { `icecast -c "#{icecastConfigFile}` }
					@services << Thread.new { `darkice -v 10 -c "#{darkiceConfigFile}"` }
					@playerOverrideCommands << "-ao #{audioDevice}:device_id=#{audioDeviceID}"
				end
			end

			unparsedOptions = parser.parse(ARGV)
			whisper "unparsed options: #{unparsedOptions}", 4

			output
		end

		def doOptionSecondaryActions optionsOutput

			if not @fileDirectory
				puts "please specify an input directory with -i"
				exit
			end

			if @youtubeSearch && !@noNetwork
				@youtubeSearchPage = 1
				searchedTracks = searchYouTube @youtubeSearch
				useTracks searchedTracks if searchedTracks
			end

			if optionsOutput.has_key? :interactiveCleanup
				interactiveCleanup
				exit
			end

			if optionsOutput.has_key? :playlistQuery
				if optionsOutput[:playlistQuery]
					match = firstFuzzyMatch optionsOutput[:playlistQuery], @library['playlists'].keys

					if match && match[:score] > 1 # FIXME: what's a good baseline score for a playlist match?
						playlistName = match[:value]
					elsif confirm("Create new playlist #{optionsOutput[:playlistQuery]}?")
						playlistName = optionsOutput[:playlistQuery]
					end
				elsif @youtubeSearch
					playlistName = @youtubeSearch
				end

				if playlistName
					if not @library['playlists'].has_key? playlistName
						puts "Creating new playlist: #{playlistName}"
						createPlaylist playlistName
						writeLibraryToFile
					end

					usePlaylist playlistName, true
				end
			end

			if optionsOutput.has_key? :newTracks
				optionsOutput[:newTracks].each { |newTrack|
					if 0 == @writeAfterSecondsPlayed
						trackReference = addTrackToLibrary newTrack
						addTrackReferenceToPlaylist trackReference, @playlistName if @playlistName
					end
					@tracks << newTrack
				}
				writeLibraryToFile false
			end
		end

		def getTracksFromURLs(urls)
			tracks = []

			urls.split(',').each { |url|
				if url.match(/ocremix\.org\/remix/)
					tracks << matchExistingLibraryTrack(createTrack(url, 'ocremix'))
					puts "This URL contains an OC Remix ID. Adding."
				elsif looksLikeAYouTubeID? url
					youtubeId = url
				else
					youtubeId = getYoutubeIdFromUrl url
				end

				if youtubeId
					tracks << updateTrackInfo(matchExistingLibraryTrack(createTrack(youtubeId, 'youtube')))
					puts "This URL contains a YouTube ID. Adding."
				end

				if confirm "Look for all tracks on this page?"
					youTubeTracks = getYouTubeTracksFromPage url
					tracks.concat youTubeTracks if youTubeTracks
				end
			}

			tracks
		end

		def encodeOptionParameters hash
			clumps = []
			hash.each { |key, value|
				clumps << "#{key}=#{value}"
			}
			clumps.join ','
		end

		def parseOptionParameters serialized
			hash = {}
			# TODO: parse normal & negated options from one list
			# hash = {
			# 	:normal => [],
			# 	:negate => []
			# }

			serialized.split(',').each { |clump|
				pair = clump.split '='
				hash[pair[0]] = pair[1]
			}

			hash
		end

		def printRepeat message, shouldReturnCursorToBeginning = false
			message = message.to_s if message.respond_to? 'to_s'
			outputMessage = "  #{message}"
			shellColumnWidth = (`tput cols` || 80).to_i
			if outputMessage.length > shellColumnWidth
				outputMessage = "#{outputMessage[0,shellColumnWidth - 3]}..."
			end
			print "\r#{outputMessage}#{$clearLineCharacter}"
			print "\r" if shouldReturnCursorToBeginning
		end

		def cliRotate
			if not @cliRotateIndex
				@cliRotateIndex = 0
				@cliRotateCharacters = ['==', '\\\\', '||', '//']
			else
				@cliRotateIndex = (@cliRotateIndex + 1) % @cliRotateCharacters.length
			end

			@cliRotateCharacters[@cliRotateIndex]
		end

		def editListInVim list, instructions = nil
			instructions ||= "edit"
			fileDirections = "##\n#{instructions.gsub(/^/, '# ')}\n##"

			editListName = 'edit-list'
			deleteTempFile editListName
			putInTempFile editListName, list.join("\n") + "\n\n" + fileDirections

			system "vim #{getTempFilePath editListName}"

			list = readTempFile(editListName).strip.lines
			list.map! { |line|
				line.sub(/\n/, '')
			}
			list.delete_if { |line| # remove empty and comment lines from the list
				line.match(/^(#.*|\s*)$/)
			}

			deleteTempFile editListName

			whisper list, 4

			list
		end

		def commandPrompt message = nil, commands = nil, action = nil
			scopedShouldShowRealtimeOutput = @shouldShowRealtimeOutput
			whisper "opening command prompt", 2
			if commands
				commands['?'] = {
					'description' => 'show this info',
					'action' => Proc.new {
						commandInfo = []
						maxCommandNameLength = 0
						sortedCommandList = []
						commands.each { |name, command|
							sortedCommandList << {:name => name, :command => command}
							maxCommandNameLength = name.length if name.length > maxCommandNameLength
						}
						sortedCommandList.sort! { |a,b| a[:name] <=> b[:name] }
						sortedCommandList.each { |commandMeta|
							info = "/#{commandMeta[:name]}"
							info += " " * (maxCommandNameLength - info.length + 1)
							info += " : #{commandMeta[:command]['description']}" if commandMeta[:command]['description']
							commandInfo << info
						}
						puts commandInfo.join "\n"
					}
				}
			end

			prompt = Proc.new {
				print "#{message} " if message
				print "$ "
			}
			prompt.call

			output = Proc.new { |message|
				print "\n#{message}\n"
			}

			response = {
				:input => nil,
				:commands => []
			}

			whisper "waiting for user input on STDIN", 3
			input = nil
			while inputCharacter = STDIN.getch
				if inputCharacter == "" # control-c character
					whisper "interrupt character, is that you?", 3
					@shouldShowRealtimeOutput = scopedShouldShowRealtimeOutput
					break
				elsif inputCharacter == "" # backspace
					if input
						input = input[0,input.length - 1]
						printRepeat input
					end
				elsif inputCharacter == "" # clear line
					if input
						input = ''
						printRepeat input
					end
				elsif /[\n\r]/.match inputCharacter
					response[:input] = input
					whisper "received input: #{input}", 3
					if commands
						while input && !input.empty? && input[0] == '/'
							whisper "parsing commands", 3
							commandParts = input.match(/^\/([^\s]*)\s*(.*)/)
							if commandParts
								commandName = commandParts[1]
								commandInput = commandParts[2]
								whisper "commandName: #{commandName}, commandInput: #{commandInput}", 3

								if !commands.has_key? commandName
									possibleCommands = []
									commands.each { |name, command|
										if name.start_with? commandName
											possibleCommands << name
										end
									}
									if possibleCommands.length == 1
										whisper "commandName: #{commandName} => #{possibleCommands[0]}"
										commandName = possibleCommands[0]
									else
										commandName = ''
										input = nil
										output.call "Did you mean #{possibleCommands.join ", or "}?" if possibleCommands.length > 1
									end
								end
							else
								commandName = ''
							end

							if commands.has_key? commandName
								commandInfo = {
									:name => commandName,
									:input => commandInput,
									:output => commands[commandName]['action'].call(commandInput, output)
								}
								response[:commands] << commandInfo
								whisper "command info: #{commandInfo}", 3
								if commandInfo[:output][:action]
									whisper "chained command calling action (#{commandInfo[:output][:action]})", 3
									action.call commandInfo[:output][:action]
								end
								if commandInfo[:output] && commandInfo[:output][:chainedInput] && commandInfo[:output][:chainedInput].length > 0
									whisper "chained input: #{commandInfo[:output][:chainedInput]}", 3
									input = commandInfo[:output][:chainedInput]
								else
									whisper "no chained input", 3
									input = nil
									break
								end
							end
						end
						whisper "no more commands to execute", 3
					end

					@shouldShowRealtimeOutput = scopedShouldShowRealtimeOutput

					if action && input && input.length > 0
						whisper "input left over after commands: passing to action (#{input})", 3
						action.call input
					end

					input = nil
					prompt.call
				else
					if not input
						input = ''
						@shouldShowRealtimeOutput = false
					end
					input += inputCharacter
					printRepeat input
				end
			end
			@shouldShowRealtimeOutput = scopedShouldShowRealtimeOutput

			whisper "closing command prompt (response #{response})", 3

			response
		end

		def confirm message, commands = nil
			confirmMessage = "#{message} (y/N): "
			confirmed = false
			confirmAction = Proc.new { |input|
				confirmed = input.match(/^[Yy]/)
				!input
			}
			commandResponse = commandPrompt(confirmMessage, commands, confirmAction)
			confirmed
		end

		def promptForPlaylist
			puts "Please choose a playlist (leave blank to play all):\n  #{@library['playlists'].keys.join "\n  "}"
			selectedListName = nil
			while !selectedListName do
				playlistQuery = commandPrompt[:input]

				if not playlistQuery or playlistQuery.length === 0
					useEntireLibrary
					break
				end

				selectedListName = findPlaylistName playlistQuery

				if not selectedListName
					puts "No matches. Try again"
				end

			end

			selectedListName
		end

		def promptForChapterIndex chapters, commands = nil, message = nil
			whisper "prompting for chapter selection", 3
			selectedChapterIndex = nil

			chapterList = chapters.map { |chapter| "#{chapter['time']} - #{chapter['name']}" }
			prePromptMessage = "  #{chapterList.join "\n  "}"
			prePromptMessage += "\n#{message}" if message
			promptMessage = "Please choose a chapter (leave blank to play first):"

			while not selectedChapterIndex do
				puts prePromptMessage
				chapterQuery = commandPrompt(promptMessage, commands)[:input]
				break if not chapterQuery or chapterQuery.length === 0

				selectedChapter = firstFuzzyMatch chapterQuery, chapterList

				if selectedChapter
					selectedChapterIndex = selectedChapter[:index]
					break
				else
					puts "No matches. Try again."
				end

			end

			whisper "Selected chapter #{selectedChapterIndex}", 4

			{
				:index => selectedChapterIndex
			}
		end

		def listTrackTitles(tracks)
			tracks.map { |t| "#{t['title']} [#{t['id']}]" }
		end

		def getTracksFromTitleList(titleList)
			tracks = []
			titleList.each { |line|
				matches = line.match(/^(.*) \[(.*)\]$/)
				if matches
					track = matchExistingLibraryTrack createTrack matches[2], 'youtube'
					track['title'] ||= matches[1]
					tracks << track if track
				end
			}

			tracks
		end

		def cloneTracks inputTracks
			tracks = []
			inputTracks.each { |id, t| tracks <<  t }
			tracks
		end

		def cloneLibraryToTracks inputLibrary
			tracks = []
			inputLibrary.each { |id, t| tracks << t }
			tracks
		end

		def cloneLibrary inputLibrary
			library = {}
			inputLibrary.each { |id, t| library[t['id']] = t }
			library
		end

		def cloneTracksToLibrary inputTracks
			library = {}
			inputTracks.each { |t| library[t['id']] = t }
			library
		end

	end

end

Tunewich::Player.new
