#!/usr/bin/env ruby

require "open-uri"
require "optparse"
require "json"
require "digest"

module Tunewich

	class UI

	end

	class Library

	end

	class Playlist

	end

	class YouTubeClient

	end

	class Player

		PROMPT_TIMEOUT_RESPONSE = 'prompt_timeout_response'
		CHAPTER_SELECT_TIMEOUT = 15
		FILTER_HELP_1 = "Filter tracks by rules, in the format 'key=value,key=value 2,key'."
		FILTER_HELP_2 = "Available rules are: [min-,max-]rating=<#0-5>,title=<query>,tag=<tag>,chapters,last=<[[[DD:]HH:]MM:]SS>."
		TAG_INPUT_SPLIT = /[,\s]+/

		def initialize
			@library = nil
			@libraryHash = nil
			@sessionID = Random.rand(1024)
			@trackIndex = nil
			@tracks = []
			@trackFilters = nil
			@trackExcludeFilters = nil
			@noNetwork = false
			@playlistName = nil
			@enableDownload = false
			@keepUnattachedDownload = false

			getEnvironmentConfig

			doOptionSecondaryActions parseOptions

			interactivePlayback
		end

		private

		def getEnvironmentConfig
			if ENV.key? 'TUNEWICH_MPLAYER_OPTS'
				@mplayerDefaultOptions = ENV['TUNEWICH_MPLAYER_OPTS']
			else
				puts "You can add `export TUNEWICH_MPLAYER_OPTS=\"<mplayer options>\"` to your ~/.profile or similar file."
			end

			if ENV.key? 'TUNEWICH_DIR'
				setLibraryPath ENV['TUNEWICH_DIR']
			else
				puts "Please add `export TUNEWICH_DIR=\"<path/to/your/music/directory>\"` to your ~/.profile or similar file."
			end
		end

		def interactivePlayback
			if @tracks && @tracks.length > 0
				titleBlock "Playing #{@tracks.length} tracks", '#'
			else
				if selectedListName = promptForPlaylist
					usePlaylist selectedListName
					titleBlock "Playlist: #{@playlistName} (#{@tracks.length})", '#'
				end
			end

			if @trackIndex == nil
				if @shuffle
					shuffleIndex()
				else
					@trackIndex = 0
				end
			elsif @trackIndex.is_a? String and @trackIndex != '0'
				@trackIndex = findTrackIndex @trackIndex
			else
				@trackIndex = @trackIndex.to_i
			end

			# TODO: catch SIGINT (ctrl+c) & prompt for playlist again
			playerOutput = nil
			commandRequiresBreak = false
			commandRequiresNext = false

			interactiveCommands = {
				'quit' => {
					'action' => Proc.new {
						puts "quitting..."
						commandRequiresBreak = true
					}
				},
				'skip' => {
					'action' => Proc.new {
						puts "skipping..."
						nextTrack()
						commandRequiresNext = true
					}
				},
				'loop' => {
					'action' => Proc.new {
						@loop = !@loop
						puts "loop: #{@loop ? 'on' : 'off'}"
					}
				},
				'shuffle' => {
					'action' => Proc.new {
						@shuffle = !@shuffle
						puts "shuffle: #{@shuffle ? 'on' : 'off'}"
					}
				}
			}

			track = nil

			while not playerOutput or playerOutput[:exit] do
				break if !@trackIndex || !@tracks[@trackIndex]

				track = @tracks[@trackIndex]

				titleBlock "[#{@trackIndex + 1}] - #{track['title']}"

				changesToWrite = false

				if @updateAllPlayedTrackInfo && !@noNetwork
					printRepeat "Getting latest track information..."
					updateTrackInfo track
					changesToWrite = true
				end

				fileExists = trackFileExists? track

				if !fileExists && @noNetwork
					next
				end

				chapterIndex = nil

				if track['chapters']
					commandRequiresBreak = false
					commandRequiresNext = false

					chapterPromptMessage = nil

					if !fileExists && !@enableDownload # TODO: checking fileExists, and checking again inside self.play
						chapterPromptMessage = "NOTE: Choosing a chapter will cause the file to download fully before playing."
					end

					chapterResponse = promptForChapterIndex track['chapters'], interactiveCommands, chapterPromptMessage
					chapterIndex = chapterResponse[:index]

					next if commandRequiresNext
					break if commandRequiresBreak
				end

				# TODO: catch C-t, or something like it, to pass commands to the script during playback
				#  -: rating down
				#  +: rating up
				#  1-5: explicit rating
				#  t: prompt for tag
				#  x: remove from library
				#  d: download
				playerOutput = play track, chapterIndex

				if playerOutput
					if (@playthroughThreshold && playerOutput[:playtime] > @playthroughThreshold)
						puts "Played more than #{@playthroughThreshold}s, saving to library."
						loadLibrary
						track = matchExistingLibraryTrack track
						track['played'] = Time.now.to_i
						trackReference = addTrackToLibrary track
						addTrackReferenceToPlaylist trackReference, @playlistName if @playlistName
						changesToWrite = true
					end

					if !track['unattached'] && @ratingsPromptDuration
						input = timedTextPrompt @ratingsPromptDuration, "rating/tags (#{track['rating']}): "

						if input && input.length
							tags = []
							new_rating = nil
							input.split(Player::TAG_INPUT_SPLIT).each { |chunk|
								if chunk.match(/^\d+$/) # is numeric
									new_rating = chunk.to_i
								else
									tags << chunk
								end
							}

							if new_rating
								track['rating'] = new_rating
								@tracks[@trackIndex] = track # FIXME: set up @tracks to reference @library
								changesToWrite = true
							end

							if tags.length
								addTrackToTags track, tags
								changesToWrite = true
							end
						end
					end
				end

				writeLibraryToFile if changesToWrite # uncomment

				filterTracksOnDeck

				nextTrack() if not chapterIndex # if a chapter was selected, prompt again in the next iteration
			end
		end

		def findTag(query)
			tag = nil

			if @library['tags'][query]
				tag = @library['tags'][query]
			else
				@library['tags'].each { |name, t|
					tag = t if t['aliases'].include? query
				}
			end

			tag
		end

		def addTrackToTags(track, tagNames)
			tagNames.each { |tagName|
				matchingTag = findTag tagName
				matchingTag ||= createTag tagName
				matchingTag['tracks'] << track['id']
				matchingTag['tracks'].uniq!
			}
		end

		def combineTags(tagNames)
			firstTag = findTag tagNames.shift

			if firstTag
				tagNames.each { |tagName|
					tag = findTag tagName
					if tag && tag != firstTag
						firstTag['aliases'] << tagName
						firstTag['tracks'].concat tag['tracks']
						deleteTag tagName
					end
				}

				firstTag['aliases'].uniq!
				firstTag['tracks'].uniq!
			end

			firstTag
		end

		def createTag(tagName)
			@library['tags'][tagName] = {
				'aliases' => [],
				'tracks' => []
			}

			@library['tags'][tagName]
		end

		def deleteTag(tagName)
			@library['tags'].delete tagName if @library['tags'][tagName]
		end

		def play(track, chapterIndex)
			response = {
				:exit => true,
				:playtime => 0
			}
			mplayerCommands = []
			fileAlreadyExists = trackFileExists? track
			streaming = !fileAlreadyExists && !@enableDownload && !chapterIndex

			if @noNetwork && !fileAlreadyExists
				puts "No local file to play: #{track['title']}"
				return response
			end

			if track['chapters']

				if chapterIndex

					if not streaming
						titleBlock "Chapter #{chapterIndex + 1}: #{track['chapters'][chapterIndex]['name']}"
						offsetSeconds = getSecondsFromDurationString track['chapters'][chapterIndex]['time']
						mplayerCommands << "-ss #{offsetSeconds}"

						if chapterIndex < track['chapters'].length - 1
							nextTrackoffsetSeconds = getSecondsFromDurationString track['chapters'][chapterIndex + 1]['time']
							mplayerCommands << "-endpos #{nextTrackoffsetSeconds - offsetSeconds}"
						end

					else
						titleBlock "This track has chapters, but seeking backward is not supported while streaming. Add the -d option to enable downloading."
					end

				else
					titleBlock "Playing all chapters in track"
				end

			elsif track['loop'].kind_of?(Array)

				if not streaming
					duration = track['loop'][1] - track['loop'][0]

					mplayerInputFile = putInTempFile 'mplayer-input', "seek -999:00:00\n" # this is a silly way to do it. -100% doesn't work. Still, there's a moment of the audio heard before this command is run.
					mplayerCommands << "-input file=#{mplayerInputFile}"

					# loop back from B to A
					mplayerCommands << "-ss #{track['loop'][0]}"
					mplayerCommands << "-endpos #{duration}"
				else
					titleBlock "This track has an A/B loop, but looping is not supported while streaming. Add the -d option to enable downloading."
				end

			end

			if fileAlreadyExists
        mediaFilePath = firstTrackFile track
      else
				if streaming
					streamName = 'youtube-stream'
					streamPath = mediaFilePath = makeStream streamName
				end

				if not downloadTrack track, streamPath
					return response
				end
			end

			if not mediaFilePath
				puts "File not found for #{track['title']}."
				return false
			end

			if !streamName
				mplayerCommands << "-loop 0" if track['loop'] or @loop
			end

			mplayerCommands += [@mplayerDefaultOptions] if @mplayerDefaultOptions
			mplayerCommands += @mplayerOverrideCommands

			if track['volume']
				mplayerCurrentVolume = 25.0
				mplayerCommands.each { |command|
					if command.include? 'volume'
						mplayerCurrentVolume = command.match(/.*-volume ([0-9]+)$/)[1].to_f
					end
				}
				mplayerCommands += ["-volume #{(mplayerCurrentVolume / track['volume']).round}"]
			end

			mplayerStartTime = Time.now.to_f

			mplayerStatus = system "mplayer \"#{mediaFilePath}\" #{mplayerCommands.join ' '}"

			mplayerEndTime = Time.now.to_f

			mplayerPlayTime = mplayerEndTime - mplayerStartTime

			if streaming
				deleteStream streamName
			elsif !fileAlreadyExists && track['unattached'] && !@keepUnattachedDownload
				deleteFileById track['id']
				titleBlock "UNATTACHED DOWNLOAD DELETED", 'X'
			end

			deleteTempFile 'mplayer-input' if mplayerInputFile

			response[:exit] = mplayerStatus
			response[:playtime] = mplayerPlayTime
			response
		end

		def nextTrack
			if @shuffle
				shuffleIndex()
			else
				@trackIndex += 1

				if @trackIndex > @tracks.length - 1

					if @youtubeSearchPage && !@noNetwork
						@youtubeSearchPage += 1
						useTracks searchYouTube(@youtubeSearch, (@youtubeSearchPage - 1) * 20)
					else
						@trackIndex %= @tracks.length
					end

				end

			end
		end

		def clearTracks
			@tracks = []
		end

		def useTracks tracks
			@tracks += tracks
			filterTracksOnDeck
		end

		def filterTracksOnDeck
			if @trackFilters
				@tracks = filterTracks @tracks, @trackFilters
			end

			if @trackExcludeFilters
				@tracks = filterTracks @tracks, @trackExcludeFilters, true
			end
		end

		def shuffleIndex
			@trackIndex = Random.rand(@tracks.length - 1) if @tracks.length > 1
		end

		def setLibraryPath libraryPath
			@tunewichDirectory = libraryPath
			if not Dir.exist? @tunewichDirectory
				puts "Please create the directory '#{@tunewichDirectory}'."
				exit
			end

			@fileDirectory = "#{@tunewichDirectory}/music"
			Dir.mkdir @fileDirectory if not Dir.exist? @fileDirectory

			@libraryFilePath = "#{@tunewichDirectory}/tunewich-library.json"
			if not File.exist? @libraryFilePath
				raise "TODO: create library file at #{@libraryFilePath}"
			end

			loadLibrary
		end

		def matchExistingLibraryTrack track
			@library['library'].each { |id, t|
				if t['src'] === track['src']
					track = t
					break
				end
			}
			track
		end

		def getTrackTitles tracks
			tracks.map{|t| t['title']}
		end

		def findTrackIndex(query)
			match = firstFuzzyMatch query, getTrackTitles(@tracks)
			match ? match[:index] : false
		end

		def findPlaylistName(query)
			match = firstFuzzyMatch query, @library['playlists'].keys
			match ? match[:value] : false
		end

		def fuzzyStringSearchInList(query, list)
			queryPattern = Regexp.new(query + '|' + query.gsub(/\s+/, '').split('').join('.*'), Regexp::IGNORECASE)
			matches = []
			list.each_with_index do |value, index|
				matchedPortion = queryPattern.match(value)

				if matchedPortion
					match = {
						:index => index,
						:value => value,
						:matchLength => matchedPortion[0].length
					};
					match[:density] = query.length.to_f / match[:matchLength].to_f
					match[:breadth] = match[:matchLength].to_f / match[:value].length.to_f
					match[:score] = match[:density] * 10 + match[:breadth]
					matches << match
				end

			end

			if matches.length > 1
				matches.sort! { |a,b| b[:score] <=> a[:score] }
			end

			matches
		end

		def firstFuzzyMatch(query, list)
			matches = fuzzyStringSearchInList query, list
			matches.length ? matches[0] : false
		end

		def deleteFileById(id)
			`rm #{getFilePrefixFromId id}*`
		end

		def firstTrackFile(track)
      files = findTrackFiles(track)
      files.length ? files[0] : nil
		end

		def findTrackFiles(track)
      Dir.glob("#{getFilePrefixFromId track['id']}*")
		end

		def trackFileExists?(track)
      findTrackFiles(track).length > 0
		end

		def getFilePrefixFromId(id)
			"#{@fileDirectory}/tunewich-#{id}"
		end

		def downloadTrack(track, streamPath = nil)
			youtubeDlCommandBegin = "youtube-dl -f bestaudio --no-part"
			youtubeDlCommandEnd = "-- #{track['src']}"

			downloadPid = nil
			downloadFeedbackFile = createTempFile 'download-feedback'

			if streamPath
				downloadPid = spawn("#{youtubeDlCommandBegin} -o - #{youtubeDlCommandEnd} > \"#{streamPath}\" 2> \"#{downloadFeedbackFile}\"")
			else
				# status = system "#{youtubeDlCommandBegin} -o \"#{getFilePrefixFromId track['src']}-%(title)s.%(ext)s\" #{youtubeDlCommandEnd}"
				downloadPid = spawn("#{youtubeDlCommandBegin} -o \"#{getFilePrefixFromId track['src']}-%(title)s.%(ext)s\" #{youtubeDlCommandEnd} &> \"#{downloadFeedbackFile}\"")
				Process.detach(downloadPid)

				while not trackFileExists? track # FIXME: event driven approach to waiting for a file?
					printRepeat "Fetching video information for download (#{cliRotate})"
					sleep 0.1
				end

				# TODO: see FIXME below
				# if track.has_key? 'duration'
				# 	trackDuration = getSecondsFromDurationString track['duration']
				# 	bufferDuration = trackDuration / 2
				# end

				while true
					output = tailTempFile 'download-feedback'
					# FIXME: get mplayer to play the whole file, even if only part is downloaded when it starts
					# if trackDuration
					# 	etaMatch = output.match(/ETA ([0-9:]+)/)
					# 	if etaMatch
					# 		eta = getSecondsFromDurationString etaMatch[1]
					# 		if eta < bufferDuration
					# 			printRepeat "ETA (#{eta}) is less than #{bufferDuration}. Ready to play.\n"
					# 			break
					# 		end
					# 	end
					# end
					break if output.match(/#{track['src']}|100(\.0)?%/)
					printRepeat "(#{cliRotate}) #{output}"
					sleep 0.1
				end

				sleep 1 # FIXME: remove `sleep` in favor of checking if the right file exists yet
			end

			deleteTempFile 'download-feedback'

			downloadPid
		end

		def titleBlock(message, fill = '=', width = 80)
			blockRow = fill * width
			padding = '  '
			marginSize = (width - message.length) / 2 - padding.length
			marginLeft = marginSize > 1 ? fill * marginSize : ''
			marginRight = marginLeft
			marginRight += fill if message.length % 2 == 1
			puts "\n#{blockRow}"
			puts "#{marginLeft}#{padding}#{message}#{padding}#{marginRight}"
			puts blockRow
		end

		##
		# File Methods
		##

		def getTempFilePath(name)
			"/tmp/tunewich-#{@sessionID}-#{name}"
		end

		def createTempFile(name)
			putInTempFile name, ''
		end

		def putInTempFile(name, value)
			path = getTempFilePath name
			File.write(path, value)
			path
		end

		def readTempFile(name)
			path = getTempFilePath name

			if File.exist? path
				return File.read path
			end
		end

		def tailTempFile(name)
			content = readTempFile name
			lastLine = content.gsub("\r","\n").lines.pop
			lastLine.strip.chomp
		end

		def deleteTempFile(name)
			path = getTempFilePath name

			if File.exist? path
				File.delete path
			end
		end

		def makeStream(name)
			path = getTempFilePath name

			if File.exist? path
				raise "The temp file '#{name}' already exists. (#{path})"
			end

			if not system "mkfifo \"#{path}\""
				raise "ERROR: Could not create the stream file (#{path})"
			end

			path
		end

		alias deleteStream deleteTempFile

		##
		# Library Methods
		##

		def usePlaylist(name, append = false)
			@playlistName = name
			clearTracks if not append
			tracks = []

			@library['playlists'][@playlistName]['tracks'].each do |trackReference|
				tracks << @library['library'][trackReference]
			end

			useTracks tracks
		end

		def useEntireLibrary
			clearTracks
			tracks = []

			@library['library'].keys.each do |trackKey|
				tracks << @library['library'][trackKey]
			end

			useTracks tracks
		end

		def processLibraryJSON(json)
			{
				:json => json,
				:hash => Digest::MD5.digest(json),
				:data => JSON.parse(json)
			}
		end

		def loadLibrary
			libraryInfo = processLibraryJSON File.read(@libraryFilePath)
			if libraryInfo
				@library = libraryInfo[:data]
				@libraryHash = libraryInfo[:hash]
			end
		end

		def writeLibraryToFile
			libraryJSON = JSON.pretty_generate(@library)
			libraryOnFile = processLibraryJSON File.read(@libraryFilePath)
			if @libraryHash == libraryOnFile[:hash] || confirm("Library file has changed since last load. Overwrite?")
				libraryInfo = processLibraryJSON libraryJSON
				File.write(@libraryFilePath, libraryJSON)
				@libraryHash = libraryInfo[:hash]
				puts "Saved change to library file."
			end
		end

		def removeTrackFromLibrary(id)
			@library['library'].delete id
			@library['playlists'].each { |playlistName, p|
				index = p['tracks'].index id
				if index
					p['tracks'].delete_at index
				end
			}
			@library['tags'].each { |tagName, t|
				index = t['tracks'].index id
				if index
					playlistMatches << tagName
					t['tracks'].delete_at index
				end
			}
		end

		def interactiveCleanup
			cleanupSelection = {}

			commands = {
				'ul' => {
					'info' => '"unlisted", select all tracks not in any playlist',
					'action' => Proc.new {

						unattachedTracks = {}

						@library['library'].map { |id, t| unattachedTracks[id] = t }

						@library['playlists'].each do |name, playlist|
							playlist['tracks'].each do |id|
								unattachedTracks.delete id if unattachedTracks.has_key? id
							end
						end

						if unattachedTracks.length > 0
							unattachedTracks.each { |id, track| cleanupSelection[id] = track }
							puts "#{listTrackTitles cleanupSelection}\n\n(#{cleanupSelection.length} tracks selected)"
						else
							puts "Every track is assigned to a playlist. No suggestions for cleanup."
						end

					}
				},
				'all' => {
					'info' => 'select all tracks in the library',
					'action' => Proc.new {
						cleanupSelection = cloneLibrary @library['library']
						puts "All tracks selected (#{cleanupSelection.length})"
					}
				},
				'add' => {
					'info' => '<playlistName> add selection to a playlist.',
					'action' => Proc.new { |playlistQuery|
						if playlistQuery && playlistQuery.length > 0
							playlistName = findPlaylistName playlistQuery

							if playlistName
								cleanupSelection.keys.each { |id| addTrackReferenceToPlaylist id, playlistName }
							elsif confirm "No existing playlist matching '#{playlistQuery}'. Create one?"
								createPlaylist playlistQuery, cleanupSelection.keys
							else
								playlistName = nil
							end

							if playlistName
								cleanupSelection = {}
								puts "Added #{cleanupSelection.length} tracks to playlist '#{playlistName}'"
							else
								puts "No change"
							end
						else
							puts "#{@library['playlists'].map { |name, p| name } .join "\n"}\n\nPlease specify a playlist name (new or existing)."
						end
					}
				},
				'keep' => {
					'info' => "#{Player::FILTER_HELP_1}\n#{Player::FILTER_HELP_2}",
					'action' => Proc.new { |filterString|
						cleanupSelection = cloneLibrary @library['library'] if cleanupSelection.length == 0
						# FIXME: lots of back and forth from arrays to hashes here. Want to pick one?
						cleanupSelection = cloneTracksToLibrary filterTracks cloneLibraryToTracks(cleanupSelection), parseOptionParameters(filterString)
						puts "#{cleanupSelection.length} tracks selected"
					}
				},
				'drop' => {
					'info' => "Excludes tracks matching the rules. #{Player::FILTER_HELP_1}\n#{Player::FILTER_HELP_2}",
					'action' => Proc.new { |filterString|
						cleanupSelection = cloneLibrary @library['library'] if cleanupSelection.length == 0
						# FIXME: lots of back and forth from arrays to hashes here. Want to pick one?
						cleanupSelection = cloneTracksToLibrary filterTracks cloneLibraryToTracks(cleanupSelection), parseOptionParameters(filterString), true
						puts "#{cleanupSelection.length} tracks selected"
					}
				},
				'edit' => {
					'info' => 'edit selection in Vim',
					'action' => Proc.new {
						putInTempFile 'cleanup', listTrackTitles(cleanupSelection)
						system "vim #{getTempFilePath 'cleanup'}"
						cleanupSelection = getTracksFromTitleList readTempFile('cleanup')
						deleteTempFile 'cleanup'
						puts "#{listTrackTitles cleanupSelection}\n\n(#{cleanupSelection.length} tracks selected)"
					}
				},
				'clear' => {
					'info' => 'clear the selection',
					'action' => Proc.new {
						cleanupSelection = {}
						puts "0 tracks selected"
					}
				},
				'rm' => {
					'info' => 'remove selected tracks',
					'action' => Proc.new {
						initialLibraryLength = @library['library'].length
						cleanupSelection.each do |id, track|
							removeTrackFromLibrary id
						end
						checksum = initialLibraryLength - cleanupSelection.length == @library['library'].length
						checksumString = "#{initialLibraryLength} - #{cleanupSelection.length} == #{@library['library'].length}"
						puts "#{checksumString} ... #{checksum ? 'OK' : 'Mismatch'}"
						cleanupSelection = {}
					}
				},
				'jointag' => {
					'info' => '<playlistName> remove a playlist.',
					'action' => Proc.new { |tagsString|
						success = false

						if tagsString.length > 0
							tags = tagsString.split(Player::TAG_INPUT_SPLIT)
							if tags.length > 1
								success = combineTags tags
							else
								puts "Please give at least two tags."
							end
						end

						puts "Tags: \n  #{@library['tags'].keys.sort.join(", ")}" if not success
					}
				},
				'rmlist' => {
					'info' => '<playlistName> remove a playlist.',
					'action' => Proc.new { |playlistQuery|
						if playlistQuery && playlistQuery.length > 0
							playlistName = findPlaylistName playlistQuery

							if playlistName
								@library['playlists'].delete playlistName
								puts "removed playlist #{playlistName}"
							end

						else
							puts "#{@library['playlists'].map { |name, p| name } .join "\n"}\n\nPlease specify a playlist name (new or existing)."
						end
					}
				}
			}

			confirmMsg = "Choose a command, or \"y\" to write changes to file"
			if confirm confirmMsg, commands
				writeLibraryToFile
			else
				puts "No changes saved."
			end

			puts "Cleanup finished."
		end

		def filterTracks tracks, filters, invert = false
			action = invert ? 'delete_if' : 'keep_if'

			if filters['rating']
				tracks.send(action) { |track| track['rating'] && track['rating'] == filters['rating'].to_i }
			end

			if filters['min-rating']
				tracks.send(action) { |track|
					track['rating'] && track['rating'] >= filters['min-rating'].to_i
				}
			end

			if filters['max-rating']
				tracks.send(action) { |track| !track['rating'] || track['rating'] <= filters['max-rating'].to_i }
			end

			if filters['tag']
				taggedPlaylistTrackIds = []
				@library['playlists'].each { |name, p| taggedPlaylistTrackIds += p['tracks'] if p['tags'] && p['tags'].find_index(filters['tag']) }
				tracks.send(action) { |t| taggedPlaylistTrackIds.find_index t['id'] }

				if tracks.length === 0 # list available tags if no matches
					allTags = []
					@library['playlists'].each { |name, p| allTags += p['tags'] if p['tags'] }
					puts "No matches. Available tags are: #{allTags.uniq.sort.join ", "}"
				end
			end

			if filters['title']
				matches = fuzzyStringSearchInList(filters['title'], getTrackTitles(tracks))
				matchedIds = []
				matches.each { |match|
					matchedIds << tracks[match[:index]]['id']
				}
				tracks.send(action) { |t| matchedIds.include? t['id'] }
			end

			if filters['last']
				now = Time.now.to_i
				watershed = now - getSecondsFromDurationString(filters['last']).to_i
				tracks.send(action) { |t|
					t['played'] ? t['played'].to_i >= watershed : false
				}
			end

			if filters['min-duration']
				minDuration = getSecondsFromDurationString filters['min-duration']
				tracks.send(action) { |t|
					t['duration'] ? getSecondsFromDurationString(t['duration']) > minDuration : false
				}
			end

			if filters.has_key? 'chapters'
				tracks.send(action) { |track|
					if track
						track.has_key? 'chapters'
					else
						false
					end
				}
			end

			tracks
		end

		def createPlaylist name, tracks = [], description = ''
			newPlaylist = {
				'description' => description,
				'public' => true,
				'tracks' => tracks
			}
			@library['playlists'][name] = newPlaylist
		end

		def createTrack id
			{
				'id' => id,
				'src' => id, # NOTE: assuming ID is a YouTube video ID, so that it's also the "src"
				'unattached' => true
			}
		end

		def getTrackInfo id
			rawInfo = `youtube-dl --get-title --get-description --get-duration -- #{id}`
			return false if !rawInfo || rawInfo.length == 0

			lines = rawInfo.chomp.lines
			track = {
				'title' => lines.shift.chomp, # first line
				'duration' => lines.pop.chomp, # last line
				'description' => lines.join("\n").chomp # everything else
			}

			track
		end

		def updateTrackInfo track
			trackInfo = getTrackInfo track['id']
			return false if !trackInfo

			track['title'] = trackInfo['title']

			if trackInfo['description']
				chapters = getChaptersFromDescription trackInfo['description'].lines
				track['chapters'] = chapters if chapters && chapters.length > 0
			end

			track['duration'] = trackInfo['duration'] if trackInfo['duration']

			track
		end

		def getChaptersFromDescription description
			description.grep(/[0-9]+:[0-9:.]+/).map! do |line|
				matches = line.match(/^(.*?)[ (]*([0-9]+:[0-9:.]+)[ )]*(.*)$/)
				{
					'time' => matches[2],
					'name' => "#{matches[1]} #{matches[3]}".gsub(/^[^0-z]/, '').strip
				}
			end
		end

		def addTrackToLibrary track
			track.delete 'unattached' if track.has_key? 'unattached'
			trackReference = track['id']
			@library['library'][trackReference] ||= track

			trackReference
		end

		def addTrackReferenceToPlaylist trackReference, playlistName
			playlistTracks = @library['playlists'][playlistName]['tracks']
			track = @library['library'][trackReference]

			if not playlistTracks.include? trackReference
				playlistTracks << trackReference
				puts "Saved '#{track['title']}' (#{trackReference}) to playlist '#{playlistName}'"
			else
				puts "Track '#{track['title']}' (#{trackReference}) is already in playlist '#{playlistName}'"
			end
		end

		##
		# YouTube Methods
		##

		def getYoutubeIdFromUrl url
      youtubeIdPattern = /^.*youtu(\.be\/|be\.com.*v=)([^&\/]+)/
			matches = url.match(youtubeIdPattern)
      matches ? matches[1] : false
		end

		def searchYouTube query, offset = 0, count = 20
			puts "Searching YouTube for '#{query}'"
			resultsPerPage = 20
			page = (offset.to_f / resultsPerPage.to_f).to_i + 1
			queryParameter = URI::encode(query)
			queryUrl="https://www.youtube.com/results?search_query=#{queryParameter}&page=#{page}"
			getYouTubeTracksFromPage queryUrl
		end

		def getYouTubeTracksFromPage url
			queryResultIds = []
			open(url) do |handle|
        html = []
        handle.each_line { |line| html << line }

        queryResultIds = html.grep(/href="\/watch/).map! do |line|
          line.sub!(/^.*watch\?v=([^\"&<]+).*\n/, '\1')
        end

        queryResultIds.uniq!
			end

			threads = []
			resultTracks = []
			receivedCount = 0
			printRepeat "Getting track information (#{receivedCount}/#{queryResultIds.length})"

			queryResultIds.each_with_index do |id, index|
				track = matchExistingLibraryTrack createTrack id
				resultTracks << track
				threads << Thread.new {
					if not updateTrackInfo track
						resultTracks.delete track
					end
					receivedCount += 1
					printRepeat "Getting track information (#{receivedCount}/#{queryResultIds.length})"
				}
			end

			threads.each { |thr| thr.join }
			print "\n"

			resultTracks
		end

		##
		# Utility Methods
		##

		def getSecondsFromDurationString durationString
			seconds = 0
			factor = 1
			factors = [1,60,60,24]

			durationString.split(':').reverse.each_with_index { |unit, index|
				factor *= factors[index]
				seconds += unit.to_f * factor
			}

			seconds
		end

		##
		# UI Methods
		##

		def parseOptions
			output = {}

			parser = OptionParser.new

      parser.on("-a", "--add-track YOUTUBE_URLS", "Add tracks to the library, and to a playlist, if specified. Takes a comma-separated list of YouTube URLs or IDs.", " ") do |urls|
				output[:newTracks] = []
				urls.split(',').each { |url|
          youtubeId = getYoutubeIdFromUrl url

          if youtubeId
            output[:newTracks] << updateTrackInfo(createTrack(youtubeId))
            puts "This URL contains a YouTube ID. Adding."
          end

          if confirm "Look for all tracks on this page?"
            output[:newTracks].concat getYouTubeTracksFromPage url
          end
				}
			end

			parser.on("-c", "--clean", "Enter an interactive cleanup mode, to remove unwanted items from the library.", " ") do
				output[:interactiveCleanup] = true
			end

			parser.on("-d", "--[keep-]download", "Enable downloading files when encountering a playlist file without a cached file already download.", "Files not added to the library will be deleted after playback, unless --keep-download is used.", " ") do |keep|
				@enableDownload = true
				@keepUnattachedDownload = keep
			end

			parser.on("-f", "--filter RULES", Player::FILTER_HELP_1, Player::FILTER_HELP_2, " ") do |rules|
				@trackFilters = parseOptionParameters rules
			end

			parser.on("-h", "--help", "Show this help.", " ") do
				puts parser.help()
				exit
			end

			parser.on("-l", "--loop", "Loop, even if a track doesn't have an A/B loop defined.", " ") do
				@loop = true
			end

			parser.on("-p", "--playlist [NAME]", "Choose or create a playlist. If no NAME/QUERY is given, a name is guessed from other input, such as a -q query", " ") do |playlistQuery|
				output[:playlistQuery] = playlistQuery
			end

			parser.on("-q", "--query QUERY", "Search YouTube for a video.", " ") do |query|
				@youtubeSearch = query
			end

			parser.on("-r", "--rating-prompt [SECONDS]", "Prompt for a rating and tags after every track plays, waiting 5 (or the number given) seconds before continuing to the next track", " ") do |seconds|
				@ratingsPromptDuration = seconds ? seconds.to_i : 5
			end

			parser.on("-s", "--shuffle", "Enable shuffle.", " ") do
				@shuffle = true
			end

			parser.on("-t", "--track INDEX/QUERY", "Seek to the given track (either by its number in the list, or by its name).", " ") do |trackQuery|
				if trackQuery.to_i != 0
					@trackIndex = trackQuery.to_i - 1
				else
					@trackIndex = trackQuery
				end
			end

			parser.on("-w", "--write [SECONDS]", "Save changes to the library. If SECONDS are given, only tracks played that many seconds will be written.", " ") do |seconds|
				@playthroughThreshold = seconds ? seconds.to_f : 0.0
			end

			parser.on("-x", "--exclude-filter RULES", "Excludes tracks matching the rules. See --filter", " ") do |rules|
				@trackExcludeFilters = parseOptionParameters rules
			end

			parser.on("--input-dir DIR", "Directory from which to read the playlist and files.", "NOTE: when used, this must be the first option. Recommended to define TUNEWICH_DIR instead.", " ") do |inputDir|
				# FIXME: always process this option first, even if it's provided last
				setLibraryPath inputDir
			end

			parser.on("--no-network", "Don't fetch any information or media from the internet. Use only local files.", " ") do
				@noNetwork = true
			end

			parser.on("--update-track-info", "Fetch updated track information for every track played.", " ") do
				@updateAllPlayedTrackInfo = true
			end

			@mplayerOverrideCommands = parser.parse(ARGV)

			output
		end

		def doOptionSecondaryActions options

			if not @fileDirectory
				puts "please specify an input directory with -i"
				exit
			end

			if @youtubeSearch && !@noNetwork
				@youtubeSearchPage = 1
				useTracks searchYouTube @youtubeSearch
			end

			if options.has_key? :interactiveCleanup
				interactiveCleanup
				exit
			end

			if options.has_key? :playlistQuery
				if options[:playlistQuery]
					match = firstFuzzyMatch options[:playlistQuery], @library['playlists'].keys

					if match && match[:score] > 1 # FIXME: what's a good baseline score for a playlist match?
						playlistName = match[:value]
					elsif confirm("Create new playlist #{options[:playlistQuery]}?")
						playlistName = options[:playlistQuery]
					end
				elsif @youtubeSearch
					playlistName = @youtubeSearch
				end

				if playlistName
					if not @library['playlists'].has_key? playlistName
						puts "Creating new playlist: #{playlistName}"
						createPlaylist playlistName
						writeLibraryToFile
					end

					usePlaylist playlistName, true
				end
			end

			if options.has_key? :newTracks
				options[:newTracks].each { |newTrack|
					trackReference = addTrackToLibrary newTrack
					addTrackReferenceToPlaylist trackReference, @playlistName if @playlistName
				}
				writeLibraryToFile
			end
		end

		def parseOptionParameters serialized
			hash = {}

			serialized.split(',').each { |clump|
				pair = clump.split '='
				hash[pair[0]] = pair[1]
			}

			hash
		end

		def printRepeat message
			print " #{" " * @printRepeatMessage.length}\r" if @printRepeatMessage
			message = message.to_s if message.respond_to? 'to_s'
			print " #{message}\r"
			@printRepeatMessage = message.match(/\n/) ? nil : message
		end

		def cliRotate
			if not @cliRotateIndex
				@cliRotateIndex = 0
				@cliRotateCharacters = ['==', '\\\\', '||', '//']
			else
				@cliRotateIndex = (@cliRotateIndex + 1) % @cliRotateCharacters.length
			end

			@cliRotateCharacters[@cliRotateIndex]
		end

		def commandPrompt message = nil, commands = nil
			if commands
				commands['help'] = {
					'info' => 'show this info',
					'action' => Proc.new {
						commandInfo = []
						commands.each { |name, set|
							info = "\"#{name}\""
							info += " -- #{set['info']}" if set['info']
							commandInfo << info
						}
						puts commandInfo.join "\n"
					}
				}
			end

			prompt = Proc.new {
				puts "\n(commands: \"#{commands.keys.join '", "'}\")" if commands
				print message if message
			}
			prompt.call

			response = {
				:input => nil,
				:commands => []
			}

			while input = STDIN.gets.chomp

				if commands && !input.empty? && input[0] == '/'

					commandParts = input.match(/^\/([^\s]+)\s*(.*)/)
					commandName = commandParts[1]
					commandArgs = commandParts[2]

					if commands[commandName]
						response[:commands] << ({
							:name => commandName,
							:args => commandArgs,
							:output => commands[commandName]['action'].call(commandArgs)
						})
					else
						puts "Invalid command '#{commandName}'; available commands: #{commands.keys.join ', '}"
					end

					prompt.call

				else

					break

				end

			end

			response[:input] = input

			response
		end

		def confirm message, commands = nil
			confirmMessage = "#{message} (y/N): "
			commandPrompt(confirmMessage, commands)[:input].match(/^[Yy]/)
		end

		def timedTextPrompt timeout, message = nil, commands = nil
			input = nil

			thr = Thread.new {
				input = STDIN.gets.chomp # doesn't keep the thread alive...
				# input = commandPrompt message, commands # doesn't keep the thread alive...
			}

			timer = 0
			while thr.alive?
				printRepeat "(#{timeout - timer}) #{message}"
				sleep 1
				timer += 1
				if timer >= timeout
					input = nil
					Thread.kill thr
				end
			end

			input
		end

		def promptForPlaylist
			puts "Please choose a playlist (leave blank to play all):\n  #{@library['playlists'].keys.join "\n  "}"
			selectedListName = nil
			while !selectedListName do
				playlistQuery = commandPrompt[:input]

				if not playlistQuery or playlistQuery.length === 0
					useEntireLibrary
					break
				end

				selectedListName = findPlaylistName playlistQuery

				if not selectedListName
					puts "No matches. Try again"
				end

			end

			selectedListName
		end

		def promptForChapterIndex chapters, commands = nil, message = nil
			selectedChapterIndex = nil

			chapterList = chapters.map { |chapter| "#{chapter['time']} - #{chapter['name']}" }
			prePromptMessage = "  #{chapterList.join "\n  "}"
			prePromptMessage += "\n#{message}" if message
			promptMessage = "Please choose a chapter (leave blank to play first):"

			while not selectedChapterIndex do
				puts prePromptMessage
				chapterQuery = timedTextPrompt Player::CHAPTER_SELECT_TIMEOUT, promptMessage, commands
				break if not chapterQuery or chapterQuery.length === 0

				selectedChapter = firstFuzzyMatch chapterQuery, chapterList

				if selectedChapter
					selectedChapterIndex = selectedChapter[:index]
					break
				else
					puts "No matches. Try again."
				end

			end

			{
				:index => selectedChapterIndex
			}
		end

		def listTrackTitles(tracks)
			tracks.map { |id, t| "#{t['title']} [#{id}]" } .join "\n"
		end

		def getTracksFromTitleList(titleString)
			tracks = {}
			titleString.chomp.lines.each { |line|
				matches = line.match(/^.*\[(.*)\]$/)
				if matches
					id = matches[1]
					track = @library['library'][id]
					tracks[id] = track if track
				else
					puts "IGNORING: #{line}"
				end
			}

			tracks
		end

		def cloneTracks inputTracks
			tracks = []
			inputTracks.each { |id, t| tracks <<  t }
			tracks
		end

		def cloneLibraryToTracks inputLibrary
			tracks = []
			inputLibrary.each { |id, t| tracks << t }
			tracks
		end

		def cloneLibrary inputLibrary
			library = {}
			inputLibrary.each { |id, t| library[t['id']] = t }
			library
		end

		def cloneTracksToLibrary inputTracks
			library = {}
			inputTracks.each { |t| library[t['id']] = t }
			library
		end

	end

end

Tunewich::Player.new
