#!/usr/bin/env ruby

# TODO: catch C-t, or something like it, to pass interactive commands to the script

require "open-uri"
require "optparse"
require "json"

module Tunewich
	class Player
		def initialize

			@sessionID = Random.rand(1024)
			@trackIndex = nil
			@tracks = nil
			@trackFilters = nil
			@playlistName = nil
			@playlist = nil

			if ENV.key? 'TUNEWICH_DIR'
				setLibraryPath ENV['TUNEWICH_DIR']
			else
				puts "Please add `export TUNEWICH_DIR=\"<path/to/your/music/directory>\"` to your ~/.profile or similar file."
			end

			parseOptions

			if not @fileDirectory
				puts "please specify an input directory with -i"
				exit
			end

			if @tracks
				titleBlock "Playing #{@tracks.length} tracks", '#'
			else
				if selectedListName = promptForPlaylist
					usePlaylist selectedListName
					titleBlock "Playlist: #{@playlistName} (#{@tracks.length})", '#'
				end
			end

			if @trackFilters
				applyTrackFilters @trackFilters
			end

			if @trackIndex == nil
				if @shuffle
					shuffleIndex()
				else
					@trackIndex = 0
				end
			elsif @trackIndex.is_a? String and @trackIndex != '0'
				@trackIndex = findTrackIndex @trackIndex
			else
				@trackIndex = @trackIndex.to_i
			end

			# TODO: catch SIGINT (ctrl+c) & prompt for playlist again
			playbackSuccessful = true
			while playbackSuccessful do
				break if not @tracks[@trackIndex]
				playbackSuccessful = play @tracks[@trackIndex]
				nextTrack()
			end
		end

		private

		def parseOptions
			parser = OptionParser.new

			parser.on("-i", "--input-dir DIR", "Directory from which to read the playlist and files. NOTE: when used, this must be the first option. Recommended to define TUNEWICH_DIR instead.") do |inputDir|
				# FIXME: always process this option first, even if it's provided last
				setLibraryPath inputDir
			end
			parser.on("-t", "--track INDEX/QUERY", "Seek to the given track (either by its number in the list, or by its name).") do |trackQuery|
				if trackQuery.to_i != 0
					@trackIndex = trackQuery.to_i - 1
				else
					@trackIndex = trackQuery
				end
			end
			parser.on("-a", "--add-track YOUTUBE_URL", "Add a track to the playlist and save.") do |url|
				# TODO: add multiple by accepting space-separated list of URLs
				@playlistName = promptForPlaylist if not @playlistName
				id = getYoutubeIdFromUrl url
				newTrack = createTrack id
				addTrackToPlaylist newTrack, @playlistName
				writeLibraryToFile
				exit
			end
			parser.on("-p", "--playlist QUERY", "Partial or full name of a playlist.") do |playlistQuery|
				playlistName = findPlaylistName playlistQuery

				if playlistName
					usePlaylist playlistName
				else
					puts "No playlist found to match query #{playlistQuery}."
				end
			end
			parser.on("-P", "--create-playlist NAME", "Create a new playlist. Implies -p of the same playlist.") do |playlistName|
				createPlaylist playlistName
				writeLibraryToFile
				usePlaylist playlistName
			end
			parser.on("-f", "--filter RULES", "Filter by rules, in the format 'name=value,name=value'. Available rules are: min-rating=[0-5],title=[query].") do |rules|
				@trackFilters = {}
				rules.split(',').each { |clump|
					pair = clump.split '='
					@trackFilters[pair[0]] = pair[1]
				}
			end
			parser.on("-d", "--enable-download", "Enable downloading files when encountering a playlist file without a cached file already download.") do
				@enableDownload = true
			end
			parser.on("-s", "--shuffle", "Enable shuffle.") do
				@shuffle = true
			end
			parser.on("-l", "--loop", "Loop, even if a track doesn't have an A/B loop defined.") do
				@loop = true
			end
			parser.on("-q", "--query QUERY", "Search YouTube for a video.") do |query|
				@tracks = searchYouTube query
			end
			parser.on("-Q", "--save-query QUERY", "Same as -q, but also create a playlist taking the query as a name. Use with -w to save to this playlist.") do |query|
				createPlaylist query
				usePlaylist query
				@youtubeSearchPage = 1
				@youtubeSearchQuery = query
				@tracks = searchYouTube @youtubeSearchQuery
			end
			parser.on("-w", "--write-after TIME", "Save tracks to the playlist (from -p or -P) when played for the given number of seconds. Use with -q.") do |time|
				@playthroughThreshold = time.to_f
			end
			parser.on("-h", "--help", "Show this help.") do
				puts parser.help()
				exit
			end

			@mplayerOverrideCommands = parser.parse(ARGV)
		end

		def setLibraryPath libraryPath
			@tunewichDirectory = libraryPath
			if not Dir.exist? @tunewichDirectory
				puts "Please create the directory '#{@tunewichDirectory}'."
				exit
			end

			@fileDirectory = "#{@tunewichDirectory}/music"
			Dir.mkdir @fileDirectory if not Dir.exist? @fileDirectory

			@libraryFilePath = "#{@tunewichDirectory}/tunewich-library.json"
			if not File.exist? @libraryFilePath
				raise "TODO: create library file at #{@libraryFilePath}"
			end

			@library = JSON.parse(File.read(@libraryFilePath))
		end

		def promptForPlaylist
			puts "Please choose a playlist (leave blank to play all):\n  #{@library['playlists'].keys.join "\n  "}"
			selectedListName = nil
			while !selectedListName do
				playlistQuery = STDIN.gets.chomp
				if not playlistQuery or playlistQuery.length === 0
					useEntireLibrary
					break
				end
				selectedListName = findPlaylistName playlistQuery
				if not selectedListName
					puts "No matches. Try again"
				end
			end

			selectedListName
		end

		def promptForChapterIndex chapters
			chapterList = chapters.map { |chapter| "#{chapter['time']} - #{chapter['name']}" }
			puts "Please choose a chapter (leave blank to play first):\n  #{chapterList.join "\n  "}"
			selectedChapter = nil
			while not selectedChapter do
				chapterQuery = STDIN.gets.chomp
				if not chapterQuery or chapterQuery.length === 0
					selectedChapterIndex = 0
					break
				end
				selectedChapter = firstFuzzyMatch chapterQuery, chapterList
				if selectedChapter
					selectedChapterIndex = selectedChapter[:index]
					break
				else
					puts "No matches. Try again"
				end
			end

			selectedChapterIndex
		end

		def getTrackTitles
			@tracks.map{|t| t['title']}
		end

		def findTrackIndex(query)
			match = firstFuzzyMatch query, getTrackTitles
			match ? match[:index] : false
		end

		def findPlaylistName(query)
			match = firstFuzzyMatch query, @library['playlists'].keys
			match ? match[:value] : false
		end

		def fuzzyStringSearchInList(query, list)
			queryPattern = Regexp.new(query + '|' + query.gsub(/\s+/, '').split('').join('.*'), Regexp::IGNORECASE)
			matches = []
			list.each_with_index do |value, index|
				matchedPortion = queryPattern.match(value)
				if matchedPortion
					match = {
						:index => index,
						:value => value,
						:matchLength => matchedPortion[0].length
					};
					match[:density] = query.length.to_f / match[:matchLength].to_f
					match[:breadth] = match[:matchLength].to_f / match[:value].length.to_f
					match[:score] = (match[:breadth] + match[:density] * 2) / 3
					matches.push(match)
				end
			end

			matches.sort_by { |match| 1 - match[:score] } if matches.length > 1

			matches
		end

		def firstFuzzyMatch(query, list)
			matches = fuzzyStringSearchInList query, list
			matches.length ? matches[0] : false
		end

		def usePlaylist(name)
			@playlistName = name
			@playlist = @library['playlists'][@playlistName]
			@tracks = []
			@playlist['tracks'].each do |trackReference|
				@tracks.push @library['library'][trackReference]
			end
		end

		def useEntireLibrary
			@tracks = []
			@library['library'].keys.each do |trackKey|
				@tracks.push @library['library'][trackKey]
			end
		end

		def nextTrack
			if @shuffle
				shuffleIndex()
			else
				@trackIndex += 1
				if @trackIndex > @tracks.length - 1
					if @youtubeSearchPage
						@youtubeSearchPage += 1
						@tracks += searchYouTube(@youtubeSearchQuery, (@youtubeSearchPage - 1) * 20)
					else
						@trackIndex %= @tracks.length
					end
				end
			end
		end

		def shuffleIndex
			@trackIndex = Random.rand(@tracks.length - 1)
		end

		def play(track)
			if track['get_info']
				track.delete 'get_info'
				track = updateTrackInfo track
			end

			titleBlock "[#{@trackIndex + 1}] - #{track['title']}"

			mplayerCommands = []

			fileExists = fileExistsFromID? track['src']
			streaming = !fileExists && !@enableDownload

			if track['loop'].kind_of?(Array)
				if not streaming
					duration = track['loop'][1] - track['loop'][0]

					mplayerInputFile = putInTempFile 'mplayer-input', "seek -999:00:00\n" # this is a silly way to do it. -100% doesn't work. Still, there's a moment of the audio heard before this command is run.
					mplayerCommands.push("-input file=#{mplayerInputFile}")

					# loop back from B to A
					mplayerCommands.push("-ss #{track['loop'][0]}")
					mplayerCommands.push("-endpos #{duration}")
				else
					titleBlock "This track has an A/B loop, but looping is not supported while streaming. Add the -d option to enable downloading."
				end
			elsif track['chapters']
				if not streaming
					chapterIndex = promptForChapterIndex track['chapters']
					puts "you chose the chapter: #{track['chapters'][chapterIndex]}" # XXX
					offsetSeconds = getSecondsFromDurationString track['chapters'][chapterIndex]['time']
					mplayerCommands.push("-ss #{offsetSeconds}")
					if chapterIndex < track['chapters'].length - 1
						nextTrackoffsetSeconds = getSecondsFromDurationString track['chapters'][chapterIndex + 1]['time']
						mplayerCommands.push("-endpos #{nextTrackoffsetSeconds - offsetSeconds}")
					end
				else
					titleBlock "This track has chapters, but seeking backward is not supported while streaming. Add the -d option to enable downloading."
				end
			end

			if not fileExists
				if streaming
					streamName = 'youtube-stream'
					streamPath = mediaFilePath = makeStream streamName
				end

				if not downloadFromYouTubeID track['src'], streamPath
					return false
				end
			end

			mediaFilePath ||= findFile track['src']

			if !streamName
				mplayerCommands.push("-loop 0") if track['loop'] or @loop
			end

			mplayerCommands.push("-novideo")
			mplayerCommands += @mplayerOverrideCommands

			mplayerStartTime = Time.now.to_f

			mplayerStatus = system "mplayer \"#{mediaFilePath}\" #{mplayerCommands.join ' '}"

			mplayerEndTime = Time.now.to_f

			mplayerPlayTime = mplayerEndTime - mplayerStartTime
			if (@playthroughThreshold && mplayerPlayTime > @playthroughThreshold)
				puts "Played more than #{@playthroughThreshold}s, adding to playlist '#{@playlistName}'."
				addTrackToPlaylist track, @playlistName if @playlistName
				writeLibraryToFile
			end

			deleteStream streamName if streamName
			deleteTempFile 'mplayer-input'

			mplayerStatus
		end

		def findFile(id)
			`ls -1 #{getFilePrefixFromId id}*`.strip
		end

		def fileExistsFromID?(id)
			system "ls -1 #{getFilePrefixFromId id}*"
		end

		def getFilePrefixFromId(id)
			"#{@fileDirectory}/tunewich-#{id}"
		end

		def downloadFromYouTubeID(id, streamPath = nil)
			puts "Downloading file (#{id})"

			youtubeDlCommandBegin = "youtube-dl -f bestaudio"
			youtubeDlCommandEnd = "-- #{id}"

			if streamPath
				streamPid = spawn("#{youtubeDlCommandBegin} -o - #{youtubeDlCommandEnd} > \"#{streamPath}\"")
				Process.detach(streamPid)
				return true
			else
				result = system "#{youtubeDlCommandBegin} -o \"#{getFilePrefixFromId id}-%(title)s.%(ext)s\" #{youtubeDlCommandEnd}"
				if not result
					puts "Download interrupted..."
				end
			end

			result
		end

		def titleBlock(message, fill = '=', width = 80)
			blockRow = fill * width
			padding = '  '
			marginSize = (width - message.length) / 2 - padding.length
			marginLeft = marginSize > 1 ? fill * marginSize : ''
			marginRight = marginLeft
			if message.length % 2 == 1 then marginRight += fill end
			puts "\n#{blockRow}"
			puts "#{marginLeft}#{padding}#{message}#{padding}#{marginRight}"
			puts blockRow
		end

		def getTempFilePath(name)
			"/tmp/tunewich-#{@sessionID}-#{name}"
		end

		def putInTempFile(name, value)
			path = getTempFilePath name
			File.write(path, value)
			path
		end

		def putInTempFile(name, value)
			path = getTempFilePath name
			File.write(path, value)
			path
		end

		def deleteTempFile(name)
			path = getTempFilePath name
			if File.exist? path
				File.delete path
			end
		end

		def makeStream(name)
			path = getTempFilePath name
			if File.exist? path
				raise "The temp file '#{name}' already exists. (#{path})"
			end
			if not system "mkfifo \"#{path}\""
				raise "ERROR: Could not create the stream file (#{path})"
			end
			path
		end

		def getYoutubeIdFromUrl url
			url.sub(/^.*v=/, '')
		end

		def applyTrackFilters filters
			if filters['min-rating']
				filterTracksByRating filters['min-rating'].to_i
			end
			if filters['title']
				filterTracksByTitle filters['title']
			end
		end

		def filterTracksByRating rating
			@tracks.keep_if { |track| track['rating'] && track['rating'] >= rating }
		end

		def filterTracksByTitle query
			matches = fuzzyStringSearchInList(query, getTrackTitles)
			oldTracks = @tracks
			@tracks = []
			matches.each { |match|
				@tracks.push oldTracks[match[:index]]
			}
		end

		def createPlaylist name, tracks = [], description = ''
			newPlaylist = {
				'description' => description,
				'public' => true,
				'tracks' => tracks
			}
			@library['playlists'][name] = newPlaylist
		end

		def getTrackInfo id

			track = {
				'title' => `youtube-dl --get-title -- #{id}`.chomp
			}

			if track['title'].empty?
				track['title'] = 'Unknown'
				puts "Video not found. Cannot get title."
			else
				track['description'] = `youtube-dl --get-description -- #{id}`.chomp
			end

			track
		end

		def getTrackDescription id
			puts "Fetching description for YouTube ID #{id}..."
			description = `youtube-dl --get-description -- #{id}`.chomp

			if description.empty?
				description = 'Unknown'
				puts "Video not found. Cannot get description."
			end

			description
		end

		def createTrack id, getInfo = true
			track = {
				'src' => id
			}

			if getInfo
				track = updateTrackInfo track
			end

			track
		end

		def updateTrackInfo track
			puts "getting track info for #{track['src']}" # XXX
			trackInfo = getTrackInfo track['src']
			puts "trackInfo: #{trackInfo}" # XXX
			track['title'] = trackInfo['title']

			if trackInfo['description']
				chapters = getChaptersFromDescription trackInfo['description'].lines
				puts "chapters found #{chapters}" # XXX
				track['chapters'] = chapters if chapters
			end

			track
		end

		def getChaptersFromDescription description
			description.grep(/[0-9]+:[0-9:.]+/).map! do |line|
				matches = line.match(/^(.*?)[ (]*([0-9]+:[0-9:.]+)[ )]*(.*)$/)
				puts "#{line} => #{matches}" # XXX
				{
					'time' => matches[2],
					'name' => "#{matches[1]} #{matches[3]}".strip
				}
			end
		end

		def addTrackToLibrary track
			trackReference = track['src']
			@library['library'][trackReference] ||= track

			trackReference
		end

		def addTrackToPlaylist track, playlistName
			trackReference = addTrackToLibrary track

			tracks = @library['playlists'][playlistName]['tracks']
			if not tracks.index trackReference
				tracks.push trackReference
				puts "Saved '#{track['title']}' (#{trackReference}) to playlist '#{playlistName}'"
			else
				puts "Track '#{track['title']}' (#{trackReference}) is already in playlist '#{playlistName}'"
			end
		end

		def writeLibraryToFile
			libraryJSON = JSON.pretty_generate(@library)
			File.write(@libraryFilePath, libraryJSON) if libraryJSON
		end

		def searchYouTube query, offset = 0, count = 20
			puts "Searching YouTube for '#{query}'"
			resultsPerPage = 20
			page = (offset.to_f / resultsPerPage.to_f).to_i + 1
			queryParameter = URI::encode(query)
			queryUrl="https://www.youtube.com/results?search_query=#{queryParameter}&page=#{page}"

			queryResultIds = []
			open(queryUrl) do |handle|
				html = []
				handle.each_line { |line| html.push(line) }
				queryResultIds = html.grep(/href="\/watch/).map! do |line|
					line.sub!(/^.*watch\?v=([^\"&<]+).*\n/, '\1')
				end
				queryResultIds.uniq!
			end

			resultTracks = []
			queryResultIds.slice(0, count).each do |id|
				track = createTrack id, false
				track['title'] = "Search '#{query}': (#{id})"
				track['get_info'] = true
				resultTracks.push track
			end

			resultTracks
		end

		def getSecondsFromDurationString durationString
			seconds = 0
			factor = 1
			factors = [1,60,60,24]

			durationString.split(':').reverse.each_with_index { |unit, index|
				factor *= factors[index]
				seconds += unit.to_f * factor
			}

			seconds
		end

		alias deleteStream deleteTempFile

	end
end

Tunewich::Player.new
