#!/usr/bin/env ruby

require "io/console" # STDIN.getch
require "open-uri" # URI
require "optparse" # OptionParser
require "json" # JSON
require "digest" # Digest
require "rexml/document" # REXML::Document
require "rexml/xpath" # REXML::XPath

$logFilePath = nil
$clearLineCharacter = "\033[0K"
$disableWrapCharacter = "\033[?7l"
$enableWrapCharacter = "\033[?7h"
$tunewichWorkingDirectory = "#{ENV['HOME']}/.tunewich"
$hostname = ENV.has_key?('TENT_HOSTNAME') ? ENV['TENT_HOSTNAME'] : ENV['HOSTNAME']
$tunewichTmpDirectory = "#{$tunewichWorkingDirectory}/tmp"
$serviceConfigDir = "#{$tunewichWorkingDirectory}/config"
$uniqueId = 0

# Go to .tunewich directory so that any temp files are stored there.
Dir.mkdir $tunewichWorkingDirectory if not Dir.exist? $tunewichWorkingDirectory
Dir.chdir $tunewichWorkingDirectory

Dir.mkdir $tunewichTmpDirectory if not Dir.exist? $tunewichTmpDirectory

module Tunewich

  class Player

    PROMPT_TIMEOUT_RESPONSE = 'prompt_timeout_response'
    FILTER_HELP_1 = "Filter tracks by rules, in the format 'key=value,key=value 2,key'."
    FILTER_HELP_2 = "Available rules are: [min-,max-]rating=<#0-5>,title=<query>,tag=<tag>,chapters,last=<[[[DD:]HH:]MM:]SS>,ab."
    FILTER_HELP_3 = "Prepend an '-' to your rule to add it to exclude matches (e.g. '-tag=' vs 'tag=')."
    MODES = {
      'play' => 'play', # manage library while playing tracks
      'edit' => 'edit', # same interaction as "play", but without playback
      'kill' => 'kill' # shutting down
    }
    TAG_INPUT_SPLIT = /[,\s]+/
    PLAYER_APP_DEFAULT = 'mplayer'
    PLAYER_APP_TERMUX = 'termux'
    MPLAYER_STDOUT_BUFFER_NAME = 'mplayer-stdout'
    MPLAYER_INPUT_FIFO_NAME = 'mplayer-input'
    MPV_STDOUT_BUFFER_NAME = 'mpv-stdout'
    MPV_INPUT_FIFO_NAME = 'mpv-input'
    UNAME = `uname`.chomp

    DEFAULT_INTERACTIVE_INPUT_PATTERN = /^(?<query>.*?)( +(?<remainder>\/.*))?$/
    # DEFAULT_INTERACTIVE_INPUT_PATTERN = /^(?<query>[^\/].*?)( +(?<remainder>\/.*))?$/ # leading '/' means next command, so query may not begin with '/'

    def initialize
      @playerApplication = PLAYER_APP_DEFAULT
      @userMode = MODES['play']
      @library = nil
      @libraryHash = nil
      @eventBindings = {}
      @eventBindingsIndex = {}
      @eventBindingGroups = {}
      @sessionID = Random.rand(1024)
      @currentTrack = nil
      @currentNoteIndex = {
        'chapters' => nil,
        'notes' => nil
      }
      @currentlySeeking = false
      @trackIndex = nil
      @trackQuery = nil
      @tracks = []
      @configuredVerbosity = 0
      @verbosityBoost = 0
      @logVerbosity = nil
      @shouldShowPlaybackInfo = true
      @trackFilters = nil
      @trackExcludeFilters = nil
      @networkEnabled = true
      @playlistName = nil
      @volume = 25 # user's intended volume
      @currentVolume = 25 # temporary, internal volume state (e.g. changes during fading)
      @actualVolume = 25 # actual volume heard (after being affected by @volumeMultipliers)
      @currentSpeed = 1
      @currentVisualEffects = {
        'brightness' => 0,
        'contrast' => 0,
        'saturation' => 0,
        'hue' => 0
      }
      @volumeMultipliers = {}
      @bpmGlideDuration = 0
      @bpmGlideDelay = 0
      @autoDownload = false
      @preferredFileFormat = 'bestaudio'
      @playerTemporaryInteractiveCommands = []
      @playerOverrideCommands = []
      @currentPlayerTime = nil
      @currentPlayerIndex = 0
      @speedBeforeRampingOut = 1
      @inputThread = nil
      @playerApplicationThreads = []
      @forceStreaming = false
      @commandPrompts = []
      @commandHistory = []
      @commandHistoryIndex = nil
      @commandUserInput = nil
      @streamingServerType = nil
      @youtubeDLTrackTypes = ['youtube', 'soundcloud']
      @isPlayerPlaying = false
      @tempFiles = {}
      @writeEnabled = true
      @yesToConfirmPropts = false
      @loop = false
      @innerLoopsOnly = false
      @loopHistory = {};
      @loopLimit = 0
      @breakLoop = false
      @commandBeforePlayer = nil
      @hasMpv = nil

      getConfigFiles

      getEnvironmentConfig # library is loaded in here

      doOptionSecondaryActions parseOptions # library may be loaded again from a different place here

      main if @userMode != MODES['kill']
    end

    def main
      updateSessionDescription

      trackTitleListFromLastSession = readTempFile('tracks', false)
      if trackTitleListFromLastSession && trackTitleListFromLastSession.length > 0
        whisper("Using tracks from last session.", 1)
        useTracks(getTracksFromTitleList(trackTitleListFromLastSession.strip.lines))
      else
        useTracks(@library['tracks'].values)
      end

      if @trackQuery
        if @trackQuery.match(/^[0-9]+$/)
          @trackIndex = @trackQuery.to_i - 1
        else
          @trackIndex = findTrackIndex(@trackQuery) || nil
        end

        if @trackIndex
          whisper("Going to track #{@trackIndex + 1}, #{@tracks[@trackIndex]['title']}.", 2)
        else
          whisper("Could not find track by query '#{@trackQuery}'.", 0)
        end
        @trackQuery = nil
      elsif @library["lastMarked"]
        markedTrack = @library["tracks"][@library["lastMarked"]]
        if markedTrack && markedTrack["mark"]
          if @tracks.include?(markedTrack)
            whisper("Returning to last marked track.", 1)
            @trackIndex = @tracks.index(markedTrack)
            @library.delete "lastMarked"
            writeLibraryToFile
          else
            whisper("A track was marked, but is not in the current queue. It will remain marked until it is played again.", 0)
          end
        end
      end

      if not @trackIndex
        if @shuffle
          shuffleIndex()
        else
          @trackIndex = 0
        end
      end

      bindOnce 'before_exit', Proc.new {
        if @services && @services.length > 0
          whisper("Exiting: killing #{@services.length} services", 2)
          @services.each { |thread| thread.kill if thread.alive? }
        else
          whisper("Exiting: no services running", 2)
        end
      }

      @actualVolume = getPlayerConfiguredVolume
      @volume = @currentVolume = getStateSpaceVolume(@actualVolume)
      whisper("@volume: #{@volume}", 3)
      trigger 'volume_change'
      @speed = 1.0
      @speed = getMplayerConfigNumericProperty('speed', 1.0)
      whisper("@speed: #{@speed}", 3)
      @currentSpeed = @speed
      trigger 'speed_change'

      listenForExternalCommands

      interactiveLoop
    end

    def cleanup
      @playerApplicationThreads.each { |thread|
        thread.kill if thread && thread.alive?
      }
      @tempFiles.each { |path, nonsense|
        File.delete(path) if File.exist?(path)
      }
    end

    def getUniqueId
      $uniqueId = $uniqueId + 1
    end

    def getPlayerConfiguredVolume
      configuredVolume = 10.0 # "safe" default

      case @playerApplication
      when PLAYER_APP_DEFAULT
        configuredVolume = getMplayerConfigNumericProperty('volume')
      when PLAYER_APP_TERMUX
        volumeJson = `termux-volume` # get the various Android volume levels
        volumeData = JSON.parse(volumeJson)
        streamIndex = volumeData.find_index { |s| s.has_key?('stream') && s['stream'] == 'music' } if volumeData
        streamData = volumeData[streamIndex] if streamIndex
        if streamData
          @volumeMultipliers['system_max'] = streamData['max_volume'].to_f / 100.0 if streamData.has_key?('max_volume')
          whisper("Got _actual_ system volume: #{streamData['volume']}", 3)
          configuredVolume = streamData['volume'].to_f
        end
      end

      configuredVolume
    end

    def sendMplayerCommand command, playerIndex = nil
      case @playerApplication
      when PLAYER_APP_DEFAULT
        playerIndex ||= @currentPlayerIndex
        if playerIndex == @currentPlayerIndex
          if /play/.match command
            @isPlayerPlaying = true
          elsif /pause/.match command
            @isPlayerPlaying = false
          end
        end
        putInTempFile "#{MPLAYER_INPUT_FIFO_NAME}#{playerIndex}", "#{command}\n"
      when PLAYER_APP_TERMUX
        whisper("Not (yet) supported with termux: #{command}", 5)
      end
    end

    def sendMpvCommand command, playerIndex = nil
      case command.chomp.strip
      when 'q'
        exitPlayerCommand false # 1hEaID
      end

      ## TODO: get interactive input to mpv working
      # whisper("sending to mpv: '#{command}'", 4)
      # playerIndex ||= @currentPlayerIndex
      # putInTempFile "#{MPV_INPUT_FIFO_NAME}#{playerIndex}", "#{command}\n"
    end

    def togglePlay
      whisper("before togglePlay, @isPlayerPlaying: #{@isPlayerPlaying}", 2)
      case @playerApplication
      when PLAYER_APP_DEFAULT
        # @isPlayerPlaying is set in sendMplayerCommand
        sendMplayerCommand @isPlayerPlaying ? 'pause' : 'play'
      when PLAYER_APP_TERMUX
        @isPlayerPlaying = !@isPlayerPlaying
        if @hasMpv
          sendMpvCommand ' '
        else
          `termux-media-player #{@isPlayerPlaying ? 'pause' : 'play'}`
        end
      end
    end

    def interactiveLoop
      bindingGroupName = 'interactivePlayback'

      shouldExitMainLoop = false
      bindOnce 'before_exit', Proc.new {
        shouldExitMainLoop = true
        exitPlayerCommand
      }, bindingGroupName

      if @tracks && @tracks.length > 0
        titleBlock "Playing #{@tracks.length} tracks", '#'
      else
        useEntireLibrary
      end

      # TODO: 1gG4j1
      playerOutput = nil

      initialUserMode = @userMode
      interactiveCommands = getInteractiveCommands [@userMode], bindingGroupName

      # chaptersNotPlayed = []

      while @userMode == 'edit' or not playerOutput or playerOutput[:exit] do
        if @trackIndex && @tracks[@trackIndex]
          previousTrack = @currentTrack
          @currentTrack = matchExistingLibraryTrack @tracks[@trackIndex]

          handleTrackChangeDuringPlayback previousTrack, @currentTrack if previousTrack

          titleBlock "[#{@trackIndex + 1}] - #{@currentTrack['title']}"

          if @userMode == MODES['play']
            nextTrack() # call nextTrack after @trackIndex is announced, but before play, so that the user can see which track will come next.

            if @updateAllPlayedTrackInfo && @networkEnabled
              printRepeat "Getting latest track information..."
              updateTrackInfo @currentTrack
            end

            fileExists = trackFileExists? @currentTrack

            if !fileExists && !@networkEnabled
              next
            end
          end

          if @userMode != initialUserMode
            interactiveCommands = getInteractiveCommands [@userMode], bindingGroupName
            initialUserMode = @userMode
          end

          case @userMode

          when MODES['play']
            playerOutput = play @currentTrack, interactiveCommands
            if @tracks.empty? || !@trackIndex || 0 > @trackIndex || @trackIndex > @tracks.length - 1
              setUserMode MODES['edit']
            end
          when MODES['edit']
            commandPrompt '(keep hitting enter)', interactiveCommands
          end

          if @currentTrack && playerOutput
            trackDurationInSeconds = getSecondsFromDurationString(@currentTrack['duration'])

            if trackDurationInSeconds && !@currentTrack['unattached']
              loadLibrary
              @currentTrack = matchExistingLibraryTrack(@currentTrack)
              @currentTrack['playTime'] ||= 0
              @currentTrack['playTime'] += playerOutput[:playTime].to_i
              minimumPlayTime = [30, trackDurationInSeconds - 10].min
              if playerOutput[:playTime] >= minimumPlayTime
                @currentTrack['lastPlayed'] = playerOutput[:endTime].to_i
                @currentTrack['playCount'] ||= 0
                @currentTrack['playCount'] += 1
                whisper("listened for #{playerOutput[:playTime]} (>= min #{minimumPlayTime}): bumping play count to #{@currentTrack['playCount']}", 1)
              else
                @currentTrack['skipCount'] ||= 0
                @currentTrack['skipCount'] += 1
                whisper("listened for #{playerOutput[:playTime]} (< min #{minimumPlayTime}): bumping SKIP count to #{@currentTrack['skipCount']}", 1)
              end
              writeLibraryToFile
            end
          end
        else
          whisper("Empty tracklist", 3)
          emptyAction = Proc.new { |input| false } # break command loop after any non-command input
          whisper("empty (index '#{@trackIndex}' not found among #{@tracks.length} tracks.", 0)
          commandPrompt "empty", interactiveCommands, emptyAction
        end

        if shouldExitMainLoop
          whisper("Exiting player loop", 3)
          break
        end
      end

      unbindGroup bindingGroupName
    end

    def handleTrackChangeDuringPlayback trackA, trackB
      if (@bpmGlideDelay > 0 || @bpmGlideDuration > 0) && trackA.has_key?('bpm') && trackB.has_key?('bpm')
        whisper("gliding bpm for #{@bpmGlideDuration} seconds (after #{@bpmGlideDelay} seconds) seconds between #{trackA['bpm']} and #{trackB['bpm']} (adjust for current speed #{@speed}).", 2)
        initialSpeed = @speed
        # TODO: ramp to the nearest multiple: e.g. if going from 60bpm to 120, do nothing. If going from 60 to 140, ramp to 70; from 140 to 60, ramp to 120.
        # This is already implemented in getSoftBPMRatio
        @speed = @speed * trackA['bpm'] / trackB['bpm']
        bindOnce 'time_update', Proc.new {
          Thread.new {
            sleep @bpmGlideDelay if @bpmGlideDelay > 0
            rampSpeed initialSpeed, @bpmGlideDuration, @currentPlayerIndex
          }
        }
      end
    end

    def trigger eventName, data = nil
      if @eventBindings.has_key? eventName
        whisper("trigger #{eventName}, #{@eventBindings[eventName].length} handlers bound", 5)
        @eventBindings[eventName].each { |handlerId|
          whisper("event #{eventName}, calling handler handler #{handlerId}", 5)
          result = @eventBindingsIndex[handlerId][:handler].call(eventName, data)
          break if result == false
        }
      else
        whisper("trigger #{eventName} (no handlers bound)", 5)
      end
    end

    def bind eventName, handlerProc, handlerGroup = nil, jumpQueue = false
      handlerId = nil

      if eventName.kind_of?(Array)
        handlerId = []
        eventName.each{ |name|
          handlerId << bind(name, handlerProc, handlerGroup, jumpQueue)
        }
      else
        handlerId = getUniqueId
        @eventBindingsIndex[handlerId] = {
          :eventName => eventName,
          :handler => handlerProc,
          :id => handlerId,
          :group => handlerGroup
        }

        @eventBindings[eventName] ||= []
        if jumpQueue
          @eventBindings[eventName].unshift << handlerId
        else
          @eventBindings[eventName] << handlerId
        end

        if handlerGroup
          @eventBindingGroups[handlerGroup] ||= []
          @eventBindingGroups[handlerGroup] << handlerId
        end

        whisper("bind, #{eventName}, #{handlerGroup}, #{handlerId}", 5)
      end

      handlerId
    end

    def bindOnce eventName, handlerProc, handlerGroup = nil
      handlerId = nil
      selfRemovingHandlerProc = Proc.new { |triggeredEventName, data|
        unbind handlerId
        handlerProc.call triggeredEventName, data
      }
      handlerId = bind eventName, selfRemovingHandlerProc, handlerGroup
      handlerId
    end

    def unbind handlerId
      if handlerId.kind_of?(Array)
        handlerId.each{ |id|
          unbind(id)
        }
      else
        if @eventBindingsIndex.has_key? handlerId
          @eventBindings[@eventBindingsIndex[handlerId][:eventName]].delete_if { |id| id == handlerId }
          if @eventBindingsIndex[handlerId][:group]
            @eventBindingGroups[@eventBindingsIndex[handlerId][:group]].delete_if { |id| id == handlerId }
          end
          @eventBindingsIndex.delete handlerId
        end
      end
    end

    def unbindGroup groupName
      if @eventBindingGroups.has_key? groupName
        whisper("Unbinding: #{@eventBindingGroups[groupName].length} handlers in binding group '#{groupName}'", 3)
        @eventBindingGroups[groupName].each { |handlerId| unbind handlerId }
        @eventBindingGroups.delete groupName
      else
        whisper("Unbinding: No bindings assigned to group '#{groupName}'", 3)
      end
    end

    def kill
      trigger 'before_exit'
      setUserMode MODES['kill']
      cleanup
    end

    private

    def updateSessionDescription
      sessionDescription = "##{@sessionID}"

      sessionDescriptors = [];

      if @tracks
        sessionDescriptors << "#{@tracks.length} tracks"
      end

      filters = listFilters
      if filters.length > 0
        sessionDescriptors << filters.join(' ')
      end

      sessionDescription << " (#{sessionDescriptors.join(', ')})" if sessionDescriptors.length > 0

      if @currentTrack && @currentTrack.has_key?('title')
        sessionDescription << " playing: #{@currentTrack['title']}"
      end

      putInTempFile 'session-description', sessionDescription
    end

    def readCharacter
      # I think I ripped this from here: https://gist.github.com/acook/4190379
      STDIN.echo = false
      STDIN.raw!
      char = STDIN.getc.chr
      if char == "\e" then
        char << STDIN.read_nonblock(3) rescue nil
        char << STDIN.read_nonblock(2) rescue nil
      end
    ensure
      STDIN.echo = true
      STDIN.cooked!
      return char
    end

    def enablePlaybackInfo
      @shouldShowPlaybackInfo = true
      whisper("ENABLING realtime playback info", 3)
    end

    def disablePlaybackInfo
      @shouldShowPlaybackInfo = false
      whisper("DISABLING realtime playback info", 3)
    end

    def putsRealtime message
      if @shouldShowPlaybackInfo
        print "\n#{message}\n"
      else
        puts message
      end
    end

    def whisper message, verbosity = 1
      # 0: basically like puts, with the benefit of optional logging
      # 1: verbose user output
      # 2: very verbose user output
      # 3: errors
      # 4: debug
      formattedMessage = "	#{"-" * verbosity} #{message}"
      effectiveVerbosity = verbosity - @verbosityBoost
      if @configuredVerbosity >= effectiveVerbosity
        if @shouldShowPlaybackInfo
          STDERR.print "#{formattedMessage}\n"
        else
          STDERR.puts formattedMessage
        end
      end
      if $logFilePath && (!@logVerbosity || @logVerbosity >= effectiveVerbosity)
        open($logFilePath, 'a') { |f|
          f.puts "#{Time.now.to_f} #{formattedMessage}"
        }
      end
    end

    def getConfigFiles
      mplayerConfigFile = "#{$serviceConfigDir}/mplayer.options"

      if File.exist?(mplayerConfigFile)
        @playerOverrideCommands.concat(File.read(mplayerConfigFile).chomp.strip.gsub(/[\r\n]+/, ' ').split(/ (?=-)/))
      end
    end

    def getEnvironmentConfig
      if ENV.key? 'TUNEWICH_PLAYER_APP'
        @playerApplication = ENV['TUNEWICH_PLAYER_APP'] # @refactor: player interface
        if @playerApplication == PLAYER_APP_TERMUX
          @hasMpv = (`command -v mpv 2>&1 >/dev/null && echo -n 1 || echo -n 0` == '1')
        end
      end

      if ENV.key? 'TUNEWICH_PLAYER_OPTS'
        @playerOverrideCommands << ENV['TUNEWICH_PLAYER_OPTS']
      end

      if ENV.key? 'TUNEWICH_DB'
        setLibraryDatabasePath ENV['TUNEWICH_DB']
      end

      if ENV.key? 'TUNEWICH_DIR'
        setLibraryMediaPath ENV['TUNEWICH_DIR']
      else
        whisper("Please add `export TUNEWICH_DIR=\"<path/to/your/music/directory>\"` to your ~/.profile or similar file.", 0)
      end

      if ENV.key? 'TUNEWICH_CMD_BEFORE_TRACK'
        @commandBeforePlayer = ENV['TUNEWICH_CMD_BEFORE_TRACK']
      else
        whisper("No per-track pre-play command set.", 2)
      end

      # assume volume is not logarithmic for player on Mac
      @isVolumeAlreadyLogarithmic = !(UNAME == "Darwin")
    end

    def getSoftBPMRatio firstTrack, secondTrack
      # TODO: 1gG4Ve
      ratio = 1
      if not firstTrack.has_key? 'bpm'
        whisper("The first track being compared doesn't have BPM set.", 2)
      elsif secondTrack.has_key? 'bpm'
        whisper("The second track being compared doesn't have BPM set.", 2)
      else
        ratio = secondTrack['bpm'].to_f / firstTrack['bpm'].to_f
        if ratio >= 2.0
          ratio /= 2.0
        elsif ratio <= 0.5
          ratio *= 2.0
        end
      end
      ratio
    end

    def addNote track, noteType, newNote
      if not track[noteType]
        track[noteType] = []
      end

      track[noteType] << newNote
      track[noteType] = sortNotes track[noteType]
    end

    def editNotes notes, emphasizeNoteIndex = nil
      formattedNotes = getFormattedNoteList notes, emphasizeNoteIndex, "# ^ current"
      editedFormattedNotes = editListInVim formattedNotes
      editedNotes = editedFormattedNotes.map { |l|
        bits = l.match(/^\s*(skip)?\s*([0-9.:]+)\s+(.*?)( \(loop to "(.*)"\))?$/)
        #              /    1         2            3    4            5         /
        if bits
          note = {'time' => bits[2], 'text' => bits[3]}
          note['skip'] = true if bits[1] == 'skip'
          note['loop_target'] = bits[5] if bits[5]
          note
        else
          false
        end
      }
      editedNotes.keep_if { |note| note }
      whisper("from:\n#{JSON.pretty_generate(notes)}\nto:\n#{JSON.pretty_generate(editedNotes)}", 3)
      editedNotes
    end

    def sortNotes chapters
      chapters.sort { |a, b|
        getSecondsFromDurationString(a['time']) <=> getSecondsFromDurationString(b['time'])
      }
    end

    def getCommandInputParts(input, pattern = nil)
      pattern ||= DEFAULT_INTERACTIVE_INPUT_PATTERN
      matches = input.match(pattern)
      whisper("input: '#{input}', matches: #{matches} (from pattern '#{pattern}", 3)
      matches
    end

    def getInteractiveCommands modes = [], bindingGroupName
      trackTabComplete = Proc.new { |input|
        begin
          inputParts = getCommandInputParts(input)

          trackTitlesAndIds = []
          @tracks.each { |t|
            trackTitlesAndIds << "#{t.has_key?('title') ? t['title'] : "<untitled>"} [#{t['id']}]"
          }
          matchingTitlesAndIds = Array.new(trackTitlesAndIds) # clone titles only for visual feedback to user
          shouldShowTracks = true

          if inputParts[:query] && inputParts[:query].length > 0
            matchingTitlesAndIds = fuzzyStringSearchInListValues(inputParts[:query], trackTitlesAndIds)
            if matchingTitlesAndIds.length > 0
              if matchingTitlesAndIds.length == 1
                matchingTitle = matchingTitlesAndIds[0].sub(/ \[[^\]]+\]$/, '')
                input = input.sub!(inputParts[:query], matchingTitle)
                shouldShowTracks = false if matchingTitlesAndIds.length == 1
              end
            end
          end

          if shouldShowTracks
            heading = "#{[matchingTitlesAndIds.length, 10].min}/#{matchingTitlesAndIds.length} tracks"
            putsRealtime "\n#{heading}\n================\n#{matchingTitlesAndIds.slice(0, 10).join("\n")}"
          end
        rescue Exception => e
          whisper(e.message, 3)
        end

        input
      }

      tagTabComplete = Proc.new { |input|
        inputParts = getCommandInputParts(input)

        if inputParts[:query] && inputParts[:query].length > 0
          lastInputToken = inputParts[:query].sub(/^.* /, '')
          if lastInputToken[0] == '-'
            lastInputToken = lastInputToken[1,lastInputToken.length - 1]
          end
          tagNames = @library['tags'].keys
          @library['tags'].each { |tagName, tag|
            if tag.has_key? 'aliases'
              tagNames = tagNames + tag['aliases']
            end
          }
          guessTagNames = fuzzyStringSearchInListValues(lastInputToken, tagNames) if lastInputToken.length > 0 # @refactor: duplicating code from trackTabComplete above
          if guessTagNames && guessTagNames.length == 1
            input = input.sub!(Regexp.new("#{lastInputToken}$"), guessTagNames[0])
          elsif guessTagNames && guessTagNames.length > 1
            heading = "#{[guessTagNames.length, 10].min}/#{guessTagNames.length} tags"
            putsRealtime "\n#{heading}\n================\n#{guessTagNames.slice(0, 10).join("\n")}"
          end
        end

        input
      }

      getToggledValueByInput = Proc.new { |value, input|
        if input && input.length > 0
          value = !!(input.match(/^(y(es)?|o(n|[^f]))/i))
        else
          value = !value
        end
        value
      }

      noteCommandDefaults = {
        'args' => ['go', 'new', 'edit', 'rm', 'skip']
      }
      noteCommandDefaults['inputPattern'] = Regexp.new("^(?<option>#{noteCommandDefaults['args'].join('|')})?( *(?<offset>[+-][0-9.]+))?( *(?<query>.*?))?( +(?<remainder>\/.*))?$")
      generateNoteCommand = Proc.new { |noteType, description|
        {
          'args' => noteCommandDefaults['args'],
          'inputPattern' => noteCommandDefaults['inputPattern'],
          'action' => Proc.new { |input, command|
            inputParts = getCommandInputParts(input, command['inputPattern'])

            chosenOption = 'edit'
            if inputParts
              if inputParts[:option]
                chosenOption = inputParts[:option]
              elsif inputParts[:query]
                if inputParts[:query].match(/^[<>]+$/)
                  chosenOption = 'go'
                elsif inputParts[:query].length > 0
                  chosenOption = 'new'
                end
              end
            end

            whisper("note command - input: #{input}", 3)
            whisper("inputParts: '#{inputParts}'", 3)
            whisper("offset: '#{inputParts[:offset]}', option: '#{inputParts[:option]}', query: '#{inputParts[:query]}', remainder: '#{inputParts[:remainder]}'", 3)
            whisper("chosenOption: '#{chosenOption}'", 3)

            loadLibrary
            @currentTrack = matchExistingLibraryTrack @currentTrack

            if chosenOption == 'go'
              if @currentTrack.has_key?(noteType)
                if inputParts[:query] && inputParts[:query].length > 0
                  noteIndex = getNoteIndexByQuery(@currentTrack[noteType], inputParts[:query])
                else
                  putsRealtime getFormattedNoteList(@currentTrack[noteType], @currentNoteIndex[noteType], "# ^ current").join("\n")
                end
              else
                putsRealtime "No #{noteType} on the current track."
              end

              if noteIndex && noteIndex >= 0 && noteIndex < @currentTrack[noteType].length
                whisper("Done with #{noteType} selection. Resulting #{noteType} index: #{noteIndex}", 3)
                note = @currentTrack[noteType][noteIndex]
                seekSeconds = getSecondsFromDurationString note['time']
                offsetSeconds = inputParts[:offset].to_f if inputParts[:offset]
                seekSeconds += offsetSeconds if offsetSeconds
                seek seekSeconds, 0.5, 0.25
              elsif inputParts[:option] && inputParts[:option].length > 0
                putsRealtime "No #{noteType} found."
              end
            end

            if chosenOption == 'rm' # remove
              if @commandinputStartPlayerTime
                # TODO 1gzTHg: take input to choose a note
                noteIndex = getNoteIndexAtTime @currentTrack[noteType], @commandinputStartPlayerTime
                if noteIndex > -1
                  @currentTrack[noteType].delete_at noteIndex
                  writeLibraryToFile
                end
              else
                whisper("No current track / current time; can't tell which #{noteType} to remove.", 0)
              end
            end

            if chosenOption == 'skip'
              if @commandinputStartPlayerTime
                noteIndex = getNoteIndexAtTime @currentTrack[noteType], @commandinputStartPlayerTime
                if noteIndex > -1
                  @currentTrack[noteType][noteIndex]['skip'] = true
                  writeLibraryToFile
                  seekToNextPlayableNoteOrSkip @currentTrack[noteType], @currentNoteIndex[noteType]
                end
              else
                whisper("No current track / current time; can't tell which #{noteType} to skip.", 0)
              end
            end

            if chosenOption == 'new'
              @currentTrack[noteType] ||= []
              addNote(
                @currentTrack,
                noteType,
                {
                  'time' => getDurationStringFromSeconds(@commandinputStartPlayerTime),
                  'text' => inputParts[:query]
                }
              )

              chosenOption = 'edit' if inputParts[:query].length == 0

              writeLibraryToFile
            end

            if chosenOption == 'edit'
              notes = editNotes(@currentTrack[noteType] || [], @currentNoteIndex[noteType])
              if notes && notes.length > 0
                @currentTrack[noteType] = sortNotes notes
              elsif @currentTrack[noteType] && @currentTrack[noteType].length > 0
                if confirm("Do you want to clear #{noteType} from this track?")
                  @currentTrack.delete noteType
                end
              end
              writeLibraryToFile
              whisper("#{noteType} changes written to library file", 3)
            end

            {:chainedInput => inputParts[:remainder]}
          },
          'tabComplete' => Proc.new { |input, command|
            inputParts = getCommandInputParts(input, command['inputPattern'])
            whisper("noteType: '#{noteType}'", 3)
            whisper("pattern: '#{command['inputPattern']}'", 3)
            whisper("inputParts: #{inputParts}", 3)
            whisper("offset: '#{inputParts[:offset]}', option: '#{inputParts[:option]}', query: '#{inputParts[:query]}', remainder: '#{inputParts[:remainder]}'", 3)

            if @currentTrack.has_key?(noteType)
              if inputParts[:query] && inputParts[:query].length > 0
                noteTexts = @currentTrack[noteType].map { |note| note['text'] }
                guessChapterTexts = fuzzyStringSearchInListValues(inputParts[:query], noteTexts) if inputParts[:query].length > 0
                if guessChapterTexts && guessChapterTexts.length == 1
                  input = input.sub!(inputParts[:query], guessChapterTexts[0])
                elsif guessChapterTexts && guessChapterTexts.length > 1
                  heading = "#{[guessChapterTexts.length, 10].min}/#{guessChapterTexts.length} #{noteType}"
                  putsRealtime "\n#{heading}\n================\n#{guessChapterTexts.slice(0, 10).join("\n")}"
                end
              elsif inputParts[:option] && inputParts[:option].length > 0
                # TODO 1gzoGh: it'd be nice to put in a space if inputParts[:offset] is given
                putsRealtime getFormattedNoteList(@currentTrack[noteType], @currentNoteIndex[noteType], "# ^ current").join("\n")
              end
            end

            input
          }
        }
      }

      generateVisualCommand = Proc.new { |property|
        {
          'description' => "#{property.upcase} [DURATION] - Blend to #{property}",
          'args' => ['out', 'in'],
          'showStatus' => Proc.new { |input, command|
            putsRealtime "#{property}: #{@currentVisualEffects[property]}"
          },
          'action' => Proc.new { |input, command|
            inputParts = getCommandInputParts input, /^(?<target>out|in|[0-9.-]+)( (?<duration>[0-9.]+))?[^\/]*(?<remainder>.*)$/
            if inputParts[:target]
              targetValue = @currentValue
              case inputParts[:target]
              when 'out'
                targetValue = -100
              when 'in'
                targetValue = 0 # normal Value
              else
                targetValue = inputParts[:target].to_f
                whisper("turning '#{inputParts[:target]}' to  '#{targetValue}'", 3)
              end
            end

            duration = inputParts[:duration] && inputParts[:duration].length > 0 && getSecondsFromDurationString(inputParts[:duration]) || 1

            tween(
              @currentVisualEffects[property],
              targetValue,
              duration,
              Proc.new { |x|
                case @playerApplication
                when PLAYER_APP_DEFAULT
                  sendMplayerCommand "#{property} #{x} 1"
                when PLAYER_APP_TERMUX
                  whisper('no support for visual effects with termux-media-player', 5)
                end
                @currentVisualEffects[property] = x
              }
            )

            {:chainedInput => inputParts[:remainder]}
          }
        }
      }

      generateMacroCommand = Proc.new { |macro, description|
        {
          'description' => "#{description} Same as `#{macro}`.",
          'action' => Proc.new { |input, command|
            inputParts = getCommandInputParts(input)
            command = macro.sub(/\bINPUT\b/, inputParts[:query] || '')
            {:chainedInput => "#{command} #{inputParts[:remainder]}"}
          }
        }
      }

      # TODO: 1gG4fU @refactor
      interactiveCommands = {
        'base' => {
          'play' => {
            'description' => 'Start playing (enter "play" mode).',
            'action' => Proc.new {
              setUserMode 'play'
              false
            }
          },
          'wait' => {
            'description' => '[EVENT | random [RANGE [ + MINIMUM]]] Wait for an event, or some number of seconds, to execute following chained commands. Random defaults are RANGE: 25, MINIMUM: 5. Events: chapter_change, play_start, play_end, fade_start, fade_end, speed_ramp_start, speed_ramp_end, download_end. You may use fuzzy substrings of the event names, e.g. "ch" will match "chapter_change", and "ple" will match "play_end". Yout can also wait a random',
            'args' => [
              'chapter_change',
              'play_start',
              'play_end',
              'fade_start',
              'fade_end',
              'speed_ramp_start',
              'speed_ramp_end',
              'download_end',
              'transcode_complete',
              'random'
            ],
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)

              if inputParts[:remainder] && inputParts[:remainder].length > 0
                output = {
                  :chainedInput => inputParts[:remainder]
                }

                waitEvent = nil
                waitInput = inputParts[:query].chomp.strip
                if waitInput.length > 0
                  waitTime = nil

                  randomInput = waitInput.match(/^random( (?<range>[0-9.]+))?( *\+ *(?<minimum>[0-9.]+))?/)
                  if randomInput
                    minimum = getSecondsFromDurationString(randomInput[:minimum]) || 5
                    range = getSecondsFromDurationString(randomInput[:range]) || 25
                    waitTime = Random.rand(range) + minimum
                  elsif waitInput.match(/^[0-9:.]+\s*$/)
                    waitTime = getSecondsFromDurationString waitInput
                  end

                  if waitTime
                    whisper("Waiting for #{waitTime} seconds", 2)
                    waitEvent = "timed_wait_in_player_#{@currentPlayerIndex}"
                    Thread.new {
                      sleep waitTime
                      whisper("triggering #{waitEvent}", 3)
                      trigger waitEvent
                    }
                  else
                    waitEvent = firstFuzzyMatchValue waitInput.strip.downcase, command['args']
                    if !waitEvent
                      putsRealtime "Unknown event '#{waitInput}'. Not waiting. Available events: #{command['args'].join ', '}"
                    end
                  end
                else
                  putsRealtime "The /wait command expects either a number of seconds, or an event name"
                end
                if waitEvent
                  output[:bindChainToEvent] = waitEvent
                  output[:bindingGroupName] = bindingGroupName
                end
              else
                putsRealtime "Put another command after /wait"
                output = nil
              end

              output
            }
          },
          'macro' => {
            'description' => "[save] NAME [COMMANDS] - Save or run some command, or chain of commands. With the 'save' keyword, this command cannot be chained into any other commands, as it will take all following commands as part of the macro.",
            'args' => ['save'],
            'inputPattern' => /^((?<save>save) )?(?<name>\w*)(?<guff>.*?)( +(?<remainder>\/.*))?$/,
            'action' => Proc.new { |input, command|
              output = {}
              inputParts = getCommandInputParts(input, command['inputPattern'])

              if inputParts || !inputParts[:guff] || inputParts[:guff].length == 0
                if inputParts[:save] && inputParts[:save].length > 0
                  loadLibrary
                  @library['commandMacros'] ||= {}
                  @library['commandMacros'][inputParts[:name]] = inputParts[:remainder]
                  writeLibraryToFile
                else
                  output[:chainedInput] = inputParts[:remainder]
                  macroName = firstFuzzyMatchValue(inputParts[:name], @library['commandMacros'].keys)
                  if @library['commandMacros'].has_key?(macroName)
                    output[:chainedInput] = "#{@library['commandMacros'][macroName]} #{output[:chainedInput]}"
                  end
                end
              else
                putsRealtime "Invalid input to the 'macro' command."
                output = nil
              end

              output
            },
            'tabComplete' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input, command['inputPattern'])

              macroNames = @library['commandMacros'].keys
              if inputParts[:name] && inputParts[:name].length > 0
                guessMacroNames = fuzzyStringSearchInListValues(inputParts[:name], macroNames) if inputParts[:name].length > 0 # @refactor: duplicating code from trackTabComplete above
                if guessMacroNames && guessMacroNames.length == 1
                  input = input.sub!(Regexp.new("#{inputParts[:name]}$"), guessMacroNames[0])
                elsif guessMacroNames && guessMacroNames.length > 1
                  heading = "#{[guessMacroNames.length, 10].min}/#{guessMacroNames.length} macros"
                  putsRealtime "\n#{heading}\n================\n#{guessMacroNames.slice(0, 10).join("\n")}"
                end
              else
                macroDescriptions = @library['commandMacros'].map { |key, commands| "#{key}: #{commands}" }
                putsRealtime "#{macroDescriptions.join("\n")}"
              end

              input
            }
          },
          'all' => {
            'description' => "Load entire library.",
            'action' => Proc.new { |input, command|
              useEntireLibrary
              {:chainedInput => input}
            }
          },
          'turn' => {
            # TODO: 1gG4hV
            'description' => "Use all this track's tags to populate the track list.",
            'action' => Proc.new { |input, command|
              trackTags = getTrackTags @currentTrack
              if trackTags.length > 0
                putsRealtime "Playing tracks with similar tags: #{trackTags.join ', '}"
                @trackFilters ||= {}
                @trackFilters['tag'] = "+#{trackTags.join ' +'}"
                useEntireLibrary
                @trackIndex = 1 # next track (current track will almost certainly be at index 0)
                if @shuffle
                  @shuffle = false
                  putsRealtime "shuffle: off"
                end
              else
                putsRealtime "Add some tags to this track to find similar tracks."
              end
              {:chainedInput => input}
            }
          },
          'rate' => {
            'description' => "Rate this track + or -, or give it an explicit number.",
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              newRating = inputParts[:query] if (inputParts[:query].length > 0) && (inputParts[:query].match(/^[+-]?[0-9]*/))
              loadLibrary
              @currentTrack = matchExistingLibraryTrack @currentTrack
              oldRating = @currentTrack['rating']
              if newRating.length < 1
                putsRealtime "current rating: #{@currentTrack['rating']}"
              elsif newRating.match(/^[+-][0-9]*$/)
                if newRating.match(/^[+-]$/) # if it's simply "+" or "-", append "1"
                  newRating = newRating + '1';
                end
                if not @currentTrack['rating']
                  @currentTrack['rating'] = 0
                end
                @currentTrack['rating'] += newRating.to_i
              else
                @currentTrack['rating'] = newRating.to_i
              end
              if oldRating != @currentTrack['rating'] && !@currentTrack['unattached']
                addTrackToLibrary @currentTrack if @currentTrack['unattached']
                writeLibraryToFile
              end
              {:chainedInput => inputParts[:remainder]}
            }
          },
          'bpm' => {
            'description' => "Interactively set the beats-per-minute of the track. Do '/bpm 0' to remove (not chainable)",
            'showStatus' => Proc.new { |command|
              putsRealtime "BPM: #{@currentTrack.has_key?('bpm') ? @currentTrack['bpm'] : "none"}"
            },
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              commitBPM = false

              if inputParts[:query].length > 0
                bpm = inputParts[:query].to_f
                commitBPM = true
              else
                bpm = getUserInputBPM
                if bpm
                  commitBPM = true
                  bpm /= @speed
                end
              end

              if commitBPM
                loadLibrary
                @currentTrack = matchExistingLibraryTrack @currentTrack
                if bpm == 0
                  @currentTrack.delete 'bpm' if @currentTrack.has_key? 'bpm'
                else
                  @currentTrack['bpm'] = bpm
                end
                writeLibraryToFile
              else
                putsRealtime "Canceling: leaving track BPM alone."
              end
              command['showStatus'].call

              {:chainedInput => inputParts[:remainder]}
            }
          },
          'tag' => {
            'description' => "Tag this track.",
            'showStatus' => Proc.new {
              putsRealtime "current tags: #{getTrackTags @currentTrack}"
            },
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              if !inputParts[:query] || inputParts[:query].length < 1
                command['showStatus'].call
              else
                tagsToAdd = inputParts[:query].split(/[, ]+/)
                whisper("all tags given: #{tagsToAdd}", 2)
                tagsToRemove = []
                tagsToRemove.replace(tagsToAdd).keep_if {|name| name.match(/^-/)}
                tagsToRemove.map! {|name| name.sub(/^-/, '')}
                tagsToAdd.delete_if {|name| name.match(/^-/)}

                loadLibrary
                addTrackToTags @currentTrack, tagsToAdd
                removeTagsFromTrack @currentTrack, tagsToRemove
                addTrackToLibrary @currentTrack if @currentTrack['unattached']
                writeLibraryToFile
              end
              {:chainedInput => inputParts[:remainder]}
            },
            'tabComplete' => tagTabComplete
          },
          'tagall' => {
            'description' => "Tag all tracks in the current tracklist.",
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              if inputParts[:query] && inputParts[:query].length > 0
                tagsToAdd = inputParts[:query].split(/[, ]+/)
                tagsToRemove = []
                tagsToAdd.each { |tagName|
                  if /^-/.match tagName
                    tagsToRemove << tagName.gsub(/^-/, '')
                    tagsToAdd.delete tagName
                  end
                }
                loadLibrary
                @tracks.each { |t|
                  addTrackToTags t, tagsToAdd
                  removeTagsFromTrack t, tagsToRemove
                  addTrackToLibrary t if t['unattached']
                }
                writeLibraryToFile
              end
              {:chainedInput => inputParts[:remainder]}
            },
            'tabComplete' => tagTabComplete
          },
          'list' => {
            'description' => "Load, save, update, or remove a playlist.",
            'args' => ['save', 'rm', 'update'],
            'inputOptions' => Proc.new { @library['playlists'].keys },
            'inputPattern' => /^((?<action>(save|rm|update)) *)?(?<query>.*?)?(?<remainder> \/.*)?$/,
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input, command['inputPattern'])

              loadLibrary

              playlistNames = command['inputOptions'].call
              chosenName = firstFuzzyMatchValue(inputParts[:query], playlistNames) if inputParts[:query] && inputParts[:query].length > 0
              shouldShowPlaylistNames = false

              if inputParts[:action] && inputParts[:action] == 'update'
                if !chosenName || !@library['playlists'].has_key?(chosenName)
                  shouldShowPlaylistNames = true
                  if !inputParts[:query]
                    whisper("No list name given.", 0)
                  else
                    whisper("No list found by name '#{inputParts[:query]}'.", 0)
                  end
                elsif !@library['playlists'][chosenName]['src'] || @library['playlists'][chosenName]['src'].length == 0
                  whisper("Unable to update list '#{inputParts[:query]}': no source URL.", 0)
                else
                  shouldGetAllTracks = true
                  urls = [@library['playlists'][chosenName]['src']]
                  newTracks = getTracksFromURLs(urls, shouldGetAllTracks)

                  @library['playlists'][chosenName]['tracks'] ||= []
                  initialListLength = @library['playlists'][chosenName]['tracks'].length
                  @library['playlists'][chosenName]['tracks'].concat(newTracks.map { |t| t['id'] })
                  @library['playlists'][chosenName]['tracks'].uniq!
                  lengthDiff = @library['playlists'][chosenName]['tracks'].length - initialListLength
                  whisper("Added #{lengthDiff} tracks to playlist '#{chosenName}'", 0)
                  writeLibraryToFile
                end
              elsif inputParts[:action] && inputParts[:action] == 'save'
                @library['playlists'] ||= {}
                @library['playlists'][inputParts[:query]] = {
                  'tracks' => @tracks.map { |t| t['id'] }
                }
                writeLibraryToFile
              elsif inputParts[:action] && inputParts[:action] == 'rm'
                if chosenName
                  if confirm("Delete the playlist '#{chosenName}'?")
                    @library['playlists'].delete inputParts[:query]
                    writeLibraryToFile
                  end
                else
                  shouldShowPlaylistNames = true
                end
              else
                if chosenName
                  usePlaylist chosenName
                else
                  shouldShowPlaylistNames = true
                end
              end

              putsRealtime playlistNames.join("\n") if shouldShowPlaylistNames

              {:chainedInput => inputParts[:remainder]}
            }
          },
          'tracks' => {
            'description' => 'Edit playing tracklist in Vim.',
            'args' => ['clear'],
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)

              editedTrackList = []
              if inputParts[:query] != 'clear'
                editedTrackList = editTrackList @tracks
                # writeTitleChangesInTrackList editedTrackList # TODO 1gSlF1: Do this only if the list being edited is not already the canonical library track list, in which case we cannot determine if there was a change
                # writeLibraryToFile # TODO 1gSlF1
              end

              useTracks editedTrackList, false
              putsRealtime "#{@tracks.length} tracks selected"
              {:chainedInput => inputParts[:remainder]}
            }
          },
          'go' => {
            'description' => "Go to a track in the current list.",
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              if inputParts[:query] && inputParts[:query].length > 0
                @trackIndex = findTrackIndex inputParts[:query]
              end
              {:chainedInput => inputParts[:remainder]}
            },
            'tabComplete' => trackTabComplete
          },
          'more' => {
            'description' => "Play all tracks linked from this media's source page (e.g. recommended videos on YouTube.com).",
            # 'args' => ['creator'], # TODO: enable jumping off from other related pages/lists
            'action' => Proc.new { |input, command|
              if @currentTrack['type'] == 'youtube'
                disablePlaybackInfo
                tracks = getYouTubeTracksFromPage(@currentTrack['link'] || @currentTrack['src'])
                enablePlaybackInfo
              elsif @currentTrack['type'] == 'soundcloud'
                disablePlaybackInfo
                tracks = getSoundcloudRecommendations(@currentTrack['link'] || @currentTrack['src'])
                enablePlaybackInfo
              else
                putsRealtime "The /more currently only supports YouTube and Soundcloud tracks."
              end

              if tracks
                tracks.shift # remove the first track, which will be the main video on the page
                @trackIndex = @tracks.length
                @trackFilters = nil
                useTracks tracks, true # and set track index to the first
              end
              {:chainedInput => input}
            }
          },
          'info' => {
            'description' => "Show track info. Track is: without input = currently playing track; with '>' = the track that will play next; with numeric input = the track at that position in the track list; any other input = the track with the title that best matches that input",
            'args' => ['all'],
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input, /^((?<arg>all)( +|$))?(?<query>.*?)( (?<remainder>\/.*))?$/)
              tracks = []
              shouldUseInnerTrackIndex = false
              trackIndexes = {}
              if inputParts[:arg] && inputParts[:arg] == 'all'
                shouldUseInnerTrackIndex = true
                tracks.concat(@tracks)
              elsif inputParts[:query] && inputParts[:query].length > 0
                if inputParts[:query] && inputParts[:query].length > 0
                  trackIndex = findTrackIndex(inputParts[:query])
                  if trackIndex
                    tracks << @tracks[trackIndex]
                    trackIndexes[@tracks[trackIndex]['id']] = trackIndex
                  else
                    whisper("TODO: search all tracks for term, and confirm with user to use it", 1)
                  end
                end
              else
                tracks << @currentTrack
                trackIndexes[@currentTrack] = @trackIndex if @tracks[@trackIndex] === @currentTrack
                # ^ the user may have altered the track list, so that it no longer includes the currently playing track
              end

              tracks.each { |track, index|
                if shouldUseInnerTrackIndex
                  trackIndex = index
                elsif trackIndexes.has_key?(track['id'])
                  trackIndex = trackIndexes[track['id']]
                else
                  trackIndex = nil
                end

                if track
                  alreadyHas = {
                    :title => track.has_key?('title') && track['title'].strip.length > 0,
                    :duration => track.has_key?('duration'),
                    :description => track.has_key?('description') && track['description'].strip.length > 0,
                    :bpm => track.has_key?('bpm')
                  }
                  tagNames = getTrackTags track

                  outputMessageLines = []
                  info = {}
                  if !alreadyHas[:title] || !alreadyHas[:duration]
                    if track['type'] === 'youtube'
                      info = getYouTubeTrackInfo track['src']
                    elsif track['type'] === 'soundcloud'
                      info = getSoundcloudTrackInfo track['src']
                    end
                    updateTrackInfo track, info
                  end
                  outputMessageLines << "     title : #{track['title']}" if track.has_key? 'title'
                  outputMessageLines << "      tags : #{tagNames.join ', '}" if tagNames.length > 0
                  outputMessageLines << "sourceTags : #{info['sourceTags']}" if info && info.has_key?('sourceTags')
                  outputMessageLines << "    rating : #{track['rating']}" if track['rating']
                  outputMessageLines << "       bpm : #{track['bpm']}" if alreadyHas[:bpm]

                  if track == @currentTrack
                    timeMessage = ""
                    timeMessage << "			time : #{getDurationStringFromSeconds @currentPlayerTime}" if @currentPlayerTime
                    if !alreadyHas[:duration] || getSecondsFromDurationString(track['duration']) == 0
                      durationResponseFromPlayer = getMplayerProperty('get_time_length', /^(ANS_LENGTH=)(.*?)(\?)?$/, 0.1)
                      whisper("Got duration from player: '#{durationResponseFromPlayer}'", 2)
                      if durationResponseFromPlayer
                        track['duration'] = getDurationStringFromSeconds durationResponseFromPlayer.to_f
                      end
                    end
                    timeMessage << " / #{track['duration']}"
                    timeMessage << " (#{@speed}x)" if @speed != 1
                    if @currentPlayerTime && @currentTrack.has_key?('chapters')
                      chapterIndex = getNoteIndexAtTime @currentTrack['chapters'], @currentPlayerTime
                      if chapterIndex > -1
                        timeMessage << "\n	 chapter : #{@currentTrack['chapters'][chapterIndex]['text']}"
                      end
                    end
                    outputMessageLines << "#{timeMessage}"
                  else
                    outputMessageLines << "	duration : #{track['duration']}" if alreadyHas[:duration]
                  end

                  outputMessageLines << "downloaded : #{trackFileExists? track}"
                  outputMessageLines << "#{track['description']}" if track.has_key?('description')
                  if !info.has_key? 'link'
                    info['link'] = track['link'] || track['src']
                    if track['type'] === 'youtube'
                      info['link'] = "http://youtu.be/#{track['src']}"
                    end
                  end
                  outputMessageLines << "      link : #{info['link']}" if info

                  outputMessageLines << "     index : #{trackIndex + 1}/#{@tracks.length}" if trackIndex
                  outputMessageLines << "    volume : #{@volume}/100" if track == @currentTrack

                  if @configuredVerbosity > 1 && tagNames.length > 0
                    whisper("about to loop through tagNames", 4)
                    tagNames.each { |tagName|
                      whisper("digging up ancestors of #{tagName}", 4)
                      ancestorTags = getAncestorTagNames tagName
                      whisper("ancestors of tag '#{tagName}': #{ancestorTags}", 1) if ancestorTags.length > 0
                    }
                  end

                  outputMessageLines << "------------------------------"
                  putsRealtime outputMessageLines.join "\n"
                  notify outputMessageLines.join "\n"
                else
                  putsRealtime "Cannot show info. No track found."
                end
              }

              {:chainedInput => inputParts[:remainder]}
            },
            'tabComplete' => trackTabComplete
          },
          'search' => {
            'description' => "<query> Search YouTube. (not chainable)",
            'action' => Proc.new { |input, command|
              if input and input.length > 1
                disablePlaybackInfo
                searchedTracks = searchYouTube(input)
                enablePlaybackInfo
                if searchedTracks
                  @trackIndex = @tracks.length
                  @trackFilters = nil
                  useTracks searchedTracks
                end
              else
                putsRealtime "Enter a search term of at least 2 characters."
              end
              nil
            }
          },
          'net' => {
            'description' => 'Toggle network enabled.',
            'args' => ['on', 'off'],
            'showStatus' => Proc.new {
              putsRealtime "network: #{@networkEnabled ? 'on' : 'off'}"
            },
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)

              @networkEnabled = getToggledValueByInput.call(@networkEnabled, inputParts[:query])

              command['showStatus'].call

              {:chainedInput => inputParts[:remainder]}
            }
          },
          'download' => {
            'description' => "OPTIONS\nget: show the command, or the path to the file if already downloaded.\nauto: download any file upon playing.\nWith no options, downloads the current track for faster play in the future.",
            'args' => ['get', 'auto', 'all'],
            'showStatus' => Proc.new {
              putsRealtime "Auto download: #{@autoDownload ? 'on' : 'off'}"
            },
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)

              options = inputParts[:query] && inputParts[:query].length > 0 ? inputParts[:query].split(/\s+/) : []

              shouldEchoCommand = false
              shouldShowStatus = false
              downloadOptions = {}
              tracks = []
              isTrackSelectionOptionUsed = false
              options.each { |option|
                case option
                when 'auto'
                  @autoDownload = !@autoDownload
                  shouldShowStatus = true
                when 'get'
                  shouldEchoCommand = true
                when 'all'
                  isTrackSelectionOptionUsed = true
                  tracks.concat(@tracks)
                else
                  isTrackSelectionOptionUsed = true
                  trackIndex = findTrackIndex option
                  tracks << @tracks[trackIndex] if trackIndex
                end
              }

              tracks << @currentTrack if !isTrackSelectionOptionUsed

              perTrackAction = nil
              if shouldShowStatus
                command['showStatus'].call
              elsif shouldEchoCommand
                perTrackAction = Proc.new { |track|
                  trackFiles = @forceStreaming ? [] : findTrackFiles(track)
                  if trackFiles.length > 0
                    whisper(trackFiles.join("\n"), 0)
                  else
                    putsRealtime getDownloadCommand(track, downloadOptions)
                  end
                }
              else
                downloadOptions['sync'] = true
                perTrackAction = Proc.new { |track, index|
                  if !@forceStreaming && trackFileExists?(track)
                    putsRealtime "This file is already downloaded."
                  else
                    downloadOptions['suppressBeginEvent'] = (index > 0)
                    downloadOptions['suppressEndEvent'] = (index < tracks.length - 1)

                    downloadTrack track, downloadOptions
                  end
                }
              end

              allTracksThread = Thread.new {
                tracks.each_with_index { |track, index| perTrackAction.call(track, index) } if perTrackAction
              }

              allTracksThread.join if shouldEchoCommand

              {:chainedInput => inputParts[:remainder]}
            }
          },
          'transcode' => {
            'description' => "[FORMAT] [FFMPEG_OPTIONS]  Transcode downloaded file to another format (default Ogg/Vorbis). This is the same as doing '/format FORMAT /download'.",
            'args' => ['vorbis'],
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input, /^(?<format>\w+)?( (?<options>[^\/].*?))?( *(?<remainder>\/.*))?$/)

              outputFormat = inputParts[:format] && inputParts[:format].length > 0 ? inputParts[:format] : 'vorbis'

              trackFiles = findTrackFiles(@currentTrack) if @currentTrack
              if trackFiles
                if trackFiles.length > 1
                  commandPrompt "pick a file:", nil, Proc.new { |fileQuery|
                    foundOneTrack = false
                    filteredFiles = fuzzyStringSearchInListValues(trackFiles, fileQuery)
                    if filteredFiles.length == 1
                      trackFiles = filteredFiles
                      foundOneTrack = true
                    end

                    !foundOneTrack
                  }
                end
                if trackFiles.length == 1
                  commandArgs = ["-i \"#{trackFiles[0]}\""]

                  case outputFormat
                  when 'vorbis'
                    outputFileExtension = 'ogg'
                    commandArgs << "-c:a libvorbis"
                  else
                    outputFileExtension = outputFormat
                  end

                  commandArgs << inputParts[:options] if inputParts[:options] if inputParts[:options] && inputParts[:options].length > 0

                  outputFilePath = trackFiles[0].sub(/\.[^.]+$/, ".#{outputFileExtension}")
                  commandArgs << "\"#{outputFilePath}\""
                  transcodeOutputFile = createTempFile "transcoding.#{Random.rand(1024)}"
                  command = "ffmpeg #{commandArgs.join(' ')} 2>&1 >#{transcodeOutputFile}"
                  Thread.new {
                    system(command)
                    trigger "transcode_complete"
                  }
                elsif trackFiles.length > 1
                  putsRealtime "Please repeat the command with a specific fragemnt of one of these filenames:\n#{trackFiles.join("\n")}"
                else
                  putsRealtime "The current track does not have any downloaded files to transcode."
                end
              else
                putsRealtime getDownloadCommand(track, downloadOptions)
              end

              {:chainedInput => inputParts[:remainder]}
            }
          },
          'add' => {
            'description' => '[all] <URL>[,<URL>,...] [<TAG>[,<TAG>,...]] - Add a new track to the play queue. URLs: comma-separated URLs or YouTube IDs (Some URLs will add multiple tracks, like a bandcamp album (or TODO: YouTube playliist); tags: comma-separated tags to add to the tracks.',
            'args' => ['all', 'list'],
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input, /^((?<option>(all|list)) *)?(?<query>[^ ]*?)(?<tags> .*?)?(?<remainder> \/.*)?$/)
              urls = inputParts[:query].split ',' if inputParts[:query]
              tags = inputParts[:tags].split ',' if inputParts[:tags]
              getAllVideos = (inputParts[:option] && inputParts[:option].length > 0)
              saveAsList = (getAllVideos && inputParts[:option] == 'list')
              whisper("urls: #{urls}\ntags: #{tags}", 3)
              if urls && urls.length > 0
                tracks = getTracksFromURLs urls, getAllVideos
                if saveAsList
                  playlistHTMLTitle = `curl -sL "#{urls[0]}" | grep '<title>'`
                  playlistName = playlistHTMLTitle.sub(/.*<title>(.*?)( - YouTube)?<\/title>.*/, '\1').chomp if playlistHTMLTitle && playlistHTMLTitle.kind_of?(String)

                  # if !playlistName || playlistName.length == 0
                  #   prompt "Please give this playlist a name" # TODO: simple text prompt, wrapping commandPrompt
                  # end

                  if playlistName && playlistName.length > 0
                    loadLibrary
                    putsRealtime "Using title: '#{playlistName}'"
                    @library['playlists'] ||= {}
                    newPlaylist = {
                      'tracks' => tracks.map { |t| t['id'] },
                    }
                    newPlaylist['src'] = urls[0] if urls.length == 1
                    @library['playlists'][playlistName] = newPlaylist
                    writeLibraryToFile
                  else
                    putsRealtime "Unable to add list without a name"
                  end
                end
                putsRealtime "Adding #{tracks.length} tracks to queue. Playing next."
                if tracks.length && tags && tags.length > 0
                  tracks.each { |t|
                    addTrackToTags t, tags
                  }
                end
                useTracks tracks

                @trackIndex = @tracks.length - tracks.length
              end
              {:chainedInput => inputParts[:remainder]}
            }
          },
          'feed' => {
            'description' => 'Load a feed that has been saved with /add (currently only podcasts).',
            'inputOptions' => Proc.new { |command|
              @library['feeds'].map { |libraryFeed| libraryFeed['title'] }
            },
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)

              feed = nil

              feedNames = command['inputOptions'].call
              availableFeedsMessage = "Available feeds:\n	#{feedNames.join "\n	"}"
              if @library.has_key?('feeds') && @library['feeds'].length > 0
                if inputParts[:query] && inputParts[:query].length > 0
                  match = firstFuzzyMatch inputParts[:query], feedNames

                  if match && match[:score] > 1
                    feed = @library['feeds'][match[:index]]
                    if !@networkEnabled
                      putsRealtime "Found feed \"#{feed['title']}\". Network is disabled, not fetching feed contents."
                    else
                      putsRealtime "Loading podcast: \"#{feed['title']}\"..."
                      feedTracks = loadPodcast feed['src']
                      useTracks feedTracks if feedTracks
                      putsRealtime "Loaded #{feedTracks.length} tracks. Playing oldest next."
                      @trackIndex = @tracks.length - feedTracks.length
                    end
                  else
                    putsRealtime "No matching feed found. #{availableFeedsMessage}"
                  end
                else
                  putsRealtime availableFeedsMessage
                end
              else
                putsRealtime "No feeds to choose from. Add one with /add."
                whisper("@library.keys: #{@library.keys}", 3)
              end

              {:chainedInput => inputParts[:remainder]}
            }
          },
          'chapter' => generateNoteCommand.call('chapters', 'Skip to a chapter, or show chapter list. Input: [optional seconds offset], number or name of chapter; or "<" or ">" to go back or forward, multiples to go further.'),
          'note' => generateNoteCommand.call('notes', "Make a note on this track, with a timestamp taken from the time you type '/' to begin the command (so that you can take your time composing the note without worrying about the moment passing)."),
          'filter' => {
            'description' => 'Set filters (same as -f/--filter). With no arguments, the filters are edited in Vim.',
            'showStatus' => Proc.new { |command|
              if @trackFilters || @trackExcludeFilters
                filtersList = listFilters
                putsRealtime "Current filters:\n" + filtersList.join("\n")
              else
                putsRealtime "No filters"
              end
            },
            'args' => ['clear'],
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              if inputParts[:query] && inputParts[:query].length > 0
                if inputParts[:query] == 'clear'
                  filters = []
                else
                  filters = parseOptionParameters inputParts[:query]
                end
              else
                filtersList = listFilters
                filterInstructions = []
                filterInstructions << FILTER_HELP_1
                filterInstructions << FILTER_HELP_2
                filterInstructions << FILTER_HELP_3
                filterInstructions << '' # empty line
                filterInstructions << "Available tags: \n	#{listAllTagsWithCountsAndAliases.join "\n	"}"
                filterInstructions << "For music without words: -tag=verbal acapella visual live noise delete missing-source"
                instructions = filterInstructions.join "\n"
                filters = parseOptionParameters editListInVim(filtersList, instructions).join ','
              end

              @trackFilters = {}
              @trackExcludeFilters = {}
              filters.each { |name, filter|
                if name.match(/^-/)
                  @trackExcludeFilters[name.sub(/^-/, '')] = filter
                else
                  @trackFilters[name] = filter
                end
              }

              filterTracksOnDeck
              {:chainedInput => inputParts[:remainder]}
            },
            'tabComplete' => Proc.new { |input|
              if input.match(/tag=[^=]*$/)
                tagListString = input.sub(/tag=([^=]*)$/, '\1')
                lastTag = tagListString.split(/(,|\s)+/).pop
                if lastTag && lastTag.length > 0
                  lastTag.sub!(/^\+/, '')
                  pattern = Regexp.new("#{lastTag}$") # assign before calling tagTabComplete
                  tabCompletedTag = tagTabComplete.call(lastTag) # alters lastTag by reference
                  input = input.sub(pattern, tabCompletedTag) if tabCompletedTag
                end
              end
              input
            }
          },
          'exit' => {
            'description' => 'Exit tunewich when the current track finishes or is quit.',
            'action' => Proc.new { |input, command|
              kill
              {:chainedInput => input}
            }
          },
          'verbose' => {
            'description' => 'Set level of verbosity: -1 (silent) to 5 (extra debugging).',
            'showStatus' => Proc.new {
              putsRealtime "verbosity set to #{@configuredVerbosity}"
            },
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              if inputParts[:query] && inputParts[:query].length > 0
                @configuredVerbosity = inputParts[:query].to_i
              end
              command['showStatus'].call

              {:chainedInput => inputParts[:remainder]}
            }
          },
          'format' => {
            'description' => '[get]: Choose the file format to download/stream, or list available formats (e.g. "mp4"; default "m4a").',
            'showStatus' => Proc.new {
              putsRealtime "preferred file format: #{@preferredFileFormat}"
            },
            'args' => ['get', 'm4a', 'mp4', 'bestaudio', 'bestvideo', '[height=720]'],
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              if inputParts[:query].length > 0
                if inputParts[:query] == 'get'
                  if @currentTrack && @currentTrack['type'] == 'youtube'
                    putsRealtime "\n" + `youtube-dl --list-formats -- "#{@currentTrack['id']}"`
                  else
                    putsRealtime "Currently only able to list available formats from YouTube media."
                  end
                else
                  @preferredFileFormat = inputParts[:query].chomp
                end
              else
                command['showStatus'].call
              end
              {:chainedInput => inputParts[:remainder]}
            }
          },
          'relatetags' => {
            'description' => '(USAGE: /relatetags A B...) Make tag A the child of tag(s) B...',
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)

              if inputParts[:query].length > 0
                tagNames = inputParts[:query].split(TAG_INPUT_SPLIT)
                # TODO: optionally remove parent tags from all tracks which contain child tag
                if tagNames && tagNames.length > 0
                  childTag = relateTags tagNames
                  if childTag
                    writeLibraryToFile
                  else
                    whiper("There was a problem with relating the tags. Your changes were not saved.", 0)
                  end
                else
                  whisper("Unable to parse tag names from command input.", 0)
                end
              end

              {:chainedInput => inputParts[:remainder]}
            },
            'tabComplete' => tagTabComplete
          },
          'jointag' => {
            'description' => '(USAGE: /jointag A... B) Make tag(s) A aliases of tag B.',
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)

              if inputParts[:query].length > 0
                tagNames = inputParts[:query].split(TAG_INPUT_SPLIT)
                if tagNames.length > 1
                  mergedTag = combineTags tagNames
                  if mergedTag
                    writeLibraryToFile
                  else
                    putsRealtime "There was a problem with combining the tags. Your changes were not saved."
                  end
                else
                  putsRealtime "Please give at least two tags."
                end
              end

              {:chainedInput => inputParts[:remainder]}
            },
            'tabComplete' => tagTabComplete
          },
          'rm' => {
            'description' => 'Remove selected tracks from the library. You\'ll be prompted to edit the list before they are deleted.',
            'args' => ['this', 'current', 'all'],
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)

              tracks = nil

              case inputParts[:query]
              when 'this'
                tracks = [@currentTrack]
              when 'all'
                tracks = @library['tracks'].values
              else
                tracks = @tracks
              end

              if tracks && tracks.length > 0
                tracks = editTrackList tracks
                initialLibraryLength = @library['tracks'].length
                tracks.each do |track|
                  removeTrackFromLibrary track['id']
                end
                checksum = initialLibraryLength - tracks.length == @library['tracks'].length
                checksumString = "#{initialLibraryLength} - #{tracks.length} == #{@library['tracks'].length}"
                if checksum
                  writeLibraryToFile
                end
                putsRealtime "#{checksumString} ... #{checksum ? 'OK: changes written' : 'Mismatch: changes not written'}"
              else
                putsRealtime "No tracks selected for removal."
              end
              {:chainedInput => inputParts[:remainder]}
            }
          },
          'rmfile' => {
            'description' => 'Remove files: (options: this (default), unknown (files not referenced by the library), current (files for all selected tracks), all (what it sounds like), You\'ll be prompted with a list to edit; clear the list if you want to cancel the operation.',
            'args' => ['this', 'unknown', 'current', 'all'],
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              setDescriptor = inputParts[:query] && inputParts[:query].length > 0 ? inputParts[:query] : 'this'

              filesToDelete = []
              filesToIgnore = ['.', '..']

              case setDescriptor
              when "this"
                trackFiles = findTrackFiles @currentTrack
                if trackFiles
                  filesToDelete.concat(trackFiles.map { |p|
                    p.sub "#{@mediaDirectoryPath}/", ''
                  })
                end
              when "unknown"
                Dir.entries(@mediaDirectoryPath).each { |file|
                  if !filesToIgnore.include? file
                    id = getIdFromFileName file
                    if !id || !@library['tracks'][id]
                      filesToDelete << file
                    end
                  end
                }
              when "current"
                Dir.entries(@mediaDirectoryPath).each { |file|
                  if !filesToIgnore.include? file
                    id = getIdFromFileName file
                    if !id || !@tracks.include?(id)
                      filesToDelete << file
                    end
                  end
                }
              when "all"
                Dir.entries(@mediaDirectoryPath).each { |file|
                  if !filesToIgnore.include? file
                    filesToDelete << file
                  end
                }
              else
                putsRealtime "\nUnrecognized option '#{setDescriptor}'. Use one of #{command['args'].join(", ")}"
              end

              filesToDelete = editListInVim filesToDelete, "remove any files you don't want to delete" if filesToDelete.length > 0

              if filesToDelete.length > 0

                if confirm("Delete #{filesToDelete.length} files?")

                  filesToDelete.each { |file|
                    File.delete "#{@mediaDirectoryPath}/#{file.chomp}"
                  }
                  putsRealtime "#{filesToDelete.length} files deleted."
                  writeLibraryToFile
                end
              else
                putsRealtime "No files to delete."
              end

              @library['x.hosts'] ||= {}
              @library['x.hosts'][$hostname] ||= {}
              @library['x.hosts'][$hostname]['downloaded'] = Dir.entries(@mediaDirectoryPath).map { |file|
                if !filesToIgnore.include? file
                  getIdFromFileName file
                end
              }.delete_if { |id|
                !id
              }.uniq

              {:chainedInput => inputParts[:remainder]}
            }
          },
          'rmlist' => {
            'description' => '<playlistName> remove a playlist.',
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              if inputParts[:query] && inputParts[:query].length > 0
                playlistName = findPlaylistName inputParts[:query]

                if playlistName
                  @library['playlists'].delete playlistName
                  writeLibraryToFile
                  putsRealtime "removed playlist #{playlistName}"
                end

              else
                putsRealtime "#{@library['playlists'].map { |name, p| name } .join "\n"}\n\nPlease specify a playlist name (new or existing)."
              end
              {:chainedInput => inputParts[:remainder]}
            }
          },
          'refresh' => {
            'description' => 'Load the latest version of the media library.',
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              loadLibrary
              @currentTrack = matchExistingLibraryTrack @currentTrack
              {:chainedInput => inputParts[:remainder]}
            }
          },
          'player' => {
            'description' => 'Define player startup options. Takes effect on the next track being played',
            'action' => Proc.new { |input, command|
              samplePlayerCommands = [];
              samplePlayerCommands << 'Some sample options:';
              samplePlayerCommands << 'small video window in the corner: -geometry 100%:100% -xy 150';
              samplePlayerCommands << 'mix stereo to mono (same as /mono command): -af pan=1:0.5:0.5';
              @playerOverrideCommands = editListInVim(@playerOverrideCommands, samplePlayerCommands.join("\n"))
              {:chainedInput => input}
            }
          },
          'stream' => {
            'description' => "Ignore downloaded files. This is useful if you want to play a different format than the one downloaded (e.g. audio vs. video).",
            'showStatus' => Proc.new {
              putsRealtime "force streaming: #{@forceStreaming ? 'on' : 'off'}"
            },
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              @forceStreaming = getToggledValueByInput.call(@forceStreaming, inputParts[:query])
              if @forceStreaming && !@networkEnabled
                if confirm("Enable network activity?")
                  @networkEnabled = true
                else
                  putsRealtime("Cannot prefer streaming while network is enabled.")
                  @forceStreaming = false
                end
              end
              command['showStatus'].call
              {:chainedInput => inputParts[:remainder]}
            }
          },
          'mono' => {
            'description' => 'Toggle downmixing to mono. If mono is enabled before the track starts, toggling will have no effect until the player starts again (e.g. `/again / q`).',
            'showStatus' => Proc.new {
              putsRealtime "downmix to mono: #{@downmixMono ? 'on' : 'off'}"
            },
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              if inputParts[:query] != 'status' # if status, fall though
                @downmixMono = getToggledValueByInput.call(@downmixMono, inputParts[:remainder])
                sendMplayerCommand 'af_del pan'
                sendMplayerCommand 'af_add pan=1:0.5:0.5' if @downmixMono # assuming stereo source
              end

              command['showStatus'].call

              {:chainedInput => inputParts[:remainder]}
            }
          },
          'loudness' => { # TODO 1gzQHH
            'description' => "Save current volume relative to default in library.",
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              loudness = inputParts[:query].to_f
              if loudness > 0.0
                loadLibrary
                @currentTrack = matchExistingLibraryTrack @currentTrack

                @currentTrack['loudness'] = loudness
                @volumeMultipliers['track_loudness'] = loudness
                writeLibraryToFile
              end
              {:chainedInput => inputParts[:remainder]}
            }
          },
          'video' => {
            'description' => 'Shortcut to enable/disable video-related settings. Toggles between mp4/bestaudio youtube-dl formats (regardless of your previous settings).',
            'showStatus' => Proc.new {
              isVideoEnabled = !@playerOverrideCommands.join(' ').match('-novideo')
              putsRealtime "Video: #{isVideoEnabled ? 'on' : 'off'}"
              isVideoEnabled
            },
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              isVideoEnabled = getToggledValueByInput.call(command['showStatus'].call(), inputParts[:query])

              if isVideoEnabled
                @playerOverrideCommands.delete_if { |option| option.match(/-novideo\b/) }
                @preferredFileFormat = 'mp4'
              else
                @playerOverrideCommands << '-novideo'
                @preferredFileFormat = 'bestaudio'
              end

              command['showStatus'].call

              {:chainedInput => inputParts[:remainder]}
            }
          },
          'loop' => {
            'description' => '/loop [COUNT]: Set the loop limit, or toggle looping off/on, or toggle only inner loops, or \'reset\' the loop counters.',
            'args' => ['off', 'on', 'inner', 'break', 'reset'],
            'showStatus' => Proc.new {
              statusMessage = "Looping: #{@loop ? 'on' : 'off'}"
              statusExtras = []
              if @breakLoop
                statusExtras << "breaking current loop"
              end
              if @innerLoopsOnly
                statusExtras << "inner loops only"
              end

              statusMessage << " (#{statusExtras.join('; ')})" if statusExtras.length > 0

              statusMessage << "\n#{getLoopLimitStatusMessage}"

              putsRealtime statusMessage
            },
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              if inputParts[:query].match(/^[0-9]+$/)
                loopLimit = inputParts[:query].to_i
                @loop = true
                @loopLimit = loopLimit
              elsif inputParts[:query] == 'reset'
                @loopHistory = {}
                @breakLoop = false
              elsif inputParts[:query] == 'inner'
                @innerLoopsOnly = getToggledValueByInput.call(@innerLoopsOnly)
              elsif inputParts[:query] == 'break'
                @breakLoop = getToggledValueByInput.call(@breakLoop)
              else
                @loop = getToggledValueByInput.call(@loop, inputParts[:query])
              end

              command['showStatus'].call

              {:chainedInput => inputParts[:remainder]}
            }
          },
          'shuffle' => {
            'description' => 'Toggle shuffle.',
            'args' => ['on', 'off'],
            'showStatus' => Proc.new {
              putsRealtime "shuffle: #{@shuffle ? 'on' : 'off'}" if @configuredVerbosity >= 1
            },
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              @shuffle = getToggledValueByInput.call(@shuffle, inputParts[:query])
              shuffleIndex() if @shuffle
              command['showStatus'].call
              {:chainedInput => inputParts[:remainder]}
            }
          },
          'eq' => {
            'description' => 'Set EQ, or save a new preset (/eq [PRESET | save NEW_NAME]). If no preset is given, a list of presets is shown, along with an interactive EQ display, which can by changed using the arrow keys.',
            'args' => ['save'],
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              loadLibrary
              @library['player'] ||= {}
              @library['player']['equalizer_presets'] ||= {}

              # default presets
              @library['player']['equalizer_presets']['flat'] = '0:0:0:0:0:0:0:0:0:0'
              @library['player']['equalizer_presets']['bass'] ||= '-1:0:-2:-3:-5:-5:-5:-5:-5:-5'
              @library['player']['equalizer_presets']['earplugs'] ||= '-4:0:-5:-6:-6:-5:-4:-2:0:-3'

              handleEQTextInput = Proc.new { |eqInput, parentCommand|
                is_success = false
                savePresetNamePattern = /^save ([^ ]+).*/
                if savePresetNamePattern.match eqInput
                  @eqPreset = eqInput.sub savePresetNamePattern, '\1'
                  @library['player']['equalizer_presets'][@eqPreset] = @eqSetting
                  writeLibraryToFile
                  is_success = true
                else
                  chosenEQPreset = firstFuzzyMatchValue eqInput, parentCommand['inputOptions'].call
                  if chosenEQPreset
                    @eqPreset = chosenEQPreset
                    @eqSetting = @library['player']['equalizer_presets'][chosenEQPreset]
                    is_success = true
                    sendMplayerCommand "af_del equalizer\naf_add equalizer=#{@eqSetting}"
                  else
                    putsRealtime "Unknown preset '#{eqInput}'."
                  end
                end
                is_success
              }

              if inputParts[:query] && inputParts[:query].length > 0
                handleEQTextInput.call inputParts[:query], command
              else
                chosenPresetMessage = @eqPreset ? "Using #{@eqPreset}. " : ""
                putsRealtime "#{chosenPresetMessage}Presets: #{@library['player']['equalizer_presets'].keys.join ", "}"

                def showInteractiveEQ bands, selectedIndex
                  printRepeat "#{bands.join(':')}\r	#{selectedIndex > 0 ? bands.slice(0, selectedIndex).join(':') + ":" : ''}"
                end

                @eqSetting ||= @library['player']['equalizer_presets']['flat']
                eqBands = @eqSetting.split(':').map { |level| level.to_i }
                selectedBandIndex = 0
                showInteractiveEQ eqBands, selectedBandIndex
                disablePlaybackInfo
                interactivePresetNameInput = ''
                while eqInput = readCharacter
                  inputCausedEQChange = false
                  if eqInput == "\e[A" # up arrow
                    eqBands[selectedBandIndex] = [eqBands[selectedBandIndex] + 1, 10].min
                    inputCausedEQChange = true
                  elsif eqInput == "\e[B" # down arrow
                    eqBands[selectedBandIndex] = [eqBands[selectedBandIndex] - 1, -10].max
                    inputCausedEQChange = true
                  elsif eqInput == "\e[C" # right arrow
                    selectedBandIndex = [selectedBandIndex + 1, eqBands.length - 1].min
                  elsif eqInput == "\e[D" # left arrow
                    selectedBandIndex = [selectedBandIndex - 1, 0].max
                  elsif eqInput == "" # backspace
                    if interactivePresetNameInput.length > 0
                      interactivePresetNameInput = interactivePresetNameInput[0, interactivePresetNameInput.length - 1]
                      printRepeat interactivePresetNameInput
                    end
                  elsif eqInput == "" # clear line
                    interactivePresetNameInput = ''
                    printRepeat interactivePresetNameInput
                  elsif /[\n\r]/.match(eqInput)
                    if interactivePresetNameInput.length > 0
                      print "\n"
                      inputCausedEQChange = handleEQTextInput.call interactivePresetNameInput, command
                    end
                    break
                  else
                    interactivePresetNameInput << eqInput
                  end

                  if interactivePresetNameInput.length > 0
                    printRepeat interactivePresetNameInput
                  else
                    showInteractiveEQ eqBands, selectedBandIndex
                  end

                  if inputCausedEQChange
                    @eqSetting = eqBands.join ':'
                    sendMplayerCommand "af_clr\naf_add equalizer=#{@eqSetting}"
                  end
                end
                enablePlaybackInfo
              end
              {:chainedInput => inputParts[:remainder]}
            },
            'inputOptions' => Proc.new { |command|
              @library['player']['equalizer_presets'].keys
            },
            'inputOptionsLabel' => 'EQ presets'
          },
          'brightness' => generateVisualCommand.call('brightness'),
          'contrast' => generateVisualCommand.call('contrast'),
          'saturation' => generateVisualCommand.call('saturation'),
          'hue' => generateVisualCommand.call('hue'),
          'logarithmic' => {
            'description' => 'Toggle logarithmic volume scale.',
            'action' => Proc.new { |input, command|
              @isVolumeAlreadyLogarithmic= !@isVolumeAlreadyLogarithmic
              putsRealtime "logarithmic volume scale: #{@isVolumeAlreadyLogarithmic ? 'off' : 'on'}"
              {:chainedInput => input}
            }
          },
          'again' => {
            'description' => "Play this track again, next.",
            'action' => Proc.new { |input, command|
              @trackIndex = @tracks.index @currentTrack
              if !@trackIndex
                useTracks [@currentTrack]
                @trackIndex = @tracks.length - 1
                # TODO 1gG4iz: add @currentTrack to queue
              end
              {:chainedInput => input}
            }
          }
        },
        'kill' => {
        },
        'edit' => {
        },
        'play' => {
          '' => {
            'description' => "Chainable player commands (empty command, i.e. '/').",
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)
              output = {
                :chainedInput => inputParts[:remainder]
              }
              if inputParts[:query] && inputParts[:query].length > 0
                whisper("Running player action (#{input})", 3)
                output[:action] = inputParts[:query]
              end

              output
            },
            'inputOptions' => Proc.new { |input, command|
              getPlayerCommands.split("\n")
            }
          },
          'stop' => {
            'description' => 'Stop playing (enter "edit" mode).',
            'action' => Proc.new { |input, command|
              setUserMode MODES['edit']
              exitPlayerCommand

              false
            }
          },
          'fade' => {
            'description' => '/fade VOLUME [DURATION]; VOLUME can be "out" or "in", which will fade from or to the last explicit volume set.',
            'args' => ['out', 'in'],
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts input, /^(?<target>out|in|[0-9.]+x?)( (?<duration>[0-9.]+))?[^\/]*(?<remainder>.*)$/
              output = {:chainedInput => inputParts[:remainder]}
              whisper("fade command", 4)
              fadeDuration = inputParts[:duration] && inputParts[:duration].length > 0 ? inputParts[:duration].to_f : 2.0
              targetFadeVolume = inputParts[:target]
              if output[:chainedInput] && output[:chainedInput].length > 0
                whisper("fade in main thread", 4)
                fadeVolume targetFadeVolume, fadeDuration, @currentPlayerIndex
              else
                whisper("fade in separate thread", 4)
                Thread.new {
                  fadeVolume targetFadeVolume, fadeDuration, @currentPlayerIndex
                }
              end
              output
            }
          },
          'volume' => generateMacroCommand.call('/fade INPUT 0', 'VOLUME - Set the volume level.'),
          'mute' => generateMacroCommand.call('/fade out 0', 'Temporarily silent audio.'),
          'unmute' => generateMacroCommand.call('/fade in 0', 'Restore audio after mute.'),
          'ramp' => {
            'description' => '/ramp SPEED [DURATION] - Ramp speed',
            'action' => Proc.new { |input, command|
              output = nil
              rampInputPattern = /^(?<target>out|in|[0-9.]*(?<bpm>bpm)?)( (?<duration>[0-9:.]+))?[^\/]*(?<remainder>.*)$/
              inputParts = getCommandInputParts input, rampInputPattern
              if inputParts
                output = {:chainedInput => inputParts[:remainder]}
                rampDuration = inputParts[:duration] && inputParts[:duration].length > 0 ? inputParts[:duration].to_f : 0.3
                whisper('without -af scaletempo[=speed=tempo], min and max limited by the system (~1/8 and ~4.5 on my Mac Mini)', 1)
                targetRampSpeed = inputParts[:target]
                if inputParts[:bpm] == 'bpm'
                  targetRampBPM = getUserInputBPM
                  if targetRampBPM && targetRampBPM > 0
                    targetRampSpeed = "#{targetRampBPM}bpm"
                  else
                    targetRampSpeed = nil
                  end
                end
                if targetRampSpeed
                  targetRampSpeed = determineRelativeSpeed targetRampSpeed, @currentTrack, true
                  if output[:chainedInput] && output[:chainedInput].length > 0
                    whisper("ramping speed in the main thread", 4)
                    rampSpeed targetRampSpeed, rampDuration, @currentPlayerIndex
                    whisper("Waiting 1 second for buffered sound to play", 2)
                    sleep 1.0
                  else
                    whisper("ramping speed in a separate thread", 4)
                    Thread.new {
                      rampSpeed targetRampSpeed, rampDuration, @currentPlayerIndex
                    }
                  end
                end
              end
              output
            }
          },
          'glide' => {
            'description' => '/glide DURATION [DELAY] - Set BPM "glide" period. Default 0 (i.e. off). If changing between two tracks with tempo information, the second track will begin playing to match the tempo of the first, and then "glide" for DURATION (after DELAY) back to the configured global speed.',
            'action' => Proc.new { |input, command|
              output = nil
              glideCommandMatch = /^([0-9.]+)( [0-9.]+)?[^\/]*(.*)$/.match input
              #                     1        2                3
              if glideCommandMatch
                output = {:chainedInput => glideCommandMatch[3]}
                @bpmGlideDuration = glideCommandMatch[1].to_f
                @bpmGlideDelay = glideCommandMatch[2] && glideCommandMatch[2].length > 0 ? glideCommandMatch[2].to_f : 0.0
              end
              output
            }
          },
          'mark' => {
            'description' => 'Mark the point at which to play this track next time. Pass any argument to remove an existing mark',
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)

              loadLibrary
              @currentTrack = matchExistingLibraryTrack @currentTrack

              if inputParts[:query] && inputParts[:query].length > 0
                removeMarkFromTrack @currentTrack
              else
                addMarkToTrack @currentTrack, @commandinputStartPlayerTime
              end
              writeLibraryToFile
              {:chainedInput => input}
            }
          },
          'seek' => {
            'description' => 'Seek to a time code. Prefix with "+" or "-" to seek relative to current play position. use "/seek mark" to seek to a time marked with the "/mark" command."',
            'args' => ['mark'],
            'action' => Proc.new { |input, command|
              inputParts = getCommandInputParts(input)

              seekInput = inputParts[:query].strip
              seekTimeInSeconds = parseRelativeTime seekInput
              seek seekTimeInSeconds, 0.5, 0.5
              {:chainedInput => inputParts[:remainder]}
            }
          }
        }
      }

      if modes.empty?
        modes = MODES.keys
      else
        modes << 'base'
        modes.uniq!
      end

      requestedCommandSet = {}

      modes.each { |modeName|
        requestedCommandSet.merge! interactiveCommands[modeName]
      }

      if requestedCommandSet
        requestedCommandSet['?'] = requestedCommandSet['help'] = {
          'description' => 'Show interactive command info (like this). Not chainable.',
          'action' => Proc.new {
            showInteractiveCommandHelp requestedCommandSet
          }
        }
      end

      requestedCommandSet
    end

    def setUserMode mode
      @userMode = mode if MODES.has_key?(mode)
    end

    def getNoteIndexAtTime notes, seconds
      noteIndex = -1 # @confirm: -1 instead of nil, so that adding 1 gets you a valid next index (the first one)
      if !seconds
        whisper("getNoteIndexAtTime: nil seconds", 3)
      else
        notes.each_with_index { |note, index|
          noteSeconds = getSecondsFromDurationString note['time']
          if !noteSeconds
            whisper("unable to get seconds from note time '#{note['time']}'", 3)
          elsif noteSeconds <= seconds
            noteIndex = index
          else
            break
          end
        }
      end
      noteIndex
    end

    def getOffsetFromInputString input
      offset = nil
      input.strip!
      if input.match(/^>+$/)
        offset = input.length
      elsif input.match(/^<+$/)
        offset = -input.length + 1
      end

      offset
    end

    def getNoteIndexByQuery notes, input, referenceIndex = nil
      noteIndex = nil

      if input.match(/^[0-9]+$/)
        noteIndex = input.to_i - 1
      else
        noteIndexOffset = getOffsetFromInputString input
        if noteIndexOffset
          referenceIndex ||= getNoteIndexAtTime notes, @currentPlayerTime
          noteIndex = referenceIndex + noteIndexOffset
        else
          chapterList = notes.map { |note| "#{note['time']} - #{note['text']}" }
          noteIndex = firstFuzzyMatchIndex input, chapterList
        end
      end
      whisper("Choosing note #{noteIndex}", 2)

      noteIndex
    end

    def parseRelativeTime seekInput
      whisper("seek input: #{seekInput}")
      if seekInput && seekInput.length > 0
        if seekInput == 'mark' && @currentTrack.has_key?('mark')
          seekInput = @currentTrack['mark']
        end

        relativeDirection = nil
        relativeDirectionMatch = seekInput.match(/^[+-]/)
        if relativeDirectionMatch
          seekInput.sub!(/^[+-]/, '')
          relativeDirection = relativeDirectionMatch[0] == '-' ? -1 : 1
        end

        seekTimeInSeconds = getSecondsFromDurationString seekInput
        if seekTimeInSeconds
          if relativeDirection
            seekTimeInSeconds = @currentPlayerTime + relativeDirection * seekTimeInSeconds
          end
        else
          whisper("Failed to get seconds from input '#{seekInput}'")
          # TODO: 1gG4hv
        end
      else
        whisper("seek input is empty: '#{seekInput}'")
      end

      seekTimeInSeconds
    end

    def seek seekTimeInSeconds, fadeOutPeriod = 0.0, fadeInPeriod = 0.0
      if @playerApplication == PLAYER_APP_DEFAULT
        isAbleToSeek = trackFileExists?(@currentTrack) || @currentTrack['type'] == 'audio/mpeg' || seekTimeInSeconds > @currentPlayerTime
        if isAbleToSeek
          @currentlySeeking = true
          fadeVolume 'out', fadeOutPeriod, @currentPlayerIndex if fadeOutPeriod > 0

          sendMplayerCommand "seek #{seekTimeInSeconds} 2"

          fadeVolume 'in', fadeInPeriod, @currentPlayerIndex if fadeInPeriod > 0

          Thread.new {
            sleep 1
            @currentlySeeking = false
          }
        else
          putsRealtime "Download the file to be able to seek backwards."
        end
      else
        putsRealtime "Sorry, seeking is not yet implemented for #{@playerApplication}."
      end
    end

    def getUserInputBPM
      disablePlaybackInfo
      firstTimeInSeconds = nil
      lastTimeInSeconds = nil
      iterations = 0;
      bpm = @currentTrack['bpm'];
      outputMessageLines = []
      outputMessageLines << "Current BPM is #{bpm}." if bpm
      outputMessageLines << "Hit ENTER key on the beat. Type \"k\" to accept, \"r\" to accept the nearest whole number, or anything else to cancel setting the BPM."
      putsRealtime outputMessageLines.join "\n"
      while bpmInput = readCharacter
        if not (/[\n\r]/).match(bpmInput)
          if bpmInput.match(/^[kr]$/)
            if bpmInput == 'r'
              bpm = bpm.round
            end
          else
            bpm = nil
          end
          break
        end

        iterations += 1
        now = Time.now.to_f
        firstTimeInSeconds ||= now
        lastTimeInSeconds = now
        if lastTimeInSeconds != firstTimeInSeconds
          bpm = ((iterations - 1).to_f / (lastTimeInSeconds - firstTimeInSeconds) * 60.0).round(1);
          printRepeat "BPM: #{bpm} "
        end
      end
      print "\n"

      enablePlaybackInfo

      return bpm
    end

    def getMultipliedVolume newVolume
      whisper("@volumeMultipliers: #{@volumeMultipliers}", 4)
      @volumeMultipliers.each { |key, m|
        newVolume *= m
      }

      newVolume
    end

    def getStateSpaceVolume actualVolume
      stateVolume = actualVolume
      @volumeMultipliers.each { |key, m|
        stateVolume /= m
      }

      stateVolume
    end

    def setActualVolume newVolume, playerIndex = nil
      playerIndex ||= @currentPlayerIndex
      @currentVolume = newVolume
      @actualVolume = getMultipliedVolume newVolume
      case @playerApplication
      when PLAYER_APP_DEFAULT
        sendMplayerCommand "volume #{@actualVolume} 1", playerIndex
      when PLAYER_APP_TERMUX
        volumeCommand = "termux-volume music #{@actualVolume.round}"
        whisper("volumeCommand", 5)
        `#{volumeCommand}`
      end
    end

    def tween a, b, duration, onStep, interval = nil, curve = 'linear'
      whisper("tween from #{a} to #{b}", 3)
      interval ||= @playerApplication == PLAYER_APP_DEFAULT ? 0.02 : 1.0
      stepCount = (duration.to_f / interval).to_i
      transitionValue = a
      span = b - a
      floor = [a, b].min

      if span != 0
        case curve
        when 'logarithmic'
          stepStrategy = Proc.new { |stepIndex|
            transitionValue = floor + 10**(Math.log10(span.abs + 1) / stepCount * stepIndex) - 1
          }
        else
          stepStrategy = Proc.new { |stepIndex|
            transitionValue = floor + span.abs * (stepIndex.to_f / stepCount)
          }
        end

        step = Proc.new { |stepIndex|
          stepStrategy.call(stepIndex)
          onStep.call(transitionValue, false)
          sleep interval
        }
        if span > 0
          1.upto(stepCount - 1) { |stepIndex| step.call stepIndex }
        else
          (stepCount - 1).downto(1) { |stepIndex| step.call stepIndex }
        end
      end

      onStep.call(b, true)
    end

    def fadeVolume targetFadeVolume, duration, playerIndex
      whisper("fadeVolume(targetFadeVolume:#{targetFadeVolume}, duration:#{duration}, playerIndex:#{playerIndex})", 4)
      # @volumeMultipliers['fade'] ||= 1 # TODO 1gzQHH: I haven't worked this out yet
      transitionVolume = @currentVolume
      if targetFadeVolume == 'out'
        whisper("fading out volume", 4)
        targetFadeVolume = 0
      elsif targetFadeVolume == 'in'
        targetFadeVolume = @volume
        whisper("fading in volume (to #{targetFadeVolume})", 4)
      elsif targetFadeVolume.match(/x$/)
        multiplier = targetFadeVolume.to_f
        targetFadeVolume = transitionVolume * multiplier
        @volume = targetFadeVolume
        whisper("fading volume #{multiplier}x (to #{targetFadeVolume})", 4)
      else
        targetFadeVolume = targetFadeVolume.to_f
        @volume = targetFadeVolume
        whisper("fading to volume #{targetFadeVolume}", 4)
      end
      targetFadeVolume = [[targetFadeVolume, 0].max, 100].min
      whisper("fading from #{transitionVolume} to #{targetFadeVolume} in #{duration} seconds (playerIndex: #{playerIndex})", 4)
      curve = @isVolumeAlreadyLogarithmic ? 'linear' : 'logarithmic'
      tween(
        transitionVolume,
        targetFadeVolume,
        duration,
        Proc.new { |iVolume|
          setActualVolume iVolume
          trigger 'volume_change'
        },
        nil, # use default interval
        curve
      )

      trigger 'fade_end'
    end

    def rampSpeed targetRampSpeed, duration, playerIndex
      isValidInput = false
      whisper("ramp speed to #{targetRampSpeed} over #{duration} seconds", 2)
      if targetRampSpeed
        transitionSpeed = @currentSpeed
        if targetRampSpeed == 'out'
          targetRampSpeed = 0
          @speedBeforeRampingOut = transitionSpeed
        elsif targetRampSpeed == 'in'
          targetRampSpeed = @speedBeforeRampingOut
        else
          targetRampSpeed = targetRampSpeed.to_f
          @speed = targetRampSpeed
          # does this work? # @speed = targetRampSpeed.to_f!
        end

        tween(
          transitionSpeed,
          targetRampSpeed,
          duration,
          Proc.new { |iSpeed|
            sendMplayerCommand "speed_set #{iSpeed}", playerIndex
            @currentSpeed = iSpeed
            trigger 'speed_change'
          }
        )

        isValidInput = true
      else
        putsRealtime "Bad speed format, or track has no bpm set."
      end

      trigger 'speed_ramp_end'

      isValidInput
    end

    def findTag(query)
      verifiedTagName = nil
      meansToFindTag = nil

      if @library['tags'].has_key? query
        meansToFindTag = 'name'
        verifiedTagName = query
      else
        @library['tags'].each { |name, t|
          if t['aliases'] && t['aliases'].include?(query)
            meansToFindTag = 'alias'
            verifiedTagName = name
          end
        }
      end

      if verifiedTagName
        whisper("found tag '#{verifiedTagName}' by #{meansToFindTag} '#{query}'", 2)
        return @library['tags'][verifiedTagName]
      else
        whisper("no tag found by query '#{query}'", 2)
        return false
      end
    end

    def addTrackToTags(track, tagNames)
      # TODO 1gtzi6: for tags containing ':' colons, add the tag as-is, and set
      # its parents to the list resulting from splitting on ':' colon (e.g.
      # 'composer:vangelis' will create/add to the tag of that name, and assign
      # that tags parents to be 'composer' and 'vangelis', creating those tags
      # as necessary).
      whisper("adding tags (input): #{tagNames}", 3)
      tagNames.each { |tagName|
        whisper("about to add to tag '#{tagName}'", 4)
        matchingTag = findTag(tagName) || createTag(tagName)
        whisper("matchingTag: #{matchingTag}", 4)
        matchingTag['tracks'] ||= []
        whisper("adding track to tag #{tagName}", 4)
        matchingTag['tracks'] << track['id']

        matchingTag['score'] ||= {}
        matchingTag['score'][track['id']] ||= 0
        matchingTag['score'][track['id']] = matchingTag['score'][track['id']] + 1

        matchingTag['tracks'].uniq!
      }
    end

    def removeTagsFromTrack(track, tagNames)
      whisper("removing tags: #{tagNames}", 3)
      tagNames.each { |tagName|
        matchingTag = findTag tagName
        if matchingTag && matchingTag['tracks']
          matchingTag['tracks'].delete track['id'] if matchingTag['tracks'].include? track['id']
        end
      }
    end

    def relateTags(tagNames)
      childTagName = tagNames.shift
      childTag = findTag childTagName

      if childTag && tagNames.length > 0
        childTag['parents'] ||= []
        childTag['parents'].concat(tagNames)
        childTag['parents'].uniq!
      else
        putsRealtime "provide 2 or more tags to relate together"
      end

      childTag
    end

    def combineTags(tagNames)
      baseTagName = tagNames.pop
      baseTag = findTag baseTagName

      if baseTag && tagNames.length > 0
        whisper("merging #{tagNames.join ', '} into #{baseTagName}", 3)
        tagNames.each { |collapsingTagName|
          collapsingTag = findTag collapsingTagName
          if collapsingTag && collapsingTag != baseTag
            baseTag['aliases'] ||= []
            baseTag['aliases'] << collapsingTagName
            if collapsingTag['tracks'] && collapsingTag['tracks'].length > 0
              baseTag['tracks'] ||= []
              baseTag['tracks'].concat(collapsingTag['tracks'])
            end
            deleteTag collapsingTagName
          end
        }

        baseTag['aliases'].uniq!
        baseTag['tracks'].uniq!
      else
        putsRealtime "provide 2 or more tags to join together"
      end

      baseTag
    end

    def createTag(tagName)
      whisper("creating tag '#{tagName}'", 3)
      @library['tags'][tagName] = {}
      @library['tags'][tagName]
    end

    def deleteTag(tagName)
      @library['tags'].delete tagName if @library['tags'].has_key? tagName
    end

    def getNextPlayableNoteIndex notes, fromIndex = -1
      nextNoteIndex = nil
      notes.each_with_index { |note, index|
        if index > fromIndex && (!note.has_key?('skip') || !note['skip'])
          nextNoteIndex = index
          break
        end
      }

      nextNoteIndex
    end

    def seekToNextPlayableNoteOrSkip notes, fromIndex, noteType = 'note'
      nextPlayableIndex = getNextPlayableNoteIndex notes, fromIndex

      if nextPlayableIndex
        note = notes[nextPlayableIndex]
        seekSeconds = getSecondsFromDurationString note['time']
        whisper("Skipping #{noteType} #{fromIndex + 1}, to #{nextPlayableIndex + 1} (#{note['time']}, #{seekSeconds}).", 0)
        seek seekSeconds, 0, 0
      else
        whisper("Skipping #{noteType} #{fromIndex + 1}; no more playable #{noteType}s; skipping track.", 0)
        fadeVolume 'out', 0.25, @currentPlayerIndex
        exitPlayerCommand
      end
    end

    def play(track, interactiveCommands)
      fileAlreadyExists = !@forceStreaming && trackFileExists?(track) # TODO: 1gG4j4: I shouldn't need to check twice
      liveStreaming = doesTrackHaveTag(track, 'live-radio') # TODO: 1gSke5
      streaming = @forceStreaming || (!fileAlreadyExists && !@autoDownload)

      if !fileAlreadyExists
        if @networkEnabled

        else
          whisper("No local file to play, and network is disabled", 0)
          return response
        end
      end

      trigger 'play_start'

      bindingGroupName = 'play'

      whisper("playing track: #{track}", 3)
      @currentPlayerIndex = 1 - @currentPlayerIndex
      whisper("@currentPlayerIndex: #{@currentPlayerIndex}", 4)
      response = {
        :exit => true,
        :playTime => 0
      }

      playerStatus = nil
      playerAction = nil

      playerInputStreamName = nil
      playerInputFile = nil
      playerStdoutName = nil
      playerStdoutFile = nil
      playerStartupOptions = []

      case @playerApplication
      when PLAYER_APP_DEFAULT
        playerInputStreamName = "#{MPLAYER_INPUT_FIFO_NAME}#{@currentPlayerIndex}"
        deleteStream playerInputStreamName
        playerInputFile = makeStream playerInputStreamName

        playerStdoutName = "#{MPLAYER_STDOUT_BUFFER_NAME}#{@currentPlayerIndex}"
        playerStdoutFile = getTempFilePath playerStdoutName

        # https://mplayerhq.hu/DOCS/tech/slave.txt
        playerStartupOptions.concat(["-slave", "-quiet", "-input file=\"#{playerInputFile}\""])

        playerAction = Proc.new { |command|
          sendMplayerCommand command
          true
        }
      when PLAYER_APP_TERMUX
        if @hasMpv
          # try to get slave mode to work, or use alternatives (e.g. https://mpv.io/manual/master/#lua-scripting)
          playerInputStreamName = "#{MPV_INPUT_FIFO_NAME}#{@currentPlayerIndex}"
          deleteStream playerInputStreamName
          playerInputFile = makeStream playerInputStreamName

          playerStdoutName = "#{MPV_STDOUT_BUFFER_NAME}#{@currentPlayerIndex}"
          playerStdoutFile = getTempFilePath playerStdoutName

          playerAction = Proc.new { |command|
            sendMpvCommand command
            true
          }
        end
      end

      firstPlayableChapterIndex = nil
      if track.has_key?('chapters') && track['chapters'].length > 0 && track['chapters'][0]['time']
        firstPlayableChapterIndex = 0
        firstChapterStartTime = getSecondsFromDurationString(track['chapters'][0]['time'])
        if firstChapterStartTime == 0
          firstPlayableChapterIndex = getNextPlayableNoteIndex track['chapters']
        end # don't skip if first chapter doesn't start at 0:00
      end

      if @loop && track['loop'].kind_of?(Array)
        whisper("This track has has an A/B loop (#{track['loop'].join(" - ")}. This will deprecated in favor of looping notes; for now, use looping chapters instead.", 1)
      end

      @currentPlayerTime = 0
      if @chapterQuery && track.has_key?('chapters')
        chapterIndex = getNoteIndexByQuery(track['chapters'], @chapterQuery)
        @chapterQuery = nil
        chapterTimecode = track['chapters'][chapterIndex]['time']
        @currentPlayerTime = getSecondsFromDurationString(chapterTimecode) if chapterIndex
        whisper("chapter start time '#{chapterTimecode} (#{@currentPlayerTime} seconds}", 3)
      elsif track['mark'] && !liveStreaming
        puts("Starting from mark at #{track['mark']}.", 0)
        @currentPlayerTime = getSecondsFromDurationString track['mark']

        loadLibrary
        editingTrack = matchExistingLibraryTrack track

        removeMarkFromTrack editingTrack
        writeLibraryToFile
      elsif firstPlayableChapterIndex && firstPlayableChapterIndex > 0
        @currentPlayerTime = getSecondsFromDurationString track['chapters'][firstPlayableChapterIndex]['time']
        whisper("Skipping marked chapters at the beginning.", 2)
      end

      if @currentPlayerTime > 0
        playerStartupOptions << "-ss #{@currentPlayerTime}"
      end

      if fileAlreadyExists
        mediaFilePath = firstTrackFile track
      else
        downloadOptions = {}
        if streaming
          if @youtubeDLTrackTypes.include? track['type']
            whisper("streaming youtube track", 2)
            streamName = 'youtube-stream'
            deleteStream streamName
            downloadOptions['streamPath'] = mediaFilePath = makeStream streamName
            if not downloadTrack(track, downloadOptions)
              whisper("could not download/stream track", 1)
              mediaFilePath = nil
            end
          else
            whisper("streaming other type of track (#{track['type']})", 2)
            streamName = 'mp3-stream'
            deleteStream streamName
            # mplayer 4.2.1 on Mac OS Sierra unable to stream HTTPS
            if /^https:\/\//.match track['src']
              downloadOptions['streamPath'] = mediaFilePath = makeStream streamName
              if not downloadTrack(track, downloadOptions)
                whisper("could not download/stream track", 1)
                mediaFilePath = nil
              end
            else
              mediaFilePath = track['src']
            end
          end
        elsif @autoDownload
          downloadOptions['sync'] = true
          if downloadTrack(track, downloadOptions)
            mediaFilePath = firstTrackFile track
          else
            whisper("could not download/stream track", 1)
            mediaFilePath = nil
          end
        end
      end

      if not mediaFilePath
        puts("File not found for #{track['title']}.", 0)
        return response
      end

      if !streamName
        playerStartupOptions << "-loop #{@loopLimit}" if @loop && !@innerLoopsOnly && !doesTrackHaveInternalLoops?(@currentTrack)
      end

      @speed = 1 if @speed < 0.01
      speed = @speed
      if @playingBPM && @currentTrack['bpm']
        speed = @speed * @playingBPM / @currentTrack['bpm']
      end

      ## TODO 1gzQHH
      # if track.has_key?('loudness') && track['loudness']
      #   @volumeMultipliers['track_loudness'] = track['loudness']
      # elsif @volumeMultipliers.has_key? 'track_loudness'
      #   @volumeMultipliers.delete 'track_loudness'
      # end
      #
      # newVolume = getMultipliedVolume @volume
      # if @currentVolume != newVolume
      # 	@currentVolume = newVolume # they may differ, but at this point, only @volume matters
      # 	trigger 'volume_change'
      # end

      if @currentVolume != @volume
        @currentVolume = @volume # they may differ, but at this point, only @volume matters
        @actualVolume = getMultipliedVolume @currentVolume
        trigger 'volume_change'
      end

      playerStartupOptions.concat(@playerOverrideCommands)
      playerStartupOptions << "-volume #{@actualVolume}"
      playerStartupOptions << "-speed #{speed}"
      playerStartupOptions << "-af pan=1:0.5:0.5" if @downmixMono # @experimental Does this wipe out any previous -af, or add to it?
      @currentVisualEffects.each { |property, value|
        playerStartupOptions << "-#{property} #{value.to_i}"
      }

      response[:startTime] = Time.now.to_f

      @inputThread.kill if @inputThread
      @inputThread = Thread.new {
        whisper("commandPrompt start (opening input thread)", 4)
        commandPrompt '', interactiveCommands, playerAction
        whisper("commandPrompt end", 4)
      }
      if playerAction && @playerTemporaryInteractiveCommands.length > 0
        playerAction.call @playerTemporaryInteractiveCommands.join("\n")
        @playerTemporaryInteractiveCommands = []
      end

      @playerApplicationThreads[@currentPlayerIndex] = Thread.new {
        @isPlayerPlaying = true
        # TODO 1gnyIc: fix missing input characters while paused
        @tempFiles[playerStdoutFile] = true

        playerCommandParts = []

        playerCommandParts << @commandBeforePlayer if @commandBeforePlayer

        afterPlayer = nil

        case @playerApplication
        when PLAYER_APP_DEFAULT
          playerCommandParts << "#{@playerApplication} \"#{mediaFilePath}\" #{playerStartupOptions.join ' '}"
        when PLAYER_APP_TERMUX
          setActualVolume @volume # handle the case of `/fade out / q`, which fades out the system volume, so it is still faded out when we start a new player
          if @hasMpv
            # TODO: implement slave mode with JSON IPC https://mpv.io/manual/master/#json-ipc
            mpvSupportedOptions = ['speed', 'quiet', 'af', 'loop', 'ss']
            mpvOptionMutations = {
              'ss' => Proc.new { |option| option.sub!(/-ss\s*/, '--start=') }
            }
            # ignoring supported options:
            # -volume: using system music volume via termux-volume instead, since slave mode is not yet working for interactive volume control
            getOptionKey = Proc.new { |option|
              option.sub(/^-(\w+).*/, '\1')
            }
            # playerStartupOptions.each { |option|
            #   optionKey = getOptionKey.call(option)
            # }
            playerStartupOptions.keep_if { |option|
              shouldKeep = false
              optionKey = getOptionKey.call(option)
              if optionKey
                if mpvOptionMutations.has_key?(optionKey)
                  whisper("Changing mplayer '#{option}'...", 4)
                  mpvOptionMutations[optionKey].call(option, optionKey)
                  whisper("...to #{option}'", 4)
                  shouldKeep = true
                elsif mpvSupportedOptions.include?(optionKey)
                  shouldKeep = true
                end
                shouldKeep
              end

            }
            playerCommandParts << "mpv #{playerStartupOptions.join ' '} \"#{mediaFilePath}\""

            # The input pipe isn't connecting to interactive input on mpv, and it's causing the command not to quit when playback is finished
            # playerCommandParts.unshift("cat \"#{playerInputFile}\" |") if playerInputFile
          else
            durationInSeconds = nil
            if @currentTrack && @currentTrack.has_key?('duration') && @currentTrack['duration']
              durationInSeconds = getSecondsFromDurationString(@currentTrack['duration'])
            end

            if durationInSeconds
              playerCommandParts << "termux-media-player play \"#{mediaFilePath}\""
              afterPlayer = Proc.new {
                sleep durationInSeconds
              }
            else
              playerCommandParts = []
              whisper("termux-media-player doesn't wait around for nobody, and this track won't tell us how long to wait in its stead.", 0)
            end
          end
        end

        if playerCommandParts.length > 0
          playerCommandParts << " > #{playerStdoutFile}" if playerStdoutFile
          playerCommand = playerCommandParts.join ' '
          whisper(playerCommand, 2)
          playerStatus = `#{playerCommand} 2> /dev/null`
          whisper("Player command finished", 3)
          afterPlayer.call if afterPlayer
        else
          playerStatus = nil
          whisper("No player command, or aborted: '#{@playerApplication}", 3)
        end

        @inputThread.kill if @inputThread
      }

      enablePlaybackInfo # might have been set false if the player quit while realtime output was hidden
      playerTimeupdateHandler = Proc.new {
        ['chapters', 'notes'].each { |noteType|
          if @currentTrack.has_key?(noteType)
            newIndex = getNoteIndexAtTime @currentTrack[noteType], @currentPlayerTime
            if newIndex > -1 && @currentNoteIndex[noteType] != newIndex
              @currentNoteIndex[noteType] = newIndex
              eventName = noteType.sub(/s$/, '_change')
              trigger eventName
            end
          else
            @currentNoteIndex[noteType] = nil
          end
        }

        showPlaybackInfo
      }

      bind('time_update', playerTimeupdateHandler, bindingGroupName)

      @loopHistory = {};

      onNoteChange = Proc.new { |noteType|
        # check if we need to skip
        currentIndex = @currentNoteIndex[noteType]
        loopTarget = @currentTrack[noteType][currentIndex]['loop_target'] if @currentTrack[noteType][currentIndex].has_key?('loop_target')
        if (
            @loop  &&
            !@breakLoop  &&
            !@currentlySeeking &&
            @currentTrack[noteType][currentIndex] &&
            loopTarget &&
            (
              !@loopHistory.has_key?(loopTarget) ||
              (@loopLimit == 0 || @loopHistory[loopTarget] < @loopLimit)
            )
        )
          whisper("looping to target '#{@currentTrack[noteType][currentIndex]['loop_target']}'", 2)

          isLooping = false
          loopTargetSeconds = getSecondsFromDurationString loopTarget
          if loopTargetSeconds
            isLooping = true
            seek loopTargetSeconds
          else
            targetNoteIndex = getNoteIndexByQuery(@currentTrack[noteType], loopTarget)
            isLooping = true
            if targetNoteIndex
              whisper("\nLoop #{getLoopLimitStatusMessage}", 1)
              seekTime = @currentTrack[noteType][targetNoteIndex]['time']
              seekSeconds = getSecondsFromDurationString seekTime
              seek seekSeconds
            end
          end

          if isLooping
            if @loopHistory.has_key?(loopTarget)
              @loopHistory[loopTarget] += 1
            else
              @loopHistory[loopTarget] = 1;
            end
          end
        elsif (
          !@currentlySeeking &&
          @currentTrack[noteType][currentIndex] &&
          @currentTrack[noteType][currentIndex].has_key?('skip') &&
          @currentTrack[noteType][currentIndex]['skip'] == true
        )
          seekToNextPlayableNoteOrSkip @currentTrack[noteType], currentIndex
        else
          whisper("#{noteType}: #{@currentTrack[noteType][currentIndex]['text']}", 1)
        end
      }

      bind(['chapter_change', 'note_change'], Proc.new { |eventName|
        noteType = eventName.sub(/_.*/, 's')
        whisper("#{eventName}, doing onNoteChange with noteType '#{noteType}'", 3)
        onNoteChange.call noteType
      }, bindingGroupName)

      @startingPlayerTime = @currentPlayerTime
      @playStartTimestamp = Time.now.to_f
      trigger 'time_update' # @currentPlayerTime set above, ~ 2878

      while @playerApplicationThreads[@currentPlayerIndex].alive?
        if @playerApplication == PLAYER_APP_DEFAULT
          playerResponseDelay = 0.1
          playerTimeResponse = getMplayerProperty('get_time_pos', /^(ANS_TIME_POSITION=|.*Time: )(.*?)(\?)?$/, playerResponseDelay)
          if playerTimeResponse
            @currentPlayerTime = playerTimeResponse.to_f
            trigger 'time_update'
          end
        else
          sleep 0.1
          @currentPlayerTime = Time.now.to_f - @playStartTimestamp + @startingPlayerTime
          trigger 'time_update'
        end
      end

      @breakLoop = false

      # @playerApplicationThreads[@currentPlayerIndex].join
      whisper("killing user input thread (again)", 4)
      @inputThread.kill if @inputThread # FIXME 1gpapl: overkill?

      response[:endTime] = Time.now.to_f

      deleteStream playerInputStreamName
      deleteTempFile playerStdoutName

      response[:playTime] = response[:endTime] - response[:startTime]

      deleteStream streamName if streamName

      trigger 'play_end'

      unbindGroup bindingGroupName

      response[:exit] = playerStatus
      response
    end

    def exitPlayerCommand hard = true
      whisper("exiting player: #{@playerApplication}", 3)
      case @playerApplication
      when PLAYER_APP_DEFAULT
        sendMplayerCommand "q"
      when PLAYER_APP_TERMUX
        if @hasMpv
          `killall -9 mpv`
        else
          `termux-media-player stop`
        end
      end

      ## 1hEaID: in termux, with mpv, killing the player threads causes tunewich to break the main loop. This is a hacky workaround for that problem.
      if hard
        # @future: only kill active thread; currently players don't overlap.
        @playerApplicationThreads.each { |thread|
          thread.kill if thread && thread.alive?
        }
      end
    end

    def getLoopLimitStatusMessage
      status = "(limit: #{@loopLimit == 0 ? "" : "#{@loopLimit}"})"
      loopHistory = @loopHistory.map { |k,v| "#{k} - #{v}" }.join("\n")
      status << "\n#{loopHistory}" if loopHistory && loopHistory.length > 0

      status
    end

    def showPlaybackInfo
      if @shouldShowPlaybackInfo && @configuredVerbosity > -1 && @configuredVerbosity < 5
        playbackInfo = []
        unicodeChars = {
          :speaker => "",
          :timer => "",
          :openBook => "",
          :label => "",
          :star => "",
          :crossArrows => "",
          :parallelArrows => "",
          :whiteStar => "",
          :floppyDisk => ""
        }

        # show shuffle or regular playback
        playbackInfo << "#{@shuffle ? unicodeChars[:crossArrows] : unicodeChars[:parallelArrows]}"

        # show volume
        volumeIndication = "" * (@currentVolume / 10).to_i + ["", "", "", "", "", "", "", ""][(@currentVolume % 10 / 1.25).to_i]
        volumeIndication = "[#{volumeIndication}#{" " * (10 - volumeIndication.length)}]"
        playbackInfo << "#{unicodeChars[:speaker]} #{volumeIndication}"

        # show playback position
        timeMessage = "#{unicodeChars[:timer]}	#{getDurationStringFromSeconds @currentPlayerTime, 0}" if @currentPlayerTime
        timeMessage << "/#{@currentTrack['duration']}" if @currentTrack.has_key?('duration')
        timeMessage << "(#{(@currentSpeed * 10).round / 10.0}x)" if @currentSpeed != 1
        playbackInfo << timeMessage

        # show if the track file is downloaded
        playbackInfo << "#{unicodeChars[:floppyDisk]}" if trackFileExists?(@currentTrack)

        # show track rating
        if @currentTrack.has_key? 'rating'
          playbackInfo << "#{unicodeChars[:star]} #{@currentTrack['rating']}"
        end

        # show current chapter name
        if @currentTrack.has_key?('chapters')
          if @currentNoteIndex['chapters'] && @currentTrack['chapters'][@currentNoteIndex['chapters']]
            playbackInfo << "#{unicodeChars[:openBook]}	#{@currentTrack['chapters'][@currentNoteIndex['chapters']]['text']}" # undefined method `[]' for nil:NilClass (NoMethodError)
          end
        else
          @currentNoteIndex['chapters'] = nil
        end

        # show tags on this track
        currentTags = getTrackTags @currentTrack
        if currentTags && currentTags.length > 0
          playbackInfo << "#{unicodeChars[:label]}	#{currentTags.join ', '}"
        end

        # check again if realtime output has been disabled while were doing all this stuff
        if @shouldShowPlaybackInfo && @configuredVerbosity > -1 && @configuredVerbosity < 5
          printRepeat(playbackInfo.join(' '), true)
        end
      end
    end

    def getMplayerProperty property, pattern = nil, responseDelay = nil
      output = nil

      if @isPlayerPlaying && @playerApplication == PLAYER_APP_DEFAULT # TODO: 1gG4j9 get time position without unpausing
        pattern ||= /^()(.*)$/
        command = "#{property}"
        command = "get_property #{command}" if not property.match(/^get_/)
        # TODO: 1gG4jB maybe this needs pausing_keep (http://www.mplayerhq.hu/DOCS/tech/slave.txt). doesn't quite work in my testing
        sendMplayerCommand command
        sleep responseDelay if responseDelay
        lastPlayerOutput = tailTempFile "#{MPLAYER_STDOUT_BUFFER_NAME}#{@currentPlayerIndex}"
        if lastPlayerOutput
          whisper("read #{property} from player, output: #{lastPlayerOutput}", 5)
          matches = lastPlayerOutput.match pattern
          output = matches[2] if matches
        end
      elsif responseDelay
        # don't use 100% CPU while doing nothing
        sleep responseDelay
      end

      output
    end

    def getMplayerConfigNumericProperty(propertyName, defaultValue = 0.0)
      playerCommands = []
      playerCommands.concat(@playerOverrideCommands) if @playerOverrideCommands
      propertyValue = defaultValue

      playerCommands.each { |command|
        if command.include? propertyName
          propertyValue = command.match(/.*-#{propertyName} ([0-9.]+)/)[1].to_f
        end
      }

      propertyValue.to_f
    end

    def nextTrack
      whisper("next track", 3)
      if @shuffle
        # FIXME 1gpalq: filterTracksOnDeck should run regardles of @shuffle, but it would mess with @trackIndex. With @shuffle == true, it doesn't matter.
        # filterTracksOnDeck() # only apply upon changing the filter or track list, for performance's sake
        shuffleIndex()
      else
        @trackIndex += 1

        if @trackIndex > @tracks.length - 1

          if @youtubeSearchPage && @networkEnabled
            @youtubeSearchPage += 1
            searchedTracks = searchYouTube(@youtubeSearch, (@youtubeSearchPage - 1) * 20)
            useTracks(searchedTracks, true) if searchedTracks
          else
            @trackIndex %= @tracks.length
          end

        end

      end
    end

    def useTracks tracks, append = true
      if append
        whisper("Adding #{tracks.length} tracks to the end of your play queue.")
      else
        whisper("Replacing your play queue with #{tracks.length} tracks.")
        @tracks = []
      end
      @tracks.concat(tracks)
      filterTracksOnDeck
      putInTempFile('tracks', listTrackTitles(@tracks).join("\n"), false)
      if @trackIndex && @trackIndex > @tracks.length - 1
        @trackIndex = 0
      end
    end

    def writeTitleChangesInTrackList tracks
      whisper("writeTitleChangesInTrackList: say something!", 3)
      anyChanges = false
      tracks.each { |track|
        canonicalTrack = matchExistingLibraryTrack(track)
        if track['title'] != canonicalTrack['title']
          whisper("Updating '#{canonicalTrack['title']}' = '#{track['title']}'", 3)
          canonicalTrack['title'] = track['title']
          anyChanges = true
        else
          whisper("Identical: '#{canonicalTrack['title']}' == '#{track['title']}'", 3)
        end
      }
      if anyChanges then writeLibraryToFile
      else whisper("No changes to track titles.", 3)
      end
    end

    def filterTracksOnDeck
      if @trackFilters
        @tracks = filterTracks @tracks, @trackFilters
      end

      if @trackExcludeFilters
        @tracks = filterTracks @tracks, @trackExcludeFilters, true
      end

      updateSessionDescription
    end

    def shuffleIndex
      @trackIndex = Random.rand(@tracks.length - 1) if @tracks.length > 1
    end

    def setLibraryDatabasePath libraryDatabasePath
      if File.exist? libraryDatabasePath
        @libraryDatabasePath = libraryDatabasePath
      else
        raise "TODO: create library file at #{@libraryDatabasePath}"
      end

      loadLibrary

      if not @library
        raise "Unable to load library from path #{@libraryDatabasePath}."
      end
    end

    def setLibraryMediaPath libraryPath
      @tunewichDirectory = libraryPath
      if not Dir.exist? @tunewichDirectory
        whisper("Please create the directory '#{@tunewichDirectory}'.", 0)
        kill
      end

      @mediaDirectoryPath = "#{@tunewichDirectory}/music" # TODO: use the tunewichDirectory directly as the music directory
      Dir.mkdir @mediaDirectoryPath if not Dir.exist? @mediaDirectoryPath

      setLibraryDatabasePath "#{@tunewichDirectory}/tunewich-library.json" if !@libraryDatabasePath
    end

    def extendHash sourceTrack, overrideTrack
      overrideTrack.each { |property, value|
        sourceTrack[property] ||= value
      }
      sourceTrack
    end

    def matchExistingLibraryTrack track
      @library['tracks'].each { |id, t|
        if t['src'] === track['src']
          extendHash t, track
          track = t
          track.delete 'unattached' if track.has_key? 'unattached'
          break
        end
      }
      track
    end

    def getTrackTags track
      tags = []
      @library['tags'].each { |name, tag|
        tags << name if tag.has_key?('tracks') && tag['tracks'].include?(track['id'])
      }
      tags
    end

    def doesTrackHaveInternalLoops? track
      hasInternalLoops = false

      notesAndChapters = []

      if track
        notesAndChapters.concat(track['chapters']) if track.has_key?('chapters')
        notesAndChapters.concat(track['notes']) if track.has_key?('notes')
      end

      if notesAndChapters.length > 0
        notesAndChapters.each { |note|
          if note && note['loop_target']
            hasInternalLoops = true
            break
          end
        }
      end

      hasInternalLoops
    end

    def doesTrackHaveTag(track, *tagNames)
      tagNames.each { |tagName|
        @library['tags'].has_key?(tagName) &&
          @library['tags'][tagName].has_key?('tracks') &&
          @library['tags'][tagName]['tracks'].include?(track['id'])
      }
    end

    def getTrackTitles tracks
      tracks.map{|t| t['title']}
    end

    def findTrackIndex(query, tracks = nil, referenceTrackIndex = nil)
      referenceTrackIndex ||= @trackIndex
      tracks ||= @tracks
      whisper("findTrackIndex() searching for '#{query}' among #{tracks.length} tracks", 3)
      newTrackIndex = referenceTrackIndex

      trackIndexOffset = getOffsetFromInputString query

      if trackIndexOffset
        newTrackIndex += trackIndexOffset
        whisper("findTrackIndex() trackIndexOffset: #{trackIndexOffset}", 3)
      elsif query.match(/^[0-9]+$/)
        whisper("findTrackIndex() treating query as an integer", 3)
        newTrackIndex = (query.to_i - 1) % tracks.length
      else
        onDeckIds = tracks.map { |t| t['id'] }
        newTrackIndex = onDeckIds.index(query)
        if newTrackIndex
          whisper("findTrackIndex() found by ID", 3)
        else
          whisper("findTrackIndex() searching by title", 3)
          newTrackIndex = firstFuzzyMatchIndex(query, getTrackTitles(tracks))
        end
      end

      whisper("findTrackIndex() => #{newTrackIndex}", 3)

      newTrackIndex
    end

    def findPlaylistName(query)
      firstFuzzyMatchValue query, @library['playlists'].keys
    end

    def fuzzyStringSearchInList(query, list)
      regexSafeQuery = query.gsub(/[\*]+/, '')
      explodedPattern = regexSafeQuery.gsub(/\s+/, '').split('').join('.*')
      queryPattern = Regexp.new(regexSafeQuery + '|' + explodedPattern, Regexp::IGNORECASE)
      matches = []
      list.each_with_index do |value, index|
        matchedPortion = queryPattern.match(value)

        if matchedPortion
          match = {
            :index => index,
            :value => value,
            :matchLength => matchedPortion[0].length,
            :starts => value.downcase.start_with?(query.downcase)
          };
          match[:density] = query.length.to_f / match[:matchLength].to_f
          match[:breadth] = match[:matchLength].to_f / match[:value].length.to_f
          match[:score] = match[:density] * 10 + match[:breadth]
          whisper("match:score]: #{match}", 3)
          matches << match
        end

      end

      if matches.length > 1
        matches.sort! { |a,b|
          if a[:starts] != b[:starts]
            (b[:starts] ? 1 : 0) <=> (a[:starts] ? 1 : 0) # starts first
          elsif a[:starts] # && b[:starts] (^ implied)
            a[:value].length <=> b[:value].length # shorter first
          else
            b[:score] <=> a[:score] # higher first
          end
        }
      end

      matches
    end

    def fuzzyStringSearchInListValues(query, list)
      fuzzyStringSearchInList(query, list).map { |m| m[:value] }
    end

    def firstFuzzyMatch(query, list)
      matches = fuzzyStringSearchInList query, list
      matches.length ? matches[0] : false
    end

    def firstFuzzyMatchValue(query, list)
      match = firstFuzzyMatch query, list
      match ? match[:value] : false
    end

    def firstFuzzyMatchIndex(query, list)
      match = firstFuzzyMatch query, list
      match ? match[:index] : false
    end

    def deleteTrackFile(track)
      `rm #{getTrackFilePrefix track}.*` # including `.` after prefix
    end

    def firstTrackFile(track)
      files = findTrackFiles(track)
      files.length ? files[0] : nil
    end

    def findTrackFiles(track, forceCacheRefresh = false)
      files = []

      # TODO: expire cache after some interval of time, maybe 1 minute

      if !@mediaFilePathCache || forceCacheRefresh
        @mediaFilePathCache = Dir.glob("#{@mediaDirectoryPath}/tunewich.*")
        @mediaFilePathCache.delete_if { |fileName| fileName.match(/\.part$/) }
      end

      if @mediaFilePathCache && @mediaFilePathCache.length > 0
        files.concat(Array.new(@mediaFilePathCache).keep_if { |path|
          path.split('/').last.start_with?("tunewich.#{track['id']}")
        })
      end

      files
    end

    def trackFileExists?(track, forceCacheRefresh = false)
      findTrackFiles(track, forceCacheRefresh).length > 0
    end

    def getIdFromFileName(fileName)
      id = fileName.gsub(/^tunewich.([^.]+).*$/) { $1 }
      whisper("id: '#{id}', file: '#{fileName}'", 4)
      id != fileName ? id : false
    end

    def getTrackFilePrefix(track)
      "#{@mediaDirectoryPath}/tunewich.#{track['id']}"
    end

    # @typedef DownloadOptions
    # @property audioFormat (see youtube-dl --audio-format)
    # @property feedbackPath {string} defaults to '/dev/null'
    # @property streamPath {string} defaults to nil

    # @param track Track
    # @param options DownloadOptions
    # @returns string download command
    def getDownloadCommand(track, options = nil)
      downloadCommand = ''
      options ||= {}
      options['feedbackPath'] ||= '/dev/null'

      # TODO 1gparD: output youtube-dl error messages to user
      if @youtubeDLTrackTypes.include? track['type']
        youtubeDlCommandBegin = "youtube-dl -f \"#{@preferredFileFormat}\" -q"
        # youtubeDlCommandBegin = "youtube-dl -f \"#{@preferredFileFormat}\" --no-part --no-cache-dir --no-continue"
        youtubeDlCommandEnd = "-- #{track['src']}"
        if options['streamPath']
          downloadCommand = "rm -f -- --Frag*; #{youtubeDlCommandBegin} -o - #{youtubeDlCommandEnd} > \"#{options['streamPath']}\" 2> \"#{options['feedbackPath']}\""
        else
          youtubeDlOptions = ''
          if options
            if !options.has_key?("audioFormat") && @preferredFileFormat == 'bestaudio'
              options['audioFormat'] = 'vorbis'
            end
            youtubeDlOptions << " --extract-audio --audio-format #{options['audioFormat']} " if options.has_key? "audioFormat"
          end
          youtubeDlOptions << " -o \"#{getTrackFilePrefix track}.%(title)s.%(ext)s\""
          downloadCommand = "#{youtubeDlCommandBegin}#{youtubeDlOptions} #{youtubeDlCommandEnd}"
        end
      else
        if options['streamPath']
          downloadCommand = "curl -sL \"#{track['src']}\" > #{options['streamPath']}"
        else
          downloadCommand = "curl -sL \"#{track['src']}\" > #{getTrackFilePrefix track}.mp3" #FIXME 1gpanQ: don't assume mp3 file extension
        end
      end

      downloadCommand
    end

    # @param track hash
    # @param options DownloadOptions
    # @returns integer PID of download process, or nil if download failed
    def downloadTrack(track, options = nil)
      if !@networkEnabled
        whisper("not downloading --no-network", 0)
        return
      end

      options ||= {}

      downloadPid = nil
      downloadFeedbackFileName = 'download-feedback'
      options['feedbackFile'] ||= createTempFile downloadFeedbackFileName
      downloadCommand = getDownloadCommand track, options
      if !options['streamPath'] && @preferredFileFormat == 'bestaudio'
        options['audioFormat'] ||= 'vorbis'
      end

      whisper(downloadCommand, 3)
      if options['streamPath'] && !options['sync']
        downloadPid = spawn(downloadCommand) # spawn: non-blocking
      else
        runAndHandleDownloadCommand = Proc.new {
          trigger('download_begin', track) if !options['suppressBeginEvent'] # Unsure of the diff triggering in new thread vs. calling inline
          whisper("download begin", 3)
          downloadPid = system(downloadCommand) # system: blocking
          if trackFileExists? track, true
            loadLibrary
            # TODO 1h1dBF: remove from this list when doing `rmfile`
            @library['x.hosts'][$hostname] ||= {'hostname' => ENV['HOSTNAME']}
            @library['x.hosts'][$hostname]['downloaded'] ||= []
            @library['x.hosts'][$hostname]['downloaded'] << track['id']
            writeLibraryToFile
            whisper("download complete", 3)
            trigger('download_success', track)
          else
            trigger('download_fail', track)
          end
          trigger('download_end', track) if !options['suppressEndEvent']
          deleteTempFile downloadFeedbackFileName
        }
        if options['sync']
          runAndHandleDownloadCommand.call
        else
          Thread.new { runAndHandleDownloadCommand.call }
        end
      end

      downloadPid
    end

    def notify(message)
      if @configuredVerbosity > 0
        if UNAME == 'Linux'
          `notify-send --expire-time=3000 --urgency=low tunewich "#{message}"`
        elsif UNAME == 'Darwin'
          clean_message = message.gsub(/"/, '\\"').gsub(/'/, "'\"'\"'"); # what a mess: escaped double-quoted string in applescript, as single-quoted arg to osascript, as double-quoted string in ruby
          notifyCommand = "osascript -e 'display notification \"#{clean_message}\" with title \"tunewich\"' &>/dev/null"
          whisper(notifyCommand, 3);
          system notifyCommand
        end
      end
    end

    def titleBlock(message, fill = '=')
      width = `tput cols 2>&/dev/null`.chomp.to_i
      blockRow = fill * width
      padding = '	'
      marginSize = (width - message.length) / 2 - padding.length
      marginLeft = marginSize > 1 ? fill * marginSize : ''
      marginRight = marginLeft
      marginRight << fill if (width - message.length) % 2 == 1
      puts "\n#{blockRow}"
      puts "#{marginLeft}#{padding}#{message}#{padding}#{marginRight}"
      puts blockRow
      notify message
    end

    def updateRadioMetadata metadata
      if @streamingServerType == 'homebrew'
        serverUsername = 'admin'
        serverPassword = 'hackme'
        serverHost = 'localhost:8000'
        serverMountName = 'radio'
        # ruby 2.3.1 `open` doesn't support userinfo (user:password@host)
        `curl -s "http://#{serverUsername}:#{serverPassword}@#{serverHost}/admin/metadata?mount=/#{serverMountName}&mode=updinfo&song=#{URI::encode metadata}"`
      end
    end

    ##
    # File Methods
    ##

    def getTempFilePath(name, shouldIncludeSessionID = true)
      nameSegments = ["tunewich"]
      nameSegments << @sessionID if shouldIncludeSessionID
      nameSegments << name
      "#{$tunewichTmpDirectory}/#{nameSegments.join '-'}"
    end

    def createTempFile(name)
      whisper("make tmp #{name}", 4)
      putInTempFile name, ''
    end

    def putInTempFile(name, value, shouldIncludeSessionID = true)
      path = getTempFilePath(name, shouldIncludeSessionID)
      # FIXME 1gpani: why does this stall when writing to a FIFO before something is reading from it?
      Thread.new {
        # FIXME 1gpani: trying to put it in a new thread...maybe won't fix the problem, but it will unblock the main thread.
        writeResult = File.write(path, value)
        whisper("#{name} << '#{value.chomp}' (#{writeResult})", 5)
      }
      path
    end

    def readTempFile(name, shouldIncludeSessionID = true)
      whisper("read tmp #{name}", 5)
      path = getTempFilePath(name, shouldIncludeSessionID)

      if File.exist? path
        whisper("read tmp #{name}: exists", 5)
        contents = File.read path
        # whisper("read tmp #{name}, contents: #{contents}", 5)
        return contents
      else
        whisper("read tmp #{name}: missing", 5)
        return ''
      end
    end

    def tailTempFile(name, shouldIncludeSessionID = true)
      whisper("tail tmp #{name}", 5)
      content = readTempFile(name, shouldIncludeSessionID)
      lastLine = ''
      if content && content.length > 0
        lastLine = content.gsub("\r","\n").lines.pop.strip.chomp
      end
      lastLine
    end

    def deleteTempFile(name, shouldIncludeSessionID = true)
      whisper("delete tmp #{name}", 4)
      path = getTempFilePath(name, shouldIncludeSessionID)

      if File.exist? path
        File.delete path
        if @tempFiles.has_key? path
          @tempFiles.delete path
        end
      end
    end

    def makeStream(name)
      path = getTempFilePath name
      whisper("mkfifo #{path}", 4)

      if File.exist? path
        File.delete path
        # raise "The temp file '#{name}' already exists. (#{path})"
      end

      if not system "mkfifo \"#{path}\""
        raise "ERROR: Could not create the stream file (#{path})"
      end

      if File.exist?(path)
        @tempFiles[path] = true
      else
        path = nil
      end

      path
    end

    alias deleteStream deleteTempFile

    ##
    # Library Methods
    ##

    def usePlaylist(name, append = false)
      tracks = []

      if @library['playlists'][name]['tracks']
        @playlistName = name
        anyUnrecognizedTracks = false
        @library['playlists'][@playlistName]['tracks'].each do |trackReference|
          if trackReference && trackReference.kind_of?(String)
            if @library['tracks'].has_key?(trackReference)
              track = @library['tracks'][trackReference]
            elsif looksLikeAYouTubeID?(trackReference)
              track = createTrack trackReference, 'youtube'
            else
              whisper("Track not in library, and ID is not recognized: '#{trackReference}'", 2)
            end
            tracks << track if track
          end
        end

        if anyUnrecognizedTracks
          message = [
            "Note: for non-YouTube tracks, the ID is an md5 hash of the media URL.",
            "Unfortunately that is not a reversible hash, but you could hash other",
            "known URLs and use matches to repair this playlist."
          ].join(' ')
          whisper(message, 2)
        end
      end

      useTracks tracks, append
    end

    def useEntireLibrary
      tracks = []

      @library['tracks'].keys.each do |trackKey|
        tracks << @library['tracks'][trackKey]
      end

      useTracks tracks, false
    end

    def processLibraryJSON(json)
      libraryData = {
        :json => json,
        :hash => Digest::MD5.hexdigest(json),
        :data => nil
      }

      begin
        libraryData[:data] = JSON.parse(json)
      rescue
        whisper("Invalid JSON.", 0)
      end


      libraryData
    end

    def addMarkToTrack track, time
      track['mark'] = getDurationStringFromSeconds time
      @library["lastMarked"] = track["id"]
    end

    def removeMarkFromTrack track
      if track.has_key? 'mark'
        track.delete 'mark'
      end
    end

    def loadLibrary
      libraryInfo = processLibraryJSON File.read(@libraryDatabasePath)
      if libraryInfo && libraryInfo[:data]
        @library = libraryInfo[:data]
        @libraryHash = libraryInfo[:hash]
        if @tracks && @tracks.length > 0
          @tracks.each_with_index { |track, index|
            @tracks[index] = matchExistingLibraryTrack(@tracks[index])
          }
        end
      end
    end

    def writeLibraryToFile shouldPrompt = false
      if @writeEnabled
        if shouldPrompt && !@yesToConfirmPropts
          return if !confirm("Write changes to library?")
        end
        libraryJSON = JSON.pretty_generate(@library)
        # FIXME 1gpb0C
        if not libraryJSON || libraryJSON == 'null' || libraryJSON.length < 1
          putsRealtime "Sorry! The loaded library has been corrupted. Please restart the player if you want to save any changes to your library."
          return
        end
        libraryOnFile = processLibraryJSON File.read(@libraryDatabasePath) # since we're writing, no need to check for libraryOnFile[:data], right?
        if @libraryHash == libraryOnFile[:hash] || confirm("Library file has changed since last load. Overwrite?")
          libraryInfo = processLibraryJSON libraryJSON
          File.write(@libraryDatabasePath, libraryJSON)
          @libraryHash = libraryInfo[:hash]
          whisper("Saved change to library file.", 2)
        end
      else
        whisper("Writing the library to file is disabled.", "2")
        return
      end
    end

    def removeTrackFromLibrary(id)
      whisper("Removing track (#{id}) from library", 2)
      @library['tracks'].delete id
      @library['playlists'].each { |playlistName, playlist|
        index = playlist['tracks'].index id
        if index
          playlist['tracks'].delete_at index
        end
      }
      @library['tags'].each { |tagName, tag|
        index = tag.has_key?('tracks') ? tag['tracks'].index(id) : nil
        if index
          tag['tracks'].delete_at index
        end
      }
    end

    def interactiveCleanup
      commands = {
      }

      confirmMsg = "Choose a command, or \"y\" to write changes to file"
      if confirm confirmMsg, commands
        writeLibraryToFile
      else
        whisper("No changes saved.", 0)
      end

      whisper("Cleanup finished.", 0)
    end

    def determineRelativeSpeed input, track, shouldSetPlayingBPM = false
      relativeSpeed = input.to_f
      whisper("relativeSpeed: #{input} -> #{relativeSpeed}", 3)
      if input.to_s.match(/bpm$/)
        if track.has_key? 'bpm'
          inputBPM = relativeSpeed
          if shouldSetPlayingBPM
            @playingBPM = inputBPM
            whisper("Setting playing BPM to #{@playingBPM}", 1)
          end
          relativeSpeed = inputBPM / track['bpm']
        else
          relativeSpeed = nil
        end
      end
      relativeSpeed
    end

    def matchPropertyWithRangeString rangeString, hash, property
      rangeParts = " #{rangeString} ".split('-')
      isAMatch = false
      if hash.has_key? property
        if rangeParts.length == 2
          lowerMatch = rangeParts[0] == " " || hash[property] >= rangeParts[0].to_i
          upperMatch = rangeParts[1] == " " || hash[property] <= rangeParts[1].to_i
          isAMatch = lowerMatch && upperMatch
        else
          isAMatch = rangeParts[0].to_i == hash[property].to_i
        end
      end
      isAMatch
    end

    def getDescendantTagNames ancestorTagName, chain = []
      chain << ancestorTagName
      allDescendantTags = []
      @library['tags'].each { |tagName, tag|
        if tag.has_key?('parents') && tag['parents'].include?(ancestorTagName)
          chainIndex = chain.index(tagName)
          if chainIndex
            whisper("Skipping circular tag reference: #{chain[chainIndex, chain.length - chainIndex].join(" > ")} > #{tagName}", 2)
          else
            allDescendantTags << tagName
            whisper("#{ancestorTagName} #{">" * (chain.length)} #{tagName}", 4)
            allDescendantTags.concat(getDescendantTagNames(tagName, chain[0, chain.length])) # pass chain array value
          end
        end
      }
      allDescendantTags
    end

    def getAncestorTagNames descendantTagName, depth = 0
      whisper("getAncestorTagNames(descendantTagName:#{descendantTagName}, depth:#{depth})", 4)
      allAncestorTags = []
      if @library['tags'].has_key? descendantTagName
        whisper("tag #{descendantTagName} has a definition", 5)
        thisTag = @library['tags'][descendantTagName]
        if thisTag && thisTag['parents']
          whisper("thisTag['parents'].each ", 5)
          thisTag['parents'].each { |tagName|
            whisper("tagName: #{tagName}", 5)
            allAncestorTags << tagName
            whisper("#{descendantTagName} #{"<" * (depth + 1)} #{tagName}", 4)
            allAncestorTags.concat(getAncestorTagNames(tagName, (depth + 1)))
          }
        end
      else
        whisper("tag #{descendantTagName} is referenced as a parent, but has no definition of its own", 5)
      end
      whisper("allAncestorTags.uniq", 5)
      allAncestorTags.uniq
    end

    def filterTracks tracks, filters, isExcludeFilter = false
      action = isExcludeFilter ? 'delete_if' : 'keep_if'

      if filters.has_key? 'local'
        tracks.send(action) { |t|
          trackFileExists? t
        }
      end

      if filters.has_key? 'rating'
        if filters['rating'] && filters['rating'].length > 0
          whisper("filtering tracks with rating in range #{filters['rating']}", 3)
          tracks.send(action) { |t|
            matchPropertyWithRangeString filters['rating'], t, 'rating'
          }
        else
          whisper("filtering tracks with any rating", 3)
          tracks.send(action) { |t| t.has_key? 'rating' }
        end
      end

      if filters.has_key? 'tag'
        if filters['tag']
          whisper("filtering tracks with the tag filter #{filters['tag']}", 3)
          # TODO: 1gG4jN: @enhancement optionally grow tag set by linking through tracks with explicitly chosen tags
          selectedTags = []
          unionTagTracks = []
          filterTags = filters['tag'].split(' ')
          descendantFilterTags = []
          filterTags.each { |tagName| descendantFilterTags.concat(getDescendantTagNames(tagName).map {|name| "+#{name}"}) }
          filterTags.concat(descendantFilterTags)
          filterTags.each { |tagName|
            unionPattern = /^\+/
            isUnionTag = tagName.match unionPattern
            tagName.sub!(unionPattern, '') if isUnionTag
            if @library['tags'].has_key? tagName
              selectedTags << {:name => tagName, :tag => @library['tags'][tagName], :union => isUnionTag}
              if isUnionTag && @library['tags'][tagName]['tracks']
                unionTagTracks.concat(@library['tags'][tagName]['tracks'])
              end
            else
              @library['tags'].each { |name, libraryTag|
                if libraryTag['aliases']
                  libraryTag['aliases'].each { |tagAlias|
                    if tagAlias == tagName
                      selectedTags << {:name => name, :tag => libraryTag, :union => isUnionTag}
                      if isUnionTag && @library['tags'][tagName]['tracks']
                        unionTagTracks.concat(@library['tags'][tagName]['tracks'])
                      end
                    end
                  }
                end
              }
            end
          }

          whisper("expanded filter tag list with descendants: #{selectedTags.map { |t| t[:name] }.join(", ")}", 4)
          if selectedTags.length > 0
            # TODO 1gG4jP: make a list of IDs and filter tracks against it once, rather than filtering separately for each tag @performance
            selectedTags.each { |tagInfo|
              tracks.send(action) { |t| tagInfo[:tag]['tracks'] && tagInfo[:tag]['tracks'].index(t['id']) || unionTagTracks.index(t['id']) }
            }

            if unionTagTracks.length > 0
              tracks.sort! { |a, b| unionTagTracks.count(b['id']) <=> unionTagTracks.count(a['id']) }
            end
          else
            whisper("No matches for \"#{filters['tag']}\". Available tags are: #{listAllTagsWithAliases.join ", "}", 0)
          end
        else
          whisper("filtering tracks that have any tags", 3)
          @library['tags'].each { |name, libraryTag|
            tracks.send(action) { |t|
              libraryTag['tracks'] && libraryTag['tracks'].index(t['id'])
            }
          }
        end
      end

      if filters.has_key? 'bpm'
        if filters['bpm'] && filters['bpm'].length > 0
          whisper("filtering tracks with bpm matching #{filters['bpm']}", 3)
          tracks.send(action) { |t|
            matchPropertyWithRangeString filters['bpm'], t, 'bpm'
          }
        else
          whisper("filtering tracks with bpm data", 3)
          tracks.send(action) { |t| t.has_key? 'bpm' }
        end
      end

      if filters['title']
        whisper("filtering tracks with title matching #{filters['title']}", 3)
        matches = fuzzyStringSearchInList(filters['title'], getTrackTitles(tracks))
        matches.sort! { |a,b| b[:density] <=> a[:density] }
        matchedIds = []
        matchesByTrackTitle = {}
        matches.each { |match|
          track = tracks[match[:index]]
          matchedIds << track['id']
          matchesByTrackTitle[track['title']] = match
        }
        tracks.send(action) { |t| matchedIds.include? t['id'] }
        if !isExcludeFilter
          tracks.sort! { |a,b| matchesByTrackTitle[b['title']][:density] <=> matchesByTrackTitle[a['title']][:density] }
        end
      end

      if filters['last']
        whisper("filtering tracks with playtime within the last #{filters['last']}", 3)
        now = Time.now.to_i
        watershed = now - getSecondsFromDurationString(filters['last']).to_i
        tracks.send(action) { |t|
          t['lastPlayed'] ? t['lastPlayed'].to_i >= watershed : false
        }
      end

      if filters['min-duration']
        whisper("Filtering tracks with duration of at least #{filters['min-duration']}", 3)
        minDuration = getSecondsFromDurationString filters['min-duration']
        tracks.send(action) { |t|
          t['duration'] ? getSecondsFromDurationString(t['duration']) > minDuration : false
        }
      end

      if filters.has_key? 'chapters'
        whisper("Filtering tracks with chapters", 3)
        tracks.send(action) { |track|
          if track
            track.has_key? 'chapters'
          else
            false
          end
        }
      end

      putsRealtime "#{tracks.length} matches for filters"

      tracks
    end

    def listFilters includeFilters = nil, excludeFilters = nil
      includeFilters ||= @trackFilters
      excludeFilters ||= @trackExcludeFilters

      filtersList = []
      filtersList.concat(includeFilters.map { |filter, rule| "#{filter}=#{rule}" }) if includeFilters
      filtersList.concat(excludeFilters.map { |filter, rule| "-#{filter}=#{rule}" }) if excludeFilters

      filtersList
    end

    def listAllTagsWithCountsAndAliases
      allTagNames = []

      @library['tags'].each { |name, libraryTag|
        # ignore tracks that have no tracks assigned
        if libraryTag['tracks'] && libraryTag['tracks'].length > 0
          entryParts = [name]

          if libraryTag['aliases'] && libraryTag['aliases'].length > 0
            entryParts << "[#{libraryTag['aliases'].join(', ')}]"
          end

          entryParts << "(#{libraryTag["tracks"].length})"

          allTagNames << entryParts.join('')
        end
      }

      # sort in descending order of # of tracks with that tag
      allTagNames.sort { |a,b| b.sub(/.*\((\d+)\).*/, '\1').to_i <=> a.sub(/.*\((\d+)\).*/, '\1').to_i }
    end

    def listAllTagsWithAliases
      allTagNames = []

      @library['tags'].each { |name, libraryTag|
        allTagNames << name
        if libraryTag['aliases']
          libraryTag['aliases'].each { |tagAlias| allTagNames << tagAlias }
        end
      }

      allTagNames.sort
    end

    def createPlaylist name, tracks = [], description = ''
      newPlaylist = {
        'description' => description,
        'public' => true,
        'tracks' => tracks
      }
      @library['playlists'][name] = newPlaylist
    end

    def createTrack url, type
      newTrack = {
        'type' => type,
        'unattached' => true
      }

      if type == 'youtube'
        newTrack['src'] = looksLikeAYouTubeID?(url) ? url : getYoutubeIdFromUrl(url)
        newTrack['id'] = newTrack['src']
      elsif type == 'ocremix'
        newTrack['src'] = url # TODO: 1gG4jS
        newTrack['id'] = getIDFromOCRemixURL url
      else
        newTrack['src'] = url
        newTrack['id'] = Digest::MD5.hexdigest(url).to_s
      end

      newTrack
    end

    def getYouTubeTrackInfo youtubeVideoID
      track = {
        'type' => 'youtube',
        'src' => youtubeVideoID,
        'id' => youtubeVideoID
      }
      if !@networkEnabled
        whisper("no getYouTubeTrackInfo --no-network", 0)
        return track
      end
      json = `youtube-dl -j -- #{youtubeVideoID} 2>/dev/null` # suppress errors
      return track if !json || json.length == 0

      trackInfo = JSON.parse(json)
      track['title'] = trackInfo['fulltitle']
      track['duration'] = getDurationStringFromSeconds(trackInfo['duration'], 0)
      track['description'] = trackInfo['description']
      track['link'] = trackInfo['webpage_url'] || "https://youtu.be/#{youtubeVideoID}"
      track['type'] = trackInfo['extractor']
      track['sourceTags'] = trackInfo['tags'] if trackInfo['tags']
      whisper("sourceTags: #{trackInfo['tags']}", 2)

      track
    end

    def getSoundcloudTrackInfo soundcloudURL
      track = {
        'type' => 'soundcloud',
        'src' => soundcloudURL,
        'id' => Digest::MD5.hexdigest(soundcloudURL).to_s
      }
      if !@networkEnabled
        whisper("no getSoundcloudTrackInfo --no-network", 0)
        return track
      end
      json = `youtube-dl -j -- #{soundcloudURL} 2>/dev/null` # suppress errors
      return track if !json || json.length == 0

      trackInfo = JSON.parse(json)
      track['title'] = trackInfo['fulltitle']
      track['duration'] = getDurationStringFromSeconds(trackInfo['duration'], 0)
      track['description'] = trackInfo['description']
      track['link'] = trackInfo['webpage_url'] || soundcloudURL
      track['type'] = trackInfo['extractor']
      track['sourceTags'] = trackInfo['tags'] if trackInfo['tags']
      whisper("sourceTags: #{trackInfo['tags']}", 4)

      track
    end

    def updateTrackInfo track, trackInfo = nil, force = false
      if track['type'] === 'youtube'
        trackInfo ||= getYouTubeTrackInfo track['id']
      elsif track['type'] === 'soundcloud'
        trackInfo ||= getSoundcloudTrackInfo track['src']
      end
      if trackInfo
        track['title'] = trackInfo['title'] if (!track['title'] || track['title'].strip.length == 0 || force) && trackInfo['title'] && trackInfo['title'].length > 0

        if (!track['description'] || force) && trackInfo['description'] && trackInfo['description'].length > 0
          if !track['chapters'] || force
            chapters = getChaptersFromDescription trackInfo['description'].lines
            track['chapters'] = chapters if chapters && chapters.length > 0
          end
        end

        track['duration'] = trackInfo['duration'] if trackInfo['duration']
        track['link'] = trackInfo['url'] if trackInfo['url']
        track['type'] = trackInfo['type'] if	trackInfo['type']
      end

      track
    end

    def getChaptersFromDescription description
      description.grep(/[0-9]+:[0-9:.]+/).map! do |line|
        matches = line.match(/^(.*?)[ (]*([0-9]+:[0-9:.]+)[ )]*(.*)$/)
        {
          'time' => matches[2],
          'text' => "#{matches[1]} #{matches[3]}".gsub(/^[^0-z]/, '').strip
        }
      end
    end

    def addTrackToLibrary track
      track.delete 'unattached' if track.has_key? 'unattached'
      trackReference = track['id']
      track['dateAdded'] = Time.now.to_i
      @library['tracks'][trackReference] ||= track

      trackReference
    end

    def addTrackReferenceToPlaylist trackReference, playlistName
      track = @library['tracks'][trackReference]

      if !@library['playlists'][playlistName].has_key?('tracks') || !@library['playlists'][playlistName]['tracks'].include?(trackReference)
        @library['playlists'][playlistName]['tracks'] ||= []
        @library['playlists'][playlistName]['tracks'] << trackReference
        whisper("Saved '#{track['title']}' (#{trackReference}) to playlist '#{playlistName}'", 0)
      else
        whisper("Track '#{track['title']}' (#{trackReference}) is already in playlist '#{playlistName}'", 0)
      end
    end

    ##
    # YouTube Methods
    ##

    def looksLikeAYouTubeID? string
      youtubeIdPattern = /^[A-Za-z0-9_-]{11}$/
      !! string.match(youtubeIdPattern)
    end

    def getYoutubeIdFromUrl url
      youtubeIDInURLPattern = /^.*youtu(\.be\/|be\.com.*v=)([^&\/]+)/
      matches = url.match(youtubeIDInURLPattern)
      matches ? matches[2] : false
    end

    def searchYouTube query, offset = 0, count = 20
      # FIXME 1gpaoG: sometimes the STDIN is not editable after this
      whisper("Searching YouTube for '#{query}'", 0)
      resultsPerPage = 20
      page = (offset.to_f / resultsPerPage.to_f).to_i + 1
      queryParameter = URI::encode(query)
      queryUrl="https://www.youtube.com/results?search_query=#{queryParameter}&page=#{page}"
      getYouTubeTracksFromPage queryUrl
    end

    def getValidYouTubeURI uri
      looksLikeAYouTubeID?(uri) ? "https://www.youtube.com/watch?v=#{uri}" : uri
    end

    def getYouTubeTracksFromPage url
      if !@networkEnabled
        whisper("no getYouTubeTracksFromPage --no-network", 0)
        return false
      end
      url = getValidYouTubeURI url
      queryResultIds = []
      whisper("reading URL #{url}", 2)
      open(url) do |handle|
        whisper("received URL #{url}", 4)
        html = []
        handle.each_line { |line| html << line }

        queryResultIds = html.grep(/href="(.*youtube.*)?\/watch/).map! do |line|
          line.sub!(/^.*watch\?v=([^\"&<]+).*\n/, '\1')
        end

        queryResultIds.uniq!
      end

      threads = []
      resultTracks = []
      receivedCount = 0
      printRepeat "Getting track information (#{receivedCount}/#{queryResultIds.length})"

      queryResultIds.each_with_index do |id, index|
        if id && id.kind_of?(String)
          track = matchExistingLibraryTrack createTrack(id, 'youtube')
          resultTracks << track
          whisper("starting a new thread to get track info for #{track['id']}", 4)
          threads << Thread.new {
            if not updateTrackInfo track
              resultTracks.delete track
            end
            receivedCount += 1
            printRepeat "Getting track information (#{receivedCount}/#{queryResultIds.length})"
          }
        end
      end

      whisper("joining 'update info' threads", 4)
      threads.each { |thread| thread.join }
      print "\n"

      resultTracks
    end

    def getSoundcloudRecommendations url
      if !@networkEnabled
        whisper("no getSoundcloudRecommendations --no-network", 0)
        return false
      end
      url = "#{url}/recommended"
      queryResultURLs = []
      open(url) do |handle|
        html = []
        handle.each_line { |line| html << line }

        queryResultURLs = html.grep(/<h2.*itemprop="url"/).map! do |line|
          line.sub!(/^.*<h2.*itemprop="url".*href="([^\"]+)".*\n/, 'https://soundcloud.com\1')
        end

        queryResultURLs.uniq!
      end

      # FIXME 1gpaoS: seems to be skipping the first recommended track

      threads = []
      resultTracks = []
      receivedCount = 0
      printRepeat "Getting track information (#{receivedCount}/#{queryResultURLs.length})"

      queryResultURLs.each_with_index do |recommendedURL, index|
        track = matchExistingLibraryTrack createTrack(recommendedURL, 'soundcloud')
        resultTracks << track
        whisper("starting a new thread to get track info for #{track['src']}", 4)
        threads << Thread.new {
          if not updateTrackInfo track
            resultTracks.delete track
          end
          receivedCount += 1
          printRepeat "Getting track information (#{receivedCount}/#{queryResultURLs.length})"
        }
      end

      whisper("joining 'update info' threads", 4)
      threads.each { |thread| thread.join }
      print "\n"

      resultTracks
    end

    def getOCRemixSource(url)
      source = nil
      if !@networkEnabled
        whisper("no getOCRemixSource --no-network", 0)
        return false
      end

      open(url) do |handle|
        sourcePattern = /^.*href="(https?:\/\/ocrmirror.org[^"]+)".*$/
        sourceLine = handle.lines.grep(sourcePattern)
        if sourceLine && sourceLine.length > 0
          match = sourceLine[0].match sourcePattern
          source = match[1]
          whisper("source: #{source}", 4)
        end
      end

      source
    end

    def getIDFromOCRemixURL(url)
      url.sub(/^.*\/remix\/([^\/?]+).*/, '\1')
    end

    ##
    # Utility Methods
    ##

    def getDurationStringFromSeconds inputSeconds, roundDigits = 2
      inputSeconds = inputSeconds.to_f
      wholeSeconds = inputSeconds.to_i
      seconds = (inputSeconds % 60).round(roundDigits)
      minutes = wholeSeconds / 60 % 60
      hours = wholeSeconds / 3600 % 24
      days = wholeSeconds / 86400

      outputString = ''
      outputString << "#{days}" if days > 0
      outputString << ":#{hours < 10 ? "0#{hours}" : hours}" if hours > 0
      outputString << ":#{minutes < 10 ? "0#{minutes}" : minutes}"
      outputString << ":#{seconds < 10 ? "0#{seconds}" : seconds}"
      outputString.sub(/^:/, '')
    end

    def getSecondsFromDurationString durationString
      seconds = nil
      timecodeRegExpPattern = /^[0-9:.]+$/

      if durationString
        if durationString.kind_of?(String)
          if durationString.length > 0 && durationString.match(timecodeRegExpPattern)
            seconds = 0
            factor = 1
            factors = [1.0, 60.0, 60.0, 24.0]
            durationString.split(':').reverse.each_with_index { |unit, index|
              factor *= factors[index]
              seconds += unit.to_f * factor
            }
          end
        else
          seconds = durationString.to_f
        end
      end

      seconds
    end

    ##
    # UI Methods
    ##

    def parseOptions
      output = {}

      parser = OptionParser.new

      parser.on("-a", "--add-track YOUTUBE_URLS", "Add tracks to the library, and to a playlist, if specified. Takes a comma-separated list of YouTube URLs or IDs.", " ") do |urls|
        output[:newTracks] = getTracksFromURLs urls.split(',')
      end

      parser.on("-d", "--download", "Enable downloading files when encountering a file that is not already download.", " ") do |keep|
        @autoDownload = true
      end

      parser.on("-L FILE", "--library FILE", "Path to the JSON file containing the library data. Without this option, it is assumed to be TUNEWICH_DIR/tunewich-library.json.", " ") do |libraryPath|
        setLibraryDatabasePath libraryPath
      end

      parser.on("-D DIR", "--input-dir DIR", "Directory where the media files are stored.\nNOTE: when used, this must be the first option. It is recommended to define TUNEWICH_DIR, instead.", " ") do |inputDir|
        # FIXME 1gpaoe: always process this option first, even if it's provided last
        setLibraryMediaPath inputDir
      end

      parser.on("-f RULES", "--filter RULES", FILTER_HELP_1, FILTER_HELP_2, FILTER_HELP_3, " ") do |rules|
        @trackFilters = parseOptionParameters rules
      end

      parser.on("-F FORMAT", "--format FORMAT", "Set the file format to request for streaming or downloading.", " ") do |format|
        @preferredFileFormat = format.chomp
      end

      parser.on("-h", "--help", "Show this help.", " ") do
        puts parser.help()
        puts "INTERACTIVE COMMANDS"
        interactiveCommands = getInteractiveCommands([], 'help')
        showInteractiveCommandHelp(interactiveCommands)
        kill
      end

      parser.on("-l [COUNT]", "--loop [COUNT]", "Loop tracks COUNT times (indefinitely if COUNT is 0 or missing). A track may contain inner loops on chapters or notes, in which case _each loop_ will be repeated COUNT times.", " ") do |count = 0|
        @loop = true
        @loopLimit = count.to_i
      end

      parser.on("-L [COUNT]", "--inner-loop [COUNT]", "Only loop internally on tracks with notes/chapters having \"loop targets\" defined.", " ") do |count = 0|
        @innerLoopsOnly = true
        @loop = true
        @loopLimit = count.to_i
      end

      parser.on("--log FILE", "Log most verbose output to FILE. This includes events and crosstalk between the script and player", " ") do |logFile|
        $logFilePath = logFile
      end

      parser.on("--loglevel LEVEL", "Set the log verbosity, as with -v, but applying only to logs. By default, all messages are logged.", " ") do |level|
        @logVerbosity = level ? level.to_i : 1
        whisper("Log level: #{@logVerbosity}", 1)
      end

      parser.on("--readonly", "Do not write any changes to the library file.", " ") do
        @writeEnabled = false
      end

      parser.on("-m MODE", "--mode MODE", "Choose a player mode: #{MODES.keys.join ', '}", " ") do |modeName|
        if MODES.has_key? modeName
          @userMode = modeName
        else
          putsRealtime "#{modeName} is not a valid player mode. Please use one of #{MODES.keys.join ', '}"
        end
      end

      parser.on("-N", "--no-network", "Don't fetch any information or media from the internet. Use only local files.", " ") do
        @networkEnabled = false
        @trackFilters ||= {}
        @trackFilters['local'] = ''
      end

      parser.on("-o OPTIONS", "--player-opts OPTIONS", "Set player options. Set interactively with the /player command. You can also add mplayer options in #{$serviceConfigDir}/mplayer.options (You can find a starting copy in the 'config' directory that came with tunewich). --player-opts will override those options.", " ") do |options|
        @playerOverrideCommands.concat(options.split(' -').map.with_index { |option, index|
          option = "-#{option}" if index > 0
          option
        })
      end

      parser.on("-p", "--playlist [NAME]", "Choose or create a playlist. If no NAME/QUERY is given, a name is guessed from other input, such as a -q query", " ") do |playlistQuery|
        output[:playlistQuery] = playlistQuery
      end

      parser.on("-q", "--query QUERY", "Search YouTube for a video.", " ") do |query|
        @youtubeSearch = query
      end

      parser.on("-r", "--rating-prompt [SECONDS]", "Prompt for a rating and tags after every track plays, waiting 5 (or the number given) seconds before continuing to the next track", " ") do |seconds|
        @ratingsPromptDuration = seconds ? seconds.to_i : 5
      end

      parser.on("-R [SERVER_TYPE]", "--radio [SERVER_TYPE]", "TODO: stream to a network radio service (SERVER_TYPE: default 'homebrew' or 'Nicecast'", " ") do |streamingServerType = 'homebrew'| #1gG4jc
        if !streamingServerType || streamingServerType.length == 0
          streamingServerType = 'homebrew'
        end
        @streamingServerType = streamingServerType
        whisper("streamingServerType: #{streamingServerType}", 2)
        isRadioConfigured = true
        whisper("Preparing to start radio (#{streamingServerType}).", 0)
        if streamingServerType == 'homebrew'
          whisper("About to prompt you for your password, so that the darkice server can be run as root.", 0)
          `sudo ls &>/dev/null`
        end
        if UNAME == "Darwin"
          audioDeviceID = `say -a ? | grep 'Soundflower (2ch)'`.chomp.sub(/^\s*(\d+).*/, '\1')
          if audioDeviceID && audioDeviceID.length > 0
            @playerOverrideCommands << "-ao coreaudio:device_id=#{audioDeviceID}"
            jackAudioDeviceAndOptions = "coreaudio -d SoundflowerEngine:0"
          else
            whisper("Please install Soundflower (https://github.com/mattingalls/Soundflower)", 0)
            isRadioConfigured = false
          end
        else
          whisper("Playing to jack server", 2)
          @playerOverrideCommands << "-ao alsa"
          jackAudioDeviceAndOptions = "alsa"
        end

        if isRadioConfigured
          bind 'play_start', Proc.new {
            updateRadioMetadata @currentTrack['title']
          }
          bind 'chapter_change', Proc.new {
            updateRadioMetadata "#{@currentTrack['title']} (#{@currentTrack['chapters'][@currentNoteIndex['chapters']]['text']})"
          }
          if streamingServerType == 'homebrew'
            icecastConfigFile = "#{$serviceConfigDir}/icecast.xml"
            darkiceConfigFile = "#{$serviceConfigDir}/darkice.cfg"

            if not File.exist? icecastConfigFile
              whisper("Please create the icecast config file at #{icecastConfigFile}.", 0)
              isRadioConfigured = false
            elsif not File.exist? darkiceConfigFile
              whisper("Please create the darkice config file at #{darkiceConfigFile}.", 0)
              isRadioConfigured = false
            end
          else
            whisper("Radio is configured. Ready to play.", 2)
          end
        else
          whisper("Radio is NOT configured. Ready to play.", 2)
        end

        # Currently 2 methods of doing radio:
        # Both have the same first step, using Soundflower.
        # a) Rogue Amoeba's Nicecast (functionaly, not free)
        #		1) mplayer plays to "Soundflower (2ch)" audio device
        #		2) Nicecast captures "Soundflower (2ch)" and streams with its built-in icecast server
        #			i) The capture is probably what's being paid for here, since their other capture tools are also paid.
        # b) jack + darkice + icecast (not currently working)
        #		1) mplayer plays to "Soundflower (2ch)" audio device
        #		2) jackd captures audio from "Soundflower (2ch)" (getting errors)
        # 	3) darkice pushes the jackd audio to the icecast2 server (might be working)
        # 	4) listeners stream music from the icecast2 server (seems to be working)
        #
        # This article from 2012 has some good info, but it may be outdated.
        # http://dzello.com/blog/2012/11/21/live-stream-audio-from-osx-mountain-lion-with-icecast-and-darkice/

        if isRadioConfigured
          if UNAME == 'Darwin'
            puts "#" * 40
            puts "## Open Soundflowerbed and make sure that the volume is all the way up on Soundflower (2ch)."
            puts "## If you mute your system audio, \"Soundflower (2ch)\" may also be muted, so take care not to do that. Open up Soundflowerbed \"Audio Setup\" and unmute \"Soundflower (2ch)\" if that happens."
            puts "#" * 40
          end
          if streamingServerType == 'homebrew'
            @services = []
            whisper("starting jackd (to capture audio)", 2)
            @services << Thread.new { `sudo jackd -d #{jackAudioDeviceAndOptions}` }
            whisper("starting icecast (to stream audio to listeners)", 2)
            if UNAME == 'Darwin'
              @services << Thread.new { `icecast -c "#{icecastConfigFile}"` }
            else
              @services << Thread.new { `icecast2 -c "#{icecastConfigFile}"` }
            end
            darkiceStartDelay = 5.0
            whisper("waiting #{darkiceStartDelay} seconds to start darkice", 2)
            sleep darkiceStartDelay
            whisper("starting darkice (to encode and push audio to streaming server)", 2)
            @services << Thread.new { `sudo darkice -v 10 -c "#{darkiceConfigFile}"` }
          else
            whisper("continue to Nicecast server", 2)
          end
        else
          whisper("Unable to configure radio server.", 0)
        end
      end

      parser.on("-s", "--shuffle", "Enable shuffle.", " ") do
        @shuffle = true
      end

      # parser.on("-S SESSION", "--session SESSION", "Load a session: a set of most options, like filters, track list. Pass no value in order to see a list of sessions available See INTERACTIVE COMMANDS for info on saving a session during playback.", " ") do
      # 	# TODO 1gTpuh: implement named sessions
      # end

      parser.on("-t INDEX/QUERY", "--track INDEX/QUERY", "Seek to the given track (either by its number in the list, or by its name).", " ") do |trackQuery|
        @trackQuery = trackQuery
      end

      parser.on("-c INDEX/QUERY", "--chapter INDEX/QUERY", "Seek to the given chapter.", " ") do |chapterQuery|
        @chapterQuery = chapterQuery
      end

      parser.on("-U", "--update-track-info", "Fetch updated track information for every track played.", " ") do
        @updateAllPlayedTrackInfo = true
      end

      parser.on("-v [LEVEL]", "--verbose", "Chatter about what's going on (more detailed or frequent messages are in levels 2 or 3.", " ") do |level|
        @configuredVerbosity = level ? level.to_i : 1
        whisper("Verbosity level: #{@configuredVerbosity}", 1)
      end

      parser.on("-w", "--write [SECONDS]", "Save changes to the library. If SECONDS are given, only tracks played that many seconds will be written.", " ") do |seconds|
        @yesToConfirmPropts = true
        @writeAfterSecondsPlayed = seconds ? seconds.to_f : 0.0
      end

      parser.on("-x", "--exclude-filter RULES", "Excludes tracks matching the rules. See --filter", " ") do |rules|
        @trackExcludeFilters = parseOptionParameters rules
      end

      unparsedOptions = parser.parse(ARGV)
      whisper("unparsed options: #{unparsedOptions}", 4)

      output
    end

    def doOptionSecondaryActions optionsOutput
      if not @mediaDirectoryPath
        whisper("please specify an input directory with -i", 0)
        kill
      end

      if @youtubeSearch && @networkEnabled
        @youtubeSearchPage = 1
        searchedTracks = searchYouTube @youtubeSearch
        useTracks searchedTracks if searchedTracks
      end

      if optionsOutput.has_key? :playlistQuery
        if optionsOutput[:playlistQuery]
          match = firstFuzzyMatch optionsOutput[:playlistQuery], @library['playlists'].keys

          if match && match[:score] > 1 # FIXME 1gpaoq: what's a good baseline score for a playlist match?
            playlistName = match[:value]
          elsif confirm("Create new playlist #{optionsOutput[:playlistQuery]}?")
            playlistName = optionsOutput[:playlistQuery]
          end
        elsif @youtubeSearch
          playlistName = @youtubeSearch
        end

        if playlistName
          if not @library['playlists'].has_key? playlistName
            whisper("Creating new playlist: #{playlistName}", 0)
            createPlaylist playlistName
            writeLibraryToFile
          end

          usePlaylist playlistName, true
        end
      end

      if optionsOutput.has_key? :newTracks
        optionsOutput[:newTracks].each { |newTrack|
          if 0 == @writeAfterSecondsPlayed
            trackReference = addTrackToLibrary newTrack
            addTrackReferenceToPlaylist trackReference, @playlistName if @playlistName
          end
          @tracks << newTrack
        }
        writeLibraryToFile true
      end
    end

    def getTracksFromURLs(urls, getAll = false)
      tracks = []

      getHTTPHeaderByPattern = Proc.new { |head, pattern|
        value = nil
        if head
          matchingLines = head.lines.keep_if { |line| line.match(pattern) }
          if matchingLines && matchingLines.length > 0
            value = matchingLines.last.chomp.sub pattern, '\1'
          end
        end
        value
      }

      urls.each { |url|
        urlCanBeScraped = true # assuming this for now
        if url.match(/ocremix\.org\/remix/)
          tracks << matchExistingLibraryTrack(createTrack(url, 'ocremix'))
          whisper("This URL contains an OC Remix ID. Adding.", 0)
        elsif looksLikeAYouTubeID? url
          youtubeId = url
        else
          youtubeId = getYoutubeIdFromUrl url
        end

        if youtubeId
          tracks << updateTrackInfo(matchExistingLibraryTrack(createTrack(youtubeId, 'youtube')))
          whisper("This URL contains a YouTube ID. Adding.", 0)
        else
          urlHTTPHead = `curl -sL --head "#{url}"`
          urlContentType = getHTTPHeaderByPattern.call(urlHTTPHead, /^Content-Type: ([^;]*).*/i)
          cookieDomain = getHTTPHeaderByPattern.call(urlHTTPHead, /^Set-Cookie:.*domain=([^;]*).*/i)
          whisper("urlContentType: #{urlContentType}, cookieDomain: #{cookieDomain}", 3)
          if 'text/html' == urlContentType && (cookieDomain == '.bandcamp.com' || url.match(/(https?:\/\/)([^\.]+)\.bandcamp\.com.*/))
            whisper("WIP: scraping bandcamp page")
            urlCanBeScraped = false
            bandcampTracks = loadBandcamp url
            tracks.concat(bandcampTracks) if bandcampTracks
          elsif 'text/html' == urlContentType && cookieDomain == '.soundcloud.com'
            whisper("WIP: getting soundcloud track")
            urlCanBeScraped = false
            soundcloudTracks = loadSoundcloud url
            tracks.concat(soundcloudTracks) if soundcloudTracks
          elsif urlContentType && ['text/xml', 'application/rss+xml'].include?(urlContentType) # TODO: 1gG4kV
            whisper("WIP: try to load podcast feed")
            urlCanBeScraped = false
            podcastTracks = loadPodcast url
            tracks.concat(podcastTracks) if podcastTracks
          elsif urlContentType.match(/^audio\//)
            urlCanBeScraped = false
            whisper("assuming that URL is an audio file. Adding as a track", 3)
            track = createTrack(url, urlContentType)
            whisper("track: #{track}", 3)
            track = matchExistingLibraryTrack(track)
            whisper("track (after matching existing): #{track}", 3)
            tracks << track
            whisper("added: #{tracks.last}", 3)
          end
        end

        begin
          if urlCanBeScraped && getAll
            youTubeTracks = getYouTubeTracksFromPage url
            tracks.concat(youTubeTracks) if youTubeTracks
          end
        rescue Exception => e
          whisper("Trouble scraping this page: #{e.message}\nbacktrace: #{e.backtrace.join "\n"}", 0) # TODO: well you give it some...Trouble.
        end
      }

      whisper("Added these tracks: #{tracks.join(', ')}", 3)
      tracks
    end

    def loadPodcast url
      feedAlreadyInLibrary = false
      @library['feeds'] ||= []
      @library['feeds'].each { |feed|
        if feed['src'] == url
          feedAlreadyInLibrary = true
          break
        end
      }
      feedXML = `curl -sL "#{url}"`
      feedDoc = REXML::Document.new(feedXML)
      if not feedDoc
        whisper("bad feed XML", 3)
        whisper(feedXML, 4)
        return nil
      end
      channel = REXML::XPath.first(feedDoc, '//rss/channel')
      if not feedAlreadyInLibrary
        podcastFeed = {
          'title' => REXML::XPath.first(channel, 'title').text,
          'description' => REXML::XPath.first(channel, 'description').text,
          'src' => url,
          'type' => 'podcast',
          'dateAdded' => Time.now.to_i
        }
        @library['feeds'] << podcastFeed
        writeLibraryToFile
      end
      podcastTracks = []
      REXML::XPath.each(channel, 'item') { |itemElement|
        whisper("itemElement: #{itemElement}", 4)
        enclosure = REXML::XPath.first(itemElement, 'enclosure')
        if enclosure
          newTrack = createTrack(enclosure.attribute('url').to_s.gsub('&amp;', '&'), enclosure.attribute('type').to_s || 'audio/mpeg')
          newTrack['title'] = REXML::XPath.first(itemElement, 'title').text.chomp
          descriptionElement = REXML::XPath.first(itemElement, 'itunes:summary') || REXML::XPath.first(itemElement, 'description')
          newTrack['description'] = descriptionElement.text.chomp
          durationElement = REXML::XPath.first(itemElement, 'itunes:duration')
          newTrack['duration'] = durationElement.text.chomp if durationElement
          linkElement = REXML::XPath.first(itemElement, 'link')
          newTrack['link'] = linkElement.text.chomp if linkElement
          whisper("newTrack: #{newTrack}", 4)
          podcastTracks << newTrack
        else
          whisper("This RSS item does not have an enclosure, i.e. no link to the audio", 3)
        end
      }
      podcastTracks.reverse # put the oldest ones first
    end

    def loadBandcamp url
      whisper("loadBandcamp #{url}", 3)
      tracks = []
      open(url) do |handle|
        handle.each_line { |line|
          matchResults = line.match(/^\s*trackinfo: (.*?),?$/)
          if matchResults
            whisper("loadBandcamp: found trackinfo: #{matchResults[1]}", 3)
            trackinfo = JSON.parse matchResults[1]
            if trackinfo
              whisper("loadBandcamp: trackinfo is valid JSON", 3)
              trackinfo.each { |bandcampTrack|
                if bandcampTrack.has_key?('file') && bandcampTrack['file'].has_key?('mp3-128')
                  whisper("loadBandcamp: found track file #{bandcampTrack['file']['mp3-128']}", 3)
                  fileURL = bandcampTrack['file']['mp3-128']
                  fileURL = "http:#{fileURL}" if fileURL.match(/^\/\//)
                  track = createTrack(fileURL, 'audio/mpeg')
                  track['title'] = bandcampTrack['title'] if bandcampTrack.has_key?('title')
                  if bandcampTrack.has_key?('title_link')
                    urlDomain = url.sub(/((^(https?:)?\/\/)?[^\/]+).*/, '\1')
                    track['link'] = "#{urlDomain}#{bandcampTrack['title_link']}"
                  end
                  tracks << track
                end
              }
            end
          end
        }
      end
      tracks
    end

    def loadSoundcloud url
      whisper("loadSoundcloud #{url}", 3)
      tracks = [createTrack(url, 'soundcloud')]
      whisper("tracks: #{tracks}", 3)
      tracks
    end

    def encodeOptionParameters hash
      clumps = []
      hash.each { |key, value|
        clumps << "#{key}=#{value}"
      }
      clumps.join ','
    end

    def parseOptionParameters serialized
      hash = {}
      # TODO: 1gG4kY

      serialized.split(',').each { |clump|
        pair = clump.split '='
        hash[pair[0]] = pair[1]
      }

      hash
    end

    def printRepeat message, shouldReturnCursorToBeginning = false
      message = message.to_s if message.respond_to? 'to_s'
      outputMessage = "	#{message}"
      print "\r#{$clearLineCharacter}#{$disableWrapCharacter}#{outputMessage}#{$enableWrapCharacter}"
      print "\r" if shouldReturnCursorToBeginning
    end

    def cliRotate
      if not @cliRotateIndex
        @cliRotateIndex = 0
        @cliRotateCharacters = ['==', '\\\\', '||', '//']
      else
        @cliRotateIndex = (@cliRotateIndex + 1) % @cliRotateCharacters.length
      end

      @cliRotateCharacters[@cliRotateIndex]
    end

    def editListInVim list, instructions = nil
      scopedShouldShowRealtimeOutput = @shouldShowPlaybackInfo
      disablePlaybackInfo
      instructions ||= "edit"
      fileDirections = "##\n#{instructions.gsub(/^/, '# ')}\n##"

      editListName = 'edit-list'
      deleteTempFile editListName
      putInTempFile editListName, list.join("\n") + "\n\n" + fileDirections

      system "vim #{getTempFilePath editListName}"

      list = readTempFile(editListName).strip.lines
      list.map! { |line|
        line.sub(/\n/, '')
      }
      list.delete_if { |line| # remove empty and comment lines from the list
        line.match(/^(#.*|\s*)$/)
      }

      deleteTempFile editListName

      whisper(list, 4)

      @shouldShowPlaybackInfo = scopedShouldShowRealtimeOutput

      list
    end

    def editHashInVim map, instructions = nil
      editableList = map.map { |name, value|
        "#{name}: #{value}"
      }
      editedOutput = editListInVim editableList, instructions
      outputHash = {}
      editedOutput.each { |line|
        parts = line.match(/^([^:]+): (.*)/)
        whisper("edited map line: name='#{parts[1]}',	value='#{parts[2]}'", 3)
        outputHash[parts[1]] = parts[2]
      }
      outputHash
    end

    def editTrackList tracks
      editedList = editListInVim(listTrackTitles(tracks), "remove or comment with # any tracks you want to deselect")
      getTracksFromTitleList editedList, tracks
    end

    def showInteractiveCommandHelp commands = nil
      commandInfo = []
      maxCommandNameLength = 0
      sortedCommandList = []
      whisper("gathering command info", 3)
      commands.each { |name, command|
        sortedCommandList << {:name => name, :command => command}
        maxCommandNameLength = name.length if name.length > maxCommandNameLength
      }
      sortedCommandList.sort! { |a,b| a[:name] <=> b[:name] }
      sortedCommandList.each { |commandMeta|
        info = "		/"
        commandPaddingLength = info.length
        info << commandMeta[:name]
        info << " " * (maxCommandNameLength - info.length + commandPaddingLength)
        info << " : #{commandMeta[:command]['description']}" if commandMeta[:command]['description']
        commandInfo << info
      }
      putsRealtime(commandInfo.join("\n"))
      nil
    end

    def processCommandsWithInput commandLoopInput, commands, leftoverAction
      while commandLoopInput && !commandLoopInput.empty? && commandLoopInput[0] == '/'
        whisper("parsing commands, input: #{commandLoopInput}", 3)
        commandName = nil
        commandInput = nil
        inputParts = commandLoopInput.match(/^\/(?<name>[^\s]*)\s*(?<input>.*)/)
        if inputParts
          commandName = inputParts[:name]
          commandInput = inputParts[:input]
          if !commands.has_key? commandName
            possibleCommands = fuzzyStringSearchInList(commandName, commands.keys).keep_if{ |c| c[:starts] }.map { |c| c[:value] }
            if possibleCommands.length == 1
              whisper("matched #{commandName} -> #{possibleCommands[0]}", 1)
              commandName = possibleCommands[0]
            else
              commandName = ''
              commandLoopInput = nil
              putsRealtime "Did you mean #{possibleCommands.join ", or "}?" if possibleCommands.length > 1
            end
          end
        else
          commandName = ''
        end

        if commands.has_key? commandName
          commandInfo = {
            :name => commandName,
            :commandLoopInput => commandInput,
            :output => nil
          }
          begin
            commandInfo[:output] = commands[commandName]['action'].call(commandInput, commands[commandName])
          rescue Exception => e
            putsRealtime "There was a problem running '#{commandName}' with input '#{commandInput}'"
            whisper("Exception: #{e.message}\nbacktrace: #{e.backtrace.join "\n"}", 3)
          end
          whisper("command info: #{commandInfo}", 3)
          if commandInfo[:output] && commandInfo[:output][:action]
            whisper("chained command calling action (#{commandInfo[:output][:action]})", 3)
            leftoverAction.call commandInfo[:output][:action]
          end
          if commandInfo[:output] && commandInfo[:output][:chainedInput] && commandInfo[:output][:chainedInput].length > 0
            whisper("chained commandLoopInput: #{commandInfo[:output][:chainedInput]}", 3)
            if commandInfo[:output][:bindChainToEvent]
              commandLoopInput = nil
              whisper("binding deferred chained commands to event '#{commandInfo[:output][:bindChainToEvent]}'", 3)
              bindOnce commandInfo[:output][:bindChainToEvent], Proc.new {
                whisper("running deferred chained commands", 1)
                whisper("deferred commands: #{commandInfo[:output][:chainedInput]}", 2)
                commandLoopInput = processCommandsWithInput(commandInfo[:output][:chainedInput], commands, leftoverAction)
              }, commandInfo[:output][:bindingGroupName]
              break
            else
              commandLoopInput = commandInfo[:output][:chainedInput]
            end
          else
            whisper("no chained commandLoopInput", 3)
            commandLoopInput = nil
            break
          end
        end
      end

      whisper("no more commands to execute (for now)", 3)

      commandLoopInput
    end

    def handleInputLine inputLine, commands, leftoverAction
      @commandHistory.unshift inputLine
      enablePlaybackInfo

      begin
        whisper("received input: #{inputLine}", 3)
        if commands
          inputLine = processCommandsWithInput(inputLine, commands, leftoverAction)
        end

        handledActionResponse = true
        if leftoverAction && inputLine && inputLine.length > 0
          whisper("input left over after commands: passing to action (#{inputLine})", 3)
          handledActionResponse = leftoverAction.call inputLine
        end
      rescue Exception => e
        whisper("Exception: #{e.message}\nbacktrace: #{e.backtrace.join "\n"}", 3)
      end

      handledActionResponse
    end

    def handleInputCharacter inputCharacter, prompt, commands, leftoverAction
      result = true

      begin
        if /[\n\r]/.match inputCharacter
          inputLine = @commandUserInput
          @commandUserInput = nil
          actionResponse = handleInputLine(inputLine, commands, leftoverAction) if inputLine

          if actionResponse
            prompt.call
          else
            result = false
          end
        elsif inputCharacter == " " && (!@commandUserInput || @commandUserInput.length == 0) # first space
          togglePlay
        elsif inputCharacter == "" # control-c character
          result = false
          case @userMode
          when MODES['play']
            setUserMode MODES['edit']
            exitPlayerCommand
          when MODES['edit']
            kill
          end
        elsif inputCharacter == "" # backspace
          if @commandUserInput
            @commandUserInput = @commandUserInput[0,@commandUserInput.length - 1]
            if @commandUserInput.length > 0
              printRepeat @commandUserInput
            else
              @commandUserInput = nil
              enablePlaybackInfo;
            end
          end
        elsif inputCharacter == "" # control-z: stop job
          shouldTogglePause = @isPlayerPlaying
          whisper("before STOP+toggle, shouldTogglePause: #{shouldTogglePause}", 0)
          togglePlay if shouldTogglePause
          whisper("before STOP, after toggle, shouldTogglePause: #{shouldTogglePause}", 0)
          sleep 0.1
          Process.kill("STOP", Process.pid)
          # TODO: 1gG4ko: the player usually doesn't unpause :/
          whisper("after STOP, shouldTogglePause: #{shouldTogglePause}, @isPlayerPlaying: #{@isPlayerPlaying}", 0)
          togglePlay if shouldTogglePause
        elsif inputCharacter == "" # control-u: clear line
          @commandUserInput = nil
          @commandInputTyped = nil
          enablePlaybackInfo
        else
          if not @commandUserInput
            @commandUserInput = ''
            disablePlaybackInfo
            if inputCharacter == '/'
              @commandinputStartPlayerTime = @currentPlayerTime
            end
          end

          if inputCharacter == "\e[A" # up arrow
            if @commandInputTyped
              matchingCommands = @commandHistory.select { |command|
                command.start_with? @commandInputTyped if command
              }
              if matchingCommands && matchingCommands.length > 0
                @commandUserInput = matchingCommands.last
              end
            else
              @commandHistoryIndex = (@commandHistoryIndex ? @commandHistoryIndex + 1 : 0) % @commandHistory.length
              @commandUserInput = @commandHistory[@commandHistoryIndex]
            end

            printRepeat @commandUserInput
          elsif inputCharacter == "\e[B" # down arrow
            if @commandInputTyped
              matchingCommands = @commandHistory.select { |command|
                command.start_with? @commandInputTyped
              }
              if matchingCommands && matchingCommands.length > 0
                @commandUserInput = matchingCommands.first
              end
            else
              @commandHistoryIndex = (@commandHistoryIndex ? @commandHistoryIndex - 1 : 0) % @commandHistory.length
              @commandUserInput = @commandHistory[@commandHistoryIndex]
            end

            printRepeat @commandUserInput
          elsif inputCharacter == "\e[C" # right arrow
            whisper("TODO: move cursor right", 3)
          elsif inputCharacter == "\e[D" # left arrow
            whisper("TODO: move cursor left", 3)
          elsif inputCharacter == "	" # tab
            whisper("tab completion (TODO: repeat tab to step through matches)", 3)
            tailNotice = nil
            if @commandUserInput[0] == "/"
              inputCommands = @commandUserInput.sub(/^\//, '').split(/ \//)
              lastCommandIndex = inputCommands.length - 1
              if lastCommandIndex > -1
                # NOTE: there is a command whose name is an empty string
                commandParts = getCommandInputParts(inputCommands[lastCommandIndex], /^(?<command>\w*)( +(?<input>.*))?/)
                if commandParts
                  commandKeys = commands.keys
                  commandName = commandParts[:command]
                  if (
                      commandName &&
                      commandName.length > 0 &&
                      !commands.has_key?(commandName)
                  )
                    newCommandName = firstFuzzyMatchValue commandName, commandKeys
                    if newCommandName
                      commandName = newCommandName
                    end
                  end

                  commandInput = commandParts[:input] || ''

                  if commands.has_key?(commandName)
                    if commandInput.length == 0
                      putsRealtime "\n#{commandName}: #{commands[commandName]['description']}"
                      if commands[commandName].has_key?('showStatus')
                        modifiedCommandInput = commands[commandName]['showStatus'].call(commands[commandName])
                      end
                      if commands[commandName].has_key?('args')
                        tailNotice = "options: #{commands[commandName]['args'].join(", ")}"
                      end
                    end

                    if commands[commandName].has_key?('args')
                      inputParts = getCommandInputParts(commandInput)
                      if inputParts && inputParts[:query] && inputParts[:query].length > 0
                        guessArg = firstFuzzyMatchValue(inputParts[:query], commands[commandName]['args'])
                        if guessArg && guessArg.length > 0
                          commandInput = commandInput.sub!(inputParts[:query], guessArg)
                        end
                      end
                    end

                    if commands[commandName].has_key?('tabComplete')
                      modifiedCommandInput = commands[commandName]['tabComplete'].call(commandInput, commands[commandName])
                      commandInput = modifiedCommandInput if modifiedCommandInput
                    elsif commands[commandName].has_key?('inputOptions')
                      genericTabComplete = Proc.new { |input, command|
                        whisper("generic tab complete for command '#{commandName}'", 3)
                        inputPattern = command['inputPattern'] if command.has_key?('inputPattern')
                        inputParts = getCommandInputParts(input, inputPattern)
                        inputOptions = command['inputOptions'].call
                        options = []
                        options.concat(command['args']) if command.has_key?('args')
                        options.concat(inputOptions) if inputOptions

                        if inputParts[:query] && inputParts[:query].length > 0
                          options = fuzzyStringSearchInListValues(inputParts[:query], options)
                          if options && options.length > 0
                            if options.length == 1
                              input = input.sub!(inputParts[:query], options[0])
                              options = [] # to hide suggestions
                            end
                          end
                        end

                        if options.length > 0
                          optionsLabel = command.has_key?('inputOptionsLabel') ? command['inputOptionsLabel'] : 'Options'
                          putsRealtime "\n#{optionsLabel}: #{options.join("\n")}"
                        end

                        input
                      }
                      modifiedCommandInput = genericTabComplete.call(commandInput, commands[commandName])
                      commandInput = modifiedCommandInput if modifiedCommandInput
                    end
                  end

                  inputCommands[lastCommandIndex] = "#{commandName} #{commandInput}"
                end
                @commandUserInput = "/" + inputCommands.join(' /')
              else
                tailNotice = "Availble commands: #{commands.keys.join(", ")}"
              end
            end
            putsRealtime "#{tailNotice}\n" if tailNotice
          else
            @commandUserInput << inputCharacter
            @commandInputTyped = @commandUserInput
          end

          printRepeat @commandUserInput
        end
      rescue Exception => e
        whisper("Exception: #{e.message}\nbacktrace: #{e.backtrace.join "\n"}", 3)
      end

      result
    end

    def commandPrompt message = nil, commands = nil, action = nil
      shouldBreakCommandLoop = false
      commandLoopExitBinding = bindOnce 'before_exit', Proc.new {
        whisper "before_exit: break command loop", 3
        shouldBreakCommandLoop = true
      }
      whisper("opening command prompt (commandLoopExitBinding: #{commandLoopExitBinding})", 3)

      prompt = Proc.new {
        print "#{message} " if message
        print "$ "
      }
      prompt.call

      whisper("waiting for user input on STDIN", 3)
      @commandHistoryIndex = nil

      @commandUserInput = nil

      externalInputHandlerId = bind('external_input', Proc.new { |eventName, extInputChar|
        handleInputCharacter(extInputChar, prompt, commands, action)
        false # stop propagation of event
      }, nil, true);
      externalCommandHandlerId = bind('external_command', Proc.new { |eventName, extInput|
        whisper("external_command: #{extInput}", 3)
        handleInputLine(extInput, commands, action) if extInput
        false # stop propagation of event
      }, nil, true);

      while directInputCharacter = readCharacter
        inputResult = handleInputCharacter(directInputCharacter, prompt, commands, action)
        break if shouldBreakCommandLoop || !inputResult
      end

      unbind(commandLoopExitBinding)
      unbind(externalCommandHandlerId)
      unbind(externalInputHandlerId)


      response = {
        :input => @commandHistory[@commandHistory.length - 1] # FIXME: @hack
      }

      whisper("closing command \"#{message}\" prompt (response #{response})", 3)

      response
    end

    def confirm message, commands = nil
      confirmMessage = "#{message} (y/N): "
      confirmed = false
      confirmAction = Proc.new { |input|
        confirmed = input.match(/^[Yy]/)
        !input
      }
      scopedShouldShowRealtimeOutput = @shouldShowPlaybackInfo
      disablePlaybackInfo
      commandPrompt(confirmMessage, commands, confirmAction)
      @shouldShowPlaybackInfo = scopedShouldShowRealtimeOutput
      confirmed
    end

    def promptForPlaylist
      whisper("Please choose a playlist (leave blank to play all):\n	#{@library['playlists'].keys.join "\n	"}", 0)
      selectedListName = nil
      while !selectedListName do
        playlistQuery = commandPrompt[:input]

        if not playlistQuery or playlistQuery.length === 0
          useEntireLibrary
          break
        end

        selectedListName = findPlaylistName playlistQuery

        if not selectedListName
          whisper("No matches. Try again", 0)
        end

      end

      selectedListName
    end

    def getFormattedNoteList notes, emphasizeNoteIndex = nil, emphasisLine = "# ^"
      formattedNotes = notes.map { |note|
        time = note['time'].to_s
        output = "#{" " * ([16-time.length, 0].max)}#{time} #{note['text']}"

        if note.has_key?('skip')
          output = "#{note.has_key?('skip') && note['skip'] ? 'skip' : '    '}" + output
        end

        if note.has_key?('loop_target')
          output << " (loop to \"#{note['loop_target']}\")"
        end

        output
      }

      if emphasizeNoteIndex
        formattedNotes.insert(emphasizeNoteIndex + 1, emphasisLine)
      end

      formattedNotes
    end

    def listTrackTitles(tracks)
      tracks.map { |t| "#{t['title']} [#{t['type']}::#{t['src']}]" }
    end

    def getTracksFromTitleList(titleList, referenceTracks = nil)
      referenceTracks ||= @library['tracks'].values
      tracks = []
      titleList.each { |line|
        matches = line.match(/^(.*) \[(.*)::(.*)\]$/)
        if matches
          trackType = matches[2]
          trackSource = matches[3]
          track = nil
          referenceTracks.each { |referenceTrack|
            if referenceTrack['src'] == trackSource
              track = referenceTrack
              if matches[1].length > 0 and matches[1] != track['title']
                track['title'] = matches[1]
              end
              break
            end
          }
          track = createTrack(trackSource, trackType) if not track
          tracks << track if track
        end
      }

      tracks
    end

    def cloneTracks inputTracks # inputTracks is a map, and tracks (output) is an array? weird
      tracks = []
      inputTracks.each { |id, t| tracks <<	t }
      tracks
    end

    def cloneLibraryToTracks inputLibrary
      tracks = []
      inputLibrary.each { |id, t| tracks << t }
      tracks
    end

    def cloneLibrary inputLibrary
      library = {}
      inputLibrary.each { |id, t| library[t['id']] = t }
      library
    end

    def cloneTracksToLibrary inputTracks
      library = {}
      inputTracks.each { |t| library[t['id']] = t }
      library
    end

    def listenForExternalCommands
      streamName = 'command-queue'
      shouldListenForExternalCommands = true
      Thread.new {
        externalCommandStream = makeStream streamName
        whisper("external command stream: #{externalCommandStream}", 2)
        File.open(externalCommandStream, 'r') { |externalCommandStreamHandle|
          # externalCommand = ""
          while shouldListenForExternalCommands do
            while ($_ = externalCommandStreamHandle.read(1)) do
              trigger 'external_input', $_
              # if $_ != "\n"
              # 	externalCommand << $_
              # else
              # 	if externalCommand && externalCommand.length > 0
              # 		trigger 'external_command', externalCommand
              # 		externalCommand = ""
              # 	end
              # end
            end
          end
        }
      }
      bindOnce 'before_exit', Proc.new{
        whisper "before_exit: killing external commands listener (nerfed: will it allow stuff to continue?)", 3
        shouldListenForExternalCommands = false
      }
    end

    def getPlayerCommands
      case @playerApplication
      when PLAYER_APP_DEFAULT
        `#{@playerApplication} -input cmdlist`
      when PLAYER_APP_TERMUX
        []
      end
    end

  end

end

begin
  player = Tunewich::Player.new
rescue Exception => e
  message = "Exception: #{e.message}\nbacktrace: #{e.backtrace.join "\n"}"
  puts message
  if $logFilePath
    open($logFilePath, 'a') { |f|
      f.puts message
    }
  end
  player && player.kill
end
