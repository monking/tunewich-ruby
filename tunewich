#!/usr/bin/env ruby

require "open-uri"
require "optparse"
require "json"
require "digest"

module Tunewich

	class UI

	end

	class Library

	end

	class Playlist

	end

	class YouTubeClient

	end

	class Player

		PROMPT_TIMEOUT_RESPONSE = 'prompt_timeout_response'
		CHAPTER_SELECT_TIMEOUT = 15
		FILTER_HELP_1 = "Filter tracks by rules, in the format 'key=value,key=value 2,key'."
		FILTER_HELP_2 = "Available rules are: [min-,max-]rating=<#0-5>,title=<query>,tag=<tag>,chapters,last=<[[[DD:]HH:]MM:]SS>."
		FILTER_HELP_3 = "Prepend an 'x-' to your rule to add it to the exclusion filters."
		TAG_INPUT_SPLIT = /[,\s]+/
		PLAYER_APPLICATION = 'mplayer'
		MPLAYER_STDOUT_BUFFER_NAME = 'mplayer-stdout'
		MPLAYER_INPUT_FIFO_NAME = 'mplayer-input'
		UNAME = `uname`

		def initialize
			@library = nil
			@libraryHash = nil
			@sessionID = Random.rand(1024)
			@trackIndex = nil
			@tracks = []
			@verbose = false
			@trackFilters = nil
			@trackExcludeFilters = nil
			@noNetwork = false
			@playlistName = nil
			@volume = 25
			@enableDownload = false
			@preferredFileFormat = 'm4a'
			@keepUnattachedDownload = false

			getEnvironmentConfig

			doOptionSecondaryActions parseOptions

			interactivePlayback
		end

		private

		def whisper message
			puts "  -- #{message}" if @verbose
		end

		def getEnvironmentConfig
			if ENV.key? 'TUNEWICH_PLAYER_OPTS'
				@mplayerDefaultOptions = ENV['TUNEWICH_PLAYER_OPTS']
				@volume = getMplayerConfigVolume
			else
				puts "You can add `export TUNEWICH_PLAYER_OPTS=\"<player options>\"` to your ~/.profile or similar file. Default player is #{Player::PLAYER_APPLICATION}."
			end

			if ENV.key? 'TUNEWICH_DIR'
				setLibraryPath ENV['TUNEWICH_DIR']
			else
				puts "Please add `export TUNEWICH_DIR=\"<path/to/your/music/directory>\"` to your ~/.profile or similar file."
			end
		end

		def interactivePlayback
			if @tracks && @tracks.length > 0
				titleBlock "Playing #{@tracks.length} tracks", '#'
			else
				useEntireLibrary
			end

			if @trackIndex == nil
				if @shuffle
					shuffleIndex()
				else
					@trackIndex = 0
				end
			elsif @trackIndex.is_a? String and @trackIndex != '0'
				@trackIndex = findTrackIndex @trackIndex
			else
				@trackIndex = @trackIndex.to_i
			end

			# TODO: catch SIGINT (ctrl+c) & prompt for playlist again
			playerOutput = nil
			commandRequiresBreak = false
			commandRequiresNext = false
			commandRequiresExit = false
			volumeBeforeFadingOut = 10 # FIXME: better initial default
			speedBeforeRampingOut = 1

			interactiveCommands = {
				'rate' => {
					'info' => "Rate this track.",
					'action' => Proc.new { |input|
						chunks = input.split ' '
						newRating = chunks.shift if (chunks.length > 0) && (chunks[0].match /^[0-9]/)
						if !newRating || newRating.length < 1
							puts "current rating: #{@tracks[@trackIndex]['rating']}"
						else
							@tracks[@trackIndex]['rating'] = newRating.to_i
							if !@tracks[@trackIndex]['unattached'] || @tracks[@trackIndex]['rating'] > 0
								addTrackToLibrary @tracks[@trackIndex] if @tracks[@trackIndex]['unattached']
								writeLibraryToFile true
							end
						end
						{:chainedInput => chunks.join(' ')}
					}
				},
				'bpm' => {
					'info' => "Interactively set the beats-per-minute of the track. Do '/bpm 0' to remove (not chainable)",
					'action' => Proc.new { |newBPM|
						commitBPM = false

						if newBPM.length > 0
							bpm = newBPM.to_f
							commitBPM = true
						else
							firstTimeInSeconds = nil
							lastTimeInSeconds = nil
							iterations = 0;
							bpm = @tracks[@trackIndex]['bpm'];
							puts "Current BPM is #{bpm}." if bpm
							puts "Hit enter on the beat. Type \"k\" to accept, or anything else to cancel setting the BPM."
							while true
								input = STDIN.gets.chomp
								if input.length > 0
									commitBPM = input == 'k'
									break
								end

								iterations += 1
								now = Time.now.to_f
								firstTimeInSeconds ||= now
								lastTimeInSeconds = now
								if lastTimeInSeconds != firstTimeInSeconds
									bpm = ((iterations - 1).to_f / (lastTimeInSeconds - firstTimeInSeconds) * 60.0).round(1);
									printRepeat "BPM: #{bpm} "
								end
							end
							print "\n"
						end

						if commitBPM
							if bpm == 0
								puts "Removing BPM from track."
								@tracks[@trackIndex].delete 'bpm' if @tracks[@trackIndex].has_key? 'bpm'
							else
								puts "Setting track BPM to #{bpm}."
								@tracks[@trackIndex]['bpm'] = bpm
							end
							writeLibraryToFile true
						else
							puts "Canceling: leaving track BPM alone."
						end
						nil
					}
				},
				'tag' => {
					'info' => "Tag this track. (not chainable)",
					'action' => Proc.new { |tags|
						if !tags || tags.length < 1
							puts "current tags: #{getTrackTags @tracks[@trackIndex]}"
						else
							tagsToAdd = tags.split(/[, ]+/)
							tagsToRemove = []
							tagsToAdd.each { |tagName|
								if /^-/.match tagName
									tagsToRemove << tagName.gsub(/^-/, '')
									tagsToAdd.delete tagName
								end
							}
							addTrackToTags @tracks[@trackIndex], tagsToAdd
							removeTagsFromTrack @tracks[@trackIndex], tagsToRemove
							addTrackToLibrary @tracks[@trackIndex] if @tracks[@trackIndex]['unattached']
							writeLibraryToFile true
						end
						nil
					}
				},
				'tagall' => {
					'info' => "Tag all tracks in the current tracklist. (not chainable)",
					'action' => Proc.new { |tags|
						if tags && tags.length > 0
							tagsToAdd = tags.split(/[, ]+/)
							tagsToRemove = []
							tagsToAdd.each { |tagName|
								if /^-/.match tagName
									tagsToRemove << tagName.gsub(/^-/, '')
									tagsToAdd.delete tagName
								end
							}
							@tracks.each { |t|
								addTrackToTags t, tagsToAdd
								removeTagsFromTrack t, tagsToRemove
								addTrackToLibrary t if t['unattached']
							}
							writeLibraryToFile true
						end
						nil
					}
				},
				'go' => {
					'info' => "Go to a track in the current list.",
					'action' => Proc.new { |input|
						chunks = input.split ' '
						trackIndex = chunks.shift
						if trackIndex.to_i == 0
							@trackIndex = findTrackIndex trackIndex
						else
							@trackIndex = trackIndex.to_i - 1 % @tracks.length
						end
						commandRequiresNext = true
						{:chainedInput => chunks.join(' ')}
					}
				},
				'clear' => {
					'info' => 'Clear current tracklist',
					'action' => Proc.new { |input|
						@clearTracks
						{:chainedInput => input}
					}
				},
				'all' => {
					'info' => "Load entire library.",
					'action' => Proc.new { |input|
						useEntireLibrary
						{:chainedInput => input}
					}
				},
				'fade' => {
					'info' => 'Fade volume (/fade VOLUME [DURATION])',
					'action' => Proc.new { |properties|
						output = {}
						fadeCommandMatch = /^(out|in|[0-9.]+x?)( [0-9.]+)?( .+)?$/.match properties
						if fadeCommandMatch
							whisper "fade command"
							duration = fadeCommandMatch[2] && fadeCommandMatch[2].length > 0 ? fadeCommandMatch[2].to_f : 2.0
							output[:chainedInput] = fadeCommandMatch[3] && fadeCommandMatch[3].length > 0 ? fadeCommandMatch[3].strip : nil
							volume = getCurrentMplayerVolume
							targetFadeVolume = fadeCommandMatch[1]
							if targetFadeVolume == 'out'
								whisper "fading out volume"
								targetFadeVolume = 0
								volumeBeforeFadingOut = volume
							elsif targetFadeVolume == 'in'
								targetFadeVolume = volumeBeforeFadingOut
								whisper "fading in volume (to #{targetFadeVolume})"
							elsif targetFadeVolume.match /x$/
								multiplier = targetFadeVolume.to_f
								targetFadeVolume = volume * multiplier
								whisper "fading volume #{multiplier}x (to #{targetFadeVolume})"
							else
								@volume = targetFadeVolume
								whisper "fading to volume #{targetFadeVolume}"
								targetFadeVolume = targetFadeVolume.to_f
							end
							volumeFadeInterval = 0.02
							volumeFadeStepCount = duration / volumeFadeInterval
							volumeStep = (targetFadeVolume - volume) / duration * volumeFadeInterval
							whisper "about to fade volume"
							for stepIndex in 1..volumeFadeStepCount
								volume += volumeStep
								printRepeat "fading: #{volume.round()}"
								putInTempFile Player::MPLAYER_INPUT_FIFO_NAME, "volume #{volume} 1\n"
								sleep volumeFadeInterval
							end
							putInTempFile Player::MPLAYER_INPUT_FIFO_NAME, "volume #{targetFadeVolume} 1\n"
						end
						output
					}
				},
				'ramp' => {
					'info' => 'Ramp speed (/ramp SPEED [DURATION])',
					'action' => Proc.new { |properties|
						# TODO: set a global value, like volume, and apply to each track.
						# option to start each track at the same bpm if it's defined for that track
						rampCommandMatch = /^(out|in|[0-9.]+(bpm)?)( [0-9.]+)?( .+)?$/.match properties
						#                    1              2      3          4
						output = {}
						if rampCommandMatch
							duration = rampCommandMatch[3] && rampCommandMatch[3].length > 0 ? rampCommandMatch[3].to_f : 0.3
							output[:chainedInput] = rampCommandMatch[4] && rampCommandMatch[4].length > 0 ? rampCommandMatch[4].strip : nil
							speed = getCurrentMplayerSpeed
							whisper 'without -af scaletempo[=speed=tempo], min and max limited by the system (~1/8 and ~4.5 on my Mac Mini)'
							targetRampSpeed = determineRelativeSpeed rampCommandMatch[1], @tracks[@trackIndex]
							if targetRampSpeed
								if targetRampSpeed == 'out'
									targetRampSpeed = 0
									speedBeforeRampingOut = speed
								elsif targetRampSpeed == 'in'
									targetRampSpeed = speedBeforeRampingOut
								else
									targetRampSpeed = targetRampSpeed.to_f
								end
								speedRampInterval = 0.02
								speedRampStepCount = duration / speedRampInterval
								speedStep = (targetRampSpeed - speed) / duration * speedRampInterval
								whisper "about to ramp speed by #{speedStep} every #{speedRampInterval} seconds"
								for stepIndex in 1..speedRampStepCount
									speed += speedStep
									printRepeat "ramping: #{(speed * 10.0).round.to_f / 10.0}"
									putInTempFile Player::MPLAYER_INPUT_FIFO_NAME, "speed_set #{speed}\n"
									sleep speedRampInterval
								end
								putInTempFile Player::MPLAYER_INPUT_FIFO_NAME, "speed_set #{targetRampSpeed}\n"
								if output[:chainedInput] && output[:chainedInput].length > 0
									whisper "Waiting 1 second for buffered sound to play"
									sleep 1.0
								end
							else
								puts "Bad speed format, or track has no bpm set."
							end
						end
						output
					}
				},
				'wait' => {
					'info' => 'Wait to execute chained commands',
					'action' => Proc.new { |input|
            chunks = input.split ' '
            if chunks.length > 0 && chunks[0].match(/^[0-9.]+$/)
              sleep chunks.shift.to_f
            end
            {:chainedInput => chunks.join(' ')}
					}
				},
				'list' => {
					'info' => "Load a playlist. (not chainable)",
					'action' => Proc.new { |playlistQuery|
						# TODO: generalized function to list playlists, their track count, and the average rating among rated tracks
						whisper "playlistQuery: #{playlistQuery}"
						playlistNames = @library['playlists'].keys
						if playlistQuery && playlistQuery.length > 0
							match = firstFuzzyMatch optionsOutput[:playlistQuery], playlistNames

							if match && match[:score] > 1 # FIXME: what's a good baseline score for a playlist match?
								playlistName = match[:value]
							end
						end

						if playlistName
							usePlaylist playlistName, true
						else
							puts playlistNames.join "\n"
						end
						commandRequiresNext = true
						nil
					}
				},
				'edit' => {
					'info' => 'Edit playing tracklist in Vim.',
					'action' => Proc.new { |input|
						editedTracklisit = getTracksFromTitleList editListInVim(listTrackTitles(@tracks), "remove or comment any tracks you want to deselect")
						useTracks editedTracklisit, false
						puts "#{@tracks.length} tracks selected"
						{:chainedInput => input}
					}
				},
				'turn' => {
					'info' => "Use all this track's tags to populate the track list.",
					'action' => Proc.new { |input|
						trackTags = getTrackTags @tracks[@trackIndex]
						if trackTags.length > 0
							puts "Playing tracks with similar tags: #{trackTags.join ', '}"
							@trackFilters ||= {}
							@trackFilters['tag'] = "+#{trackTags.join ' +'}"
							useEntireLibrary
							@trackIndex = 1 # next track (current track will almost certainly be at index 0)
							if @shuffle
								@shuffle = false
								puts "shuffle: off"
							end
							commandRequiresNext = true
						else
							puts "Add some tags to this track to find similar tracks."
						end
						{:chainedInput => input}
					}
				},
				'more' => {
					'info' => "Play all tracks on this video's page.",
					'action' => Proc.new { |input|
						# FIXME: diagnose: I updated youtube-dl, and I still get errors all the time, and it'll quit afterward (2016 Feb 29 Mon 11:37:51)
						tracks = getYouTubeTracksFromPage(@tracks[@trackIndex]['src'])
						tracks.shift # remove the first track, which will be the main video on the page
						tracks.unshift @tracks[@trackIndex]
						@trackFilters = nil
						useTracks tracks, false
						@trackIndex = 1
						commandRequiresNext = true
						{:chainedInput => input}
					}
				},
				'info' => {
					'info' => "Show track info",
					'action' => Proc.new { |input|
						chunks = input.split ' '
						index = chunks.shift
						if index && index.length > 0
							index = index.to_i - 1
						else
							index = @trackIndex
						end
						alreadyHas = {
							:title => @tracks[index].has_key?('title'),
							:duration => @tracks[index].has_key?('duration'),
							:description => @tracks[index].has_key?('description'),
							:bpm => @tracks[index].has_key?('bpm')
						}
						tagNames = getTrackTags @tracks[index]

						puts "------------------------------"
						puts "   title : #{@tracks[index]['title']}" if alreadyHas[:title]
						puts "duration : #{@tracks[index]['duration']}" if alreadyHas[:duration]
						puts "    tags : #{tagNames.join ', '}" if tagNames.length > 0
						puts "  rating : #{@tracks[index]['rating']}" if @tracks[index]['rating']
						puts "     bpm : #{@tracks[index]['bpm']}" if alreadyHas[:bpm]
						puts "==============================\n#{@tracks[index]['description']}" if alreadyHas[:description]

						if !alreadyHas[:title] || !alreadyHas[:duration]
							info = getTrackInfo @tracks[index]['src']
							updateTrackInfo @tracks[index], info

							puts "   title : #{@tracks[index]['title']}" if !alreadyHas[:title]
							puts "duration : #{@tracks[index]['duration']}" if !alreadyHas[:duration]
							puts "==============================\n#{@tracks[index]['description']}" if !alreadyHas[:description] && @tracks[index]['description']
						else
							info = {'url' => "http://youtu.be/#{@tracks[index]['src']}"}
						end

						puts "     url : #{info['url']}"
						puts "------------------------------"

						{:chainedInput => chunks.join(' ')}
					}
				},
				'search' => {
					'info' => "<query> Search YouTube. (not chainable)",
					'action' => Proc.new { |query|
						if query and query.length > 1
							useTracks searchYouTube(query), false
							@trackIndex = 0
							@trackFilters = nil
							commandRequiresNext = true
						else
							puts "Enter a search term of at least 2 characters."
						end
						nil
					}
				},
				'loop' => {
					'info' => 'Toggle loop.',
					'action' => Proc.new { |input|
						@loop = !@loop
						commandRequiresNext = true if @loop
						puts "loop: #{@loop ? 'on' : 'off'}"
						{:chainedInput => input}
					}
				},
				'shuffle' => {
					'info' => 'Toggle shuffle.',
					'action' => Proc.new { |input|
						@shuffle = !@shuffle
						puts "shuffle: #{@shuffle ? 'on' : 'off'}"
						{:chainedInput => input}
					}
				},
				'defvolume' => {
					'info' => "TODO: save current volume relative to default in library.",
					'action' => Proc.new { |input|
						track = @tracks[@trackIndex]
						track['loudness'] = getMplayerConfigVolume / getCurrentMplayerVolume
						writeLibraryToFile true
						{:chainedInput => input}
					}
				},
				'download' => {
					'info' => "Download the current track for faster play in the future.",
					'action' => Proc.new { |input|
						if not trackFileExists? @tracks[@trackIndex]
							downloadTrack @tracks[@trackIndex]
						else
							puts "This file is already downloaded."
						end
						{:chainedInput => input}
					}
				},
				'add' => {
					'info' => 'Add a track by id.',
					'action' => Proc.new { |input|
						chunks = input.split ' '
						videoID = chunks.shift
						if videoID.length > 0
							puts "Adding #{videoID} to track list. Playing next."
							@tracks << matchExistingLibraryTrack(createTrack(videoID, 'youtube'))

							# FIXME: I don't necessarily want to go to the track next, but it's better than not being able to find the track
							@trackIndex = @tracks.length - 1
							commandRequiresNext = true
						end
						{:chainedInput => chunks.join(' ')}
					}
				},
				'again' => {
					'info' => "Play the last track again.",
					'action' => Proc.new { |input|
						commandRequiresNext = true
						{:chainedInput => input}
					}
				},
				'filter' => {
					'info' => 'Edit filters.',
					'action' => Proc.new { |input|
						filtersList = @trackFilters.map { |filter, rule| "#{filter}=#{rule}" } if @trackFilters
						filtersList ||= []
						instructions = "#{Player::FILTER_HELP_1}\n#{Player::FILTER_HELP_2}\n#{Player::FILTER_HELP_3}\n\nAvailable tags: #{listAllTagsWithAliases.join ', '}"
						@trackFilters = parseOptionParameters editListInVim(filtersList, instructions).join ','
						filterTracksOnDeck
						{:chainedInput => input}
					}
				},
				'exclude' => {
					'info' => 'Edit exclude filters.',
					'action' => Proc.new { |input|
						# TODO: replace this with "-" prefixed filter keys in the regular filter command (i.e. "-f tag=silly,-tag=vocal")
						filtersList = @trackExcludeFilters.map { |filter, rule| "#{filter}=#{rule}" } if @trackExcludeFilters
						filtersList ||= []
						instructions = "#{Player::FILTER_HELP_1}\n#{Player::FILTER_HELP_2}\n#{Player::FILTER_HELP_3}\n\nAvailable tags: #{listAllTagsWithAliases.join ', '}"
						@trackExcludeFilters = parseOptionParameters editListInVim(filtersList, instructions).join ','
						filterTracksOnDeck
						{:chainedInput => input}
					}
				},
				'exit' => {
					'info' => 'Exit.',
					'action' => Proc.new { |input|
						commandRequiresExit = true
						{:chainedInput => input}
					}
				},
				'verbose' => {
					'info' => 'Toggle Verbose mode.',
					'action' => Proc.new { |input|
						@verbose = !@verbose
						{:chainedInput => input}
					}
				},
				'format' => {
					'info' => 'Choose the file format to download (e.g. "mp4"; default "m4a").',
					'action' => Proc.new { |input|
						chunks = input.split ' '
						@preferredFileFormat = chunks.shift
						{:chainedInput => chunks.join(' ')}
					}
				},
				'commands' => {
					'info' => "List #{Player::PLAYER_APPLICATION} commands.",
					'action' => Proc.new { |input|
						system "#{Player::PLAYER_APPLICATION} -input cmdlist"
						{:chainedInput => input}
					}
				}
			}

			track = nil

			while not playerOutput or playerOutput[:exit] do
				if @trackIndex && @tracks[@trackIndex]
					commandRequiresBreak = false
					commandRequiresNext = false

					track = @tracks[@trackIndex]

					titleBlock "[#{@trackIndex + 1}] - #{track['title']} (#{track['duration']})"

					if @updateAllPlayedTrackInfo && !@noNetwork
						printRepeat "Getting latest track information..."
						updateTrackInfo track
					end

					fileExists = trackFileExists? track

					if !fileExists && @noNetwork
						nextTrack
						next
					end

					chapterIndex = nil

					if track['chapters']
						commandRequiresBreak = false
						commandRequiresNext = false

						chapterPromptMessage = nil

						if !fileExists && !@enableDownload # TODO: checking fileExists, and checking again inside self.play
							chapterPromptMessage = "NOTE: Choosing a chapter will cause the file to download fully before playing."
						end

						chapterResponse = promptForChapterIndex track['chapters'], interactiveCommands, chapterPromptMessage
						chapterIndex = chapterResponse[:index]

						next if commandRequiresNext
						break if commandRequiresBreak
					end

					# TODO: catch C-t, or something like it, to pass commands to the script during playback
					#  -: rating down
					#  =/+: rating up
					#  1-5: explicit rating
					#  t: prompt for tag
					#  l: copy a link to share the source
					#  x: remove from library
					#  d: download
					playerOutput = play track, chapterIndex, interactiveCommands

					track['playTime'] ||= 0
					track['playTime'] += playerOutput[:playTime].to_i
					minimumPlayTime = [30, getSecondsFromDurationString(track['duration']) -10].min
					if playerOutput[:playTime] >= minimumPlayTime
						track['lastPlayed'] = playerOutput[:endTime].to_i
						track['playCount'] ||= 0
						track['playCount'] += 1
					else
						track['skipCount'] ||= 0
						track['skipCount'] += 1
					end
					writeLibraryToFile true

					track['playTime'] ||= 0
					track['playTime'] += playerOutput[:playTime].to_i
					minimumPlayTime = [30, getSecondsFromDurationString(track['duration']) -10].min
					if playerOutput[:playTime] >= minimumPlayTime
						track['lastPlayed'] = playerOutput[:endTime].to_i
						track['playCount'] ||= 0
						track['playCount'] += 1
					else
						track['skipCount'] ||= 0
						track['skipCount'] += 1
					end
					writeLibraryToFile true

					if !track['unattached']
						track['playTime'] ||= 0
						track['playTime'] += playerOutput[:playTime].to_i
						minimumPlayTime = [30, getSecondsFromDurationString(track['duration']) -10].min
						if playerOutput[:playTime] >= minimumPlayTime
							track['lastPlayed'] = playerOutput[:endTime].to_i
							track['playCount'] ||= 0
							track['playCount'] += 1
						else
							track['skipCount'] ||= 0
							track['skipCount'] += 1
						end
						writeLibraryToFile true
					end

					whisper "I've been asked to exit" if commandRequiresExit
					exit if commandRequiresExit
					whisper "I've been asked to break" if commandRequiresBreak
					break if commandRequiresBreak
					whisper "I've been asked to skip to next" if commandRequiresNext
					next if commandRequiresNext

					nextTrack() if not chapterIndex # if a chapter was selected, prompt again in the next iteration
				else
					commandPrompt "empty", interactiveCommands
				end
			end
		end

		def findTag(query)
			tag = nil

			if @library['tags'][query]
				tag = @library['tags'][query]
			else
				@library['tags'].each { |name, t|
					tag = t if t['aliases'].include? query
				}
			end

			tag
		end

		def addTrackToTags(track, tagNames)
			tagNames.each { |tagName|
				matchingTag = findTag tagName
				matchingTag ||= createTag tagName
				matchingTag['tracks'] << track['id']
				matchingTag['tracks'].uniq!
			}
		end

		def removeTagsFromTrack(track, tagNames)
			tagNames.each { |tagName|
				matchingTag = findTag tagName
				if matchingTag
					matchingTag['tracks'].delete track['id'] if matchingTag['tracks'].include? track['id']
				end
			}
		end

		def combineTags(tagNames)
			firstTag = findTag tagNames.shift

			if firstTag
				tagNames.each { |tagName|
					tag = findTag tagName
					if tag && tag != firstTag
						firstTag['aliases'] << tagName
						firstTag['tracks'].concat tag['tracks']
						deleteTag tagName
					end
				}

				firstTag['aliases'].uniq!
				firstTag['tracks'].uniq!
			end

			firstTag
		end

		def createTag(tagName)
			@library['tags'][tagName] = {
				'aliases' => [],
				'tracks' => []
			}

			@library['tags'][tagName]
		end

		def deleteTag(tagName)
			@library['tags'].delete tagName if @library['tags'][tagName]
		end

		def play(track, chapterIndex, interactiveCommands)
			response = {
				:exit => true,
				:playtime => 0
			}
			mplayerStartupOptions = []
			deleteStream Player::MPLAYER_INPUT_FIFO_NAME
			mplayerInputFile = makeStream Player::MPLAYER_INPUT_FIFO_NAME
			mplayerStartupOptions << "-slave -quiet -input file=#{mplayerInputFile}"
			mplayerThread = nil
			inputThread = nil
			mplayerStatus = nil
			mplayerAction = Proc.new { |command|
				whisper "mplayerAction: begin"
				putInTempFile Player::MPLAYER_INPUT_FIFO_NAME, "#{command}\n"
				if /^vol/.match command
					whisper "mplayerAction: found a volume command"
					@volume = getCurrentMplayerVolume
					puts "volume: #{@volume}"
				end
				whisper "mplayerAction: done"

				true
			}
			# TODO: I shouldn't need to check twice
			fileAlreadyExists = trackFileExists? track
			streaming = !fileAlreadyExists && !@enableDownload && !chapterIndex

			if @noNetwork && !fileAlreadyExists
				puts "No local file to play: #{track['title']}"
				return response
			end

			if track['chapters']

				if chapterIndex

					if not streaming
						titleBlock "Chapter #{chapterIndex + 1}: #{track['chapters'][chapterIndex]['name']}"
						offsetSeconds = getSecondsFromDurationString track['chapters'][chapterIndex]['time']
						mplayerStartupOptions << "-ss #{offsetSeconds}"

						if chapterIndex < track['chapters'].length - 1
							nextTrackoffsetSeconds = getSecondsFromDurationString track['chapters'][chapterIndex + 1]['time']
							mplayerStartupOptions << "-endpos #{nextTrackoffsetSeconds - offsetSeconds}"
						end

					else
						titleBlock "This track has chapters, but seeking backward is not supported while streaming. Add the -d option to enable downloading."
					end

				else
					titleBlock "Playing all chapters in track"
				end

			elsif track['loop'].kind_of?(Array)
				whisper "ooh, this track has has an A/B loop!"

				if not streaming
					duration = track['loop'][1] - track['loop'][0]

					# FIXME: this stalls when file is to be downloaded...
					# whisper "putting a 'seek to the beginning' command in the player command input file"
					# mplayerAction.call 'seek 0 1'

					whisper "setting some player startup options"
					# loop back from B to A
					mplayerStartupOptions << "-ss #{track['loop'][0]}"
					mplayerStartupOptions << "-endpos #{duration}"
				else
					titleBlock "This track has an A/B loop, but looping is not supported while streaming. Add the -d option to enable downloading."
				end

			end

			if fileAlreadyExists
				mediaFilePath = firstTrackFile track
			else
				if streaming
					streamName = 'youtube-stream'
					deleteStream streamName
					streamPath = mediaFilePath = makeStream streamName
				end

				if not downloadTrack track, streamPath
					return response
				end
			end

			if not mediaFilePath
				puts "File not found for #{track['title']}."
				return false
			end

			if !streamName
				mplayerStartupOptions << "-loop 0" if track['loop'] or @loop
			end

			mplayerStartupOptions += [@mplayerDefaultOptions] if @mplayerDefaultOptions
			mplayerStartupOptions += @mplayerOverrideCommands
			mplayerStartupOptions += ["-volume #{@volume}"]

			if track['loudness']
				mplayerStartupOptions += ["-volume #{(getMplayerConfigVolume / track['loudness']).round}"]
			end

			response[:startTime] = Time.now.to_f

			mplayerStdoutFile = getTempFilePath Player::MPLAYER_STDOUT_BUFFER_NAME

			inputThread = Thread.new {
				whisper "commandPrompt start (opening input thread)"
				commandPrompt Player::PLAYER_APPLICATION, interactiveCommands, mplayerAction
				whisper "commandPrompt end"
			}
			mplayerThread = Thread.new {
				mplayerCommand = "#{Player::PLAYER_APPLICATION} \"#{mediaFilePath}\" #{mplayerStartupOptions.join ' '} > #{mplayerStdoutFile}"
				whisper mplayerCommand
				mplayerStatus = `#{mplayerCommand}`
				whisper "mplayer is finished. killing user input thread"
				inputThread.kill if inputThread
			}
			mplayerThread.join
			whisper "killing user input thread (again)"
			inputThread.kill if inputThread # FIXME: overkill?

			response[:endTime] = Time.now.to_f

			deleteStream Player::MPLAYER_INPUT_FIFO_NAME
			deleteTempFile Player::MPLAYER_STDOUT_BUFFER_NAME

			response[:playTime] = response[:endTime] - response[:startTime]

			if streaming
				deleteStream streamName
			elsif !fileAlreadyExists && track['unattached'] && !@keepUnattachedDownload
				deleteTrackFile track
				titleBlock "UNATTACHED DOWNLOAD DELETED", 'X'
			end

			response[:exit] = mplayerStatus
			response
		end

		def getMplayerProperty property, pattern = nil
			pattern ||= /^()(.*)$/
			command = "#{property}\n"
			command = "get_property #{command}" if not property.match(/^get_/)
			responseWait = 0.1
			putInTempFile Player::MPLAYER_INPUT_FIFO_NAME, command
			sleep responseWait
			lastPlayerOutput = tailTempFile Player::MPLAYER_STDOUT_BUFFER_NAME
			if lastPlayerOutput
				whisper "read #{property} from player, output: #{lastPlayerOutput}"
				matches = lastPlayerOutput.match pattern
				return matches[2] if matches
			end
			return nil
		end

		def getCurrentMplayerVolume
			getMplayerProperty('volume', /^(ANS_volume=|.*Volume: )(.*?)(\?)?$/).to_f
		end

		def getCurrentMplayerSpeed
			getMplayerProperty('speed', /^(ANS_speed=|.*Speed: )(.*?)(\?)?$/).to_f
		end

		def getMplayerConfigVolume
			mplayerCommands = []
			mplayerCommands += @mplayerOverrideCommands if @mplayerOverrideCommands
			mplayerCommands += [@mplayerDefaultOptions] if @mplayerDefaultOptions
			mplayerConfigVolume = 25.0 # factory default

			mplayerCommands.each { |command|
				if command.include? 'volume'
					mplayerConfigVolume = command.match(/.*-volume ([0-9.]+)/)[1].to_f
				end
			}

			mplayerConfigVolume.to_f
		end

		def nextTrack
			if @shuffle
				# FIXME: this should happen regardles of @shuffle, but it would mess with @trackIndex. With @shuffle == true, it doesn't matter.
				filterTracksOnDeck()
				shuffleIndex()
			else
				@trackIndex += 1

				if @trackIndex > @tracks.length - 1

					if @youtubeSearchPage && !@noNetwork
						@youtubeSearchPage += 1
						useTracks searchYouTube(@youtubeSearch, (@youtubeSearchPage - 1) * 20)
					else
						@trackIndex %= @tracks.length
					end

				end

			end
		end

		def clearTracks
			@tracks = []
			@trackIndex = 0
		end

		def useTracks tracks, append = true
			@tracks = [] if !append
			@tracks += tracks
			filterTracksOnDeck
			if @trackIndex && @trackIndex > @tracks.length - 1
				@trackIndex = 0 # TODO: should this only happen if "loop" option is enabled
			end
		end

		def filterTracksOnDeck
			if @trackFilters
				@tracks = filterTracks @tracks, @trackFilters
			end

			if @trackExcludeFilters
				@tracks = filterTracks @tracks, @trackExcludeFilters, true
			end
		end

		def shuffleIndex
			@trackIndex = Random.rand(@tracks.length - 1) if @tracks.length > 1
		end

		def setLibraryPath libraryPath
			@tunewichDirectory = libraryPath
			if not Dir.exist? @tunewichDirectory
				puts "Please create the directory '#{@tunewichDirectory}'."
				exit
			end

			@fileDirectory = "#{@tunewichDirectory}/music"
			Dir.mkdir @fileDirectory if not Dir.exist? @fileDirectory

			@libraryFilePath = "#{@tunewichDirectory}/tunewich-library.json"
			if not File.exist? @libraryFilePath
				raise "TODO: create library file at #{@libraryFilePath}"
			end

			loadLibrary
		end

		def matchExistingLibraryTrack track
			@library['library'].each { |id, t|
				if t['src'] === track['src']
					track = t
					break
				end
			}
			track
		end

		def getTrackTags track
			tags = []
			@library['tags'].each { |name, tag|
				tags << name if tag['tracks'].include? track['id']
			}
			tags
		end

		def getTrackTitles tracks
			tracks.map{|t| t['title']}
		end

		def findTrackIndex(query)
			match = firstFuzzyMatch query, getTrackTitles(@tracks)
			match ? match[:index] : false
		end

		def findPlaylistName(query)
			match = firstFuzzyMatch query, @library['playlists'].keys
			match ? match[:value] : false
		end

		def fuzzyStringSearchInList(query, list)
			queryPattern = Regexp.new(query + '|' + query.gsub(/\s+/, '').split('').join('.*'), Regexp::IGNORECASE)
			matches = []
			list.each_with_index do |value, index|
				matchedPortion = queryPattern.match(value)

				if matchedPortion
					match = {
						:index => index,
						:value => value,
						:matchLength => matchedPortion[0].length
					};
					match[:density] = query.length.to_f / match[:matchLength].to_f
					match[:breadth] = match[:matchLength].to_f / match[:value].length.to_f
					match[:score] = match[:density] * 10 + match[:breadth]
					matches << match
				end

			end

			if matches.length > 1
				matches.sort! { |a,b| b[:score] <=> a[:score] }
			end

			matches
		end

		def firstFuzzyMatch(query, list)
			matches = fuzzyStringSearchInList query, list
			matches.length ? matches[0] : false
		end

		def deleteTrackFile(track)
			`rm #{getTrackFilePrefix track}*`
		end

		def firstTrackFile(track)
			files = findTrackFiles(track)
			files.length ? files[0] : nil
		end

		def findTrackFiles(track)
			globString = "#{getTrackFilePrefix track}*"
			files = Dir.glob(globString)
			files.delete_if { |fileName| fileName.match /\.part$/ }
			files
		end

		def trackFileExists?(track)
			findTrackFiles(track).length > 0
		end

		def getIdFromFileName(fileName)
			id = fileName.gsub(/^tunewich-([A-Za-z0-9_-]{11}).*$/) {
				$1
			}
			id != fileName ? id : false
		end

		def getTrackFilePrefix(track)
			"#{@fileDirectory}/tunewich-#{track['id']}"
		end

		def downloadTrack(track, streamPath = nil)
			youtubeDlCommandBegin = "youtube-dl -f #{@preferredFileFormat}"
			# youtubeDlCommandBegin = "youtube-dl -f #{@preferredFileFormat} --no-part --no-cache-dir --no-continue"
			youtubeDlCommandEnd = "-- #{track['src']}"

			downloadPid = nil
			downloadFeedbackFileName = 'download-feedback'
			downloadFeedbackFile = createTempFile downloadFeedbackFileName

			if streamPath
				downloadPid = spawn("#{youtubeDlCommandBegin} -o - #{youtubeDlCommandEnd} > \"#{streamPath}\" 2> \"#{downloadFeedbackFile}\"")
			else
				# status = system "#{youtubeDlCommandBegin} -o \"#{getTrackFilePrefix track}-%(title)s.%(ext)s\" #{youtubeDlCommandEnd}"
				downloadPid = spawn("#{youtubeDlCommandBegin} -o \"#{getTrackFilePrefix track}-%(title)s.%(ext)s\" #{youtubeDlCommandEnd} &> \"#{downloadFeedbackFile}\"")
				Process.detach(downloadPid)

				while not trackFileExists? track # FIXME: event driven approach to waiting for a file?
					printRepeat "Fetching video information for download (#{cliRotate})"
					sleep 0.1
				end

				# TODO: see FIXME below
				# if track.has_key? 'duration'
				# 	trackDuration = getSecondsFromDurationString track['duration']
				# 	bufferDuration = trackDuration / 2
				# end

				while true
					output = tailTempFile downloadFeedbackFileName
					# FIXME: get player to play the whole file, even if only part is downloaded when it starts
					# if trackDuration
					# 	etaMatch = output.match(/ETA ([0-9:]+)/)
					# 	if etaMatch
					# 		eta = getSecondsFromDurationString etaMatch[1]
					# 		if eta < bufferDuration
					# 			printRepeat "ETA (#{eta}) is less than #{bufferDuration}. Ready to play.\n"
					# 			break
					# 		end
					# 	end
					# end
					if output.match(/#{track['src']}|100(\.0)?%|ERROR/)
						whisper "downloadTrack: #{output}"
						break
					end
					printRepeat "(#{cliRotate}) #{output}"
					sleep 0.1
				end

				# delayForFileToExist = 5
				# puts "Waiting #{delayForFileToExist} seconds to be sure the file is ready..."
				# sleep delayForFileToExist # FIXME: remove `sleep` in favor of checking if the right file exists yet
			end

			deleteTempFile downloadFeedbackFileName

			downloadPid
		end

		def notify(message)
			if UNAME == 'Linux'
				`notify-send --expire-time=3000 --urgency=low tunewich "#{message}"`
			end
		end

		def titleBlock(message, fill = '=', width = 80)
			blockRow = fill * width
			padding = '  '
			marginSize = (width - message.length) / 2 - padding.length
			marginLeft = marginSize > 1 ? fill * marginSize : ''
			marginRight = marginLeft
			marginRight += fill if message.length % 2 == 1
			puts "\n#{blockRow}"
			puts "#{marginLeft}#{padding}#{message}#{padding}#{marginRight}"
			puts blockRow
			notify message
		end

		##
		# File Methods
		##

		def getTempFilePath(name)
			"/tmp/tunewich-#{@sessionID}-#{name}"
		end

		def createTempFile(name)
			whisper "make tmp #{name}"
			putInTempFile name, ''
		end

		def putInTempFile(name, value)
			path = getTempFilePath name
			# FIXME: why does this stall when writing to a FIFO before something is reading from it?
			writeResult = File.write(path, value)
			whisper "#{name} << '#{value.chomp}' (#{writeResult})"
			writeResult && path
		end

		def readTempFile(name)
			whisper "read tmp #{name}"
			path = getTempFilePath name

			if File.exist? path
				whisper "read tmp #{name}: exists"
				contents = File.read path
				whisper "read tmp #{name}, contents: #{contents}"
				return contents
			else
				whisper "read tmp #{name}: missing"
				return ''
			end
		end

		def tailTempFile(name)
			whisper "tail tmp #{name}"
			content = readTempFile name
			lastLine = ''
			if content && content.length > 0
				lastLine = content.gsub("\r","\n").lines.pop.strip.chomp
			end
			lastLine
		end

		def deleteTempFile(name)
			whisper "delete tmp #{name}"
			path = getTempFilePath name

			if File.exist? path
				File.delete path
			end
		end

		def makeStream(name)
			path = getTempFilePath name
			whisper "mkfifo #{path}"

			if File.exist? path
				File.delete path
				# raise "The temp file '#{name}' already exists. (#{path})"
			end

			if not system "mkfifo \"#{path}\""
				raise "ERROR: Could not create the stream file (#{path})"
			end

			File.exist?(path) && path
		end

		alias deleteStream deleteTempFile

		##
		# Library Methods
		##

		def usePlaylist(name, append = false)
			@playlistName = name
			tracks = []

			@library['playlists'][@playlistName]['tracks'].each do |trackReference|
				tracks << @library['library'][trackReference]
			end

			useTracks tracks, append
		end

		def useEntireLibrary
			tracks = []

			@library['library'].keys.each do |trackKey|
				tracks << @library['library'][trackKey]
			end

			useTracks tracks, false
		end

		def processLibraryJSON(json)
			{
				:json => json,
				:hash => Digest::MD5.digest(json),
				:data => JSON.parse(json)
			}
		end

		def loadLibrary
			libraryInfo = processLibraryJSON File.read(@libraryFilePath)
			if libraryInfo
				@library = libraryInfo[:data]
				@libraryHash = libraryInfo[:hash]
			end
		end

		def writeLibraryToFile forceWritable = nil
			if !forceWritable && !@writeEnabled
				return if forceWritable == false || !confirm("Write changes to library?")
			end
			libraryJSON = JSON.pretty_generate(@library)
			libraryOnFile = processLibraryJSON File.read(@libraryFilePath)
			if @libraryHash == libraryOnFile[:hash] || confirm("Library file has changed since last load. Overwrite?")
				libraryInfo = processLibraryJSON libraryJSON
				File.write(@libraryFilePath, libraryJSON)
				@libraryHash = libraryInfo[:hash]
				puts "Saved change to library file."
			end
		end

		def removeTrackFromLibrary(id)
			@library['library'].delete id
			@library['playlists'].each { |playlistName, p|
				index = p['tracks'].index id
				if index
					p['tracks'].delete_at index
				end
			}
			@library['tags'].each { |tagName, t|
				index = t['tracks'].index id
				if index
					t['tracks'].delete_at index
				end
			}
		end

		def interactiveCleanup
			cleanupSelection = {}

			commands = {
				'ul' => {
					'info' => '"unlisted", select all tracks not in any playlist',
					'action' => Proc.new {

						unattachedTracks = {}

						@library['library'].map { |id, t| unattachedTracks[id] = t }

						@library['playlists'].each do |name, playlist|
							playlist['tracks'].each do |id|
								unattachedTracks.delete id if unattachedTracks.has_key? id
							end
						end

						if unattachedTracks.length > 0
							unattachedTracks.each { |id, track| cleanupSelection[id] = track }
							puts "#{listTrackTitles cleanupSelection}\n\n(#{cleanupSelection.length} tracks selected)"
						else
							puts "Every track is assigned to a playlist. No suggestions for cleanup."
						end

					}
				},
				'all' => {
					'info' => 'select all tracks in the library',
					'action' => Proc.new {
						cleanupSelection = cloneLibrary @library['library']
						puts "All tracks selected (#{cleanupSelection.length})"
					}
				},
				'add' => {
					'info' => '<playlistName> add selection to a playlist.',
					'action' => Proc.new { |playlistQuery|
						if playlistQuery && playlistQuery.length > 0
							playlistName = findPlaylistName playlistQuery

							if playlistName
								cleanupSelection.keys.each { |id| addTrackReferenceToPlaylist id, playlistName }
							elsif confirm "No existing playlist matching '#{playlistQuery}'. Create one?"
								createPlaylist playlistQuery, cleanupSelection.keys
							else
								playlistName = nil
							end

							if playlistName
								cleanupSelection = {}
								puts "Added #{cleanupSelection.length} tracks to playlist '#{playlistName}'"
							else
								puts "No change"
							end
						else
							puts "#{@library['playlists'].map { |name, p| name } .join "\n"}\n\nPlease specify a playlist name (new or existing)."
						end
					}
				},
				'keep' => {
					'info' => "#{Player::FILTER_HELP_1}\n#{Player::FILTER_HELP_2}\n#{Player::FILTER_HELP_3}",
					'action' => Proc.new { |filterString|
						cleanupSelection = cloneLibrary @library['library'] if cleanupSelection.length == 0
						# FIXME: lots of back and forth from arrays to hashes here. Want to pick one?
						cleanupSelection = cloneTracksToLibrary filterTracks cloneLibraryToTracks(cleanupSelection), parseOptionParameters(filterString)
						puts "#{cleanupSelection.length} tracks selected"
					}
				},
				'drop' => {
					'info' => "Excludes tracks matching the rules. #{Player::FILTER_HELP_1}\n#{Player::FILTER_HELP_2}",
					'action' => Proc.new { |filterString|
						cleanupSelection = cloneLibrary @library['library'] if cleanupSelection.length == 0
						# FIXME: lots of back and forth from arrays to hashes here. Want to pick one?
						cleanupSelection = cloneTracksToLibrary filterTracks cloneLibraryToTracks(cleanupSelection), parseOptionParameters(filterString), true
						puts "#{cleanupSelection.length} tracks selected"
					}
				},
				'edit' => {
					'info' => 'edit selection in Vim',
					'action' => Proc.new {
						whisper "FIXME: this may be broken, while listTrackTitles and getTracksFromTitleList are changing for interactive use"
						cleanupSelection = getTracksFromTitleList editListInVim(listTrackTitles(cleanupSelection), "remove or comment any tracks you want to deselect")
						puts "#{listTrackTitles(cleanupSelection).join "\n"}\n\n(#{cleanupSelection.length} tracks selected)"
					}
				},
				'clear' => {
					'info' => 'clear the selection',
					'action' => Proc.new {
						cleanupSelection = {}
						puts "0 tracks selected"
					}
				},
				'rm' => {
					'info' => 'remove selected tracks',
					'action' => Proc.new {
						initialLibraryLength = @library['library'].length
						cleanupSelection.each do |id, track|
							removeTrackFromLibrary id
						end
						checksum = initialLibraryLength - cleanupSelection.length == @library['library'].length
						checksumString = "#{initialLibraryLength} - #{cleanupSelection.length} == #{@library['library'].length}"
						puts "#{checksumString} ... #{checksum ? 'OK' : 'Mismatch'}"
						cleanupSelection = {}
					}
				},
				'jointag' => {
					'info' => '<playlistName> remove a playlist.',
					'action' => Proc.new { |tagsString|
						success = false

						if tagsString.length > 0
							tags = tagsString.split(Player::TAG_INPUT_SPLIT)
							if tags.length > 1
								success = combineTags tags
							else
								puts "Please give at least two tags."
							end
						end

						puts "Tags: \n  #{@library['tags'].keys.sort.join(", ")}" if not success
					}
				},
				'rmfile' => {
					'info' => 'Remove files not referenced in the library.',
					'action' => Proc.new {
						filesToDelete = []
						filesToIgnore = ['.', '..']
						Dir.entries(@fileDirectory).each { |file|
							if !filesToIgnore.include? file
								id = getIdFromFileName file
								if !id || !@library['library'][id]
									filesToDelete << file
								end
							end
						}
						if filesToDelete.length > 0
							filesToDelete = editListInVim filesToDelete, "remove any files you don't want to delete"

							filesToDelete.each { |file|
								File.delete "#{@fileDirectory}/#{file.chomp}"
							}
							puts "#{filesToDelete.length} files deleted."
						else
							puts "No orphaned files found."
						end
					}
				},
				'rmlist' => {
					'info' => '<playlistName> remove a playlist.',
					'action' => Proc.new { |playlistQuery|
						if playlistQuery && playlistQuery.length > 0
							playlistName = findPlaylistName playlistQuery

							if playlistName
								@library['playlists'].delete playlistName
								puts "removed playlist #{playlistName}"
							end

						else
							puts "#{@library['playlists'].map { |name, p| name } .join "\n"}\n\nPlease specify a playlist name (new or existing)."
						end
					}
				}
			}

			confirmMsg = "Choose a command, or \"y\" to write changes to file"
			if confirm confirmMsg, commands
				writeLibraryToFile true
			else
				puts "No changes saved."
			end

			puts "Cleanup finished."
		end

		def determineRelativeSpeed input, track
			relativeSpeed = input.to_f
			if input.to_s.match /bpm$/
				if track.has_key? 'bpm'
					inputBPM = relativeSpeed
					relativeSpeed = inputBPM / track['bpm']
				else
					relativeSpeed = nil
				end
			end
			relativeSpeed
		end

		def matchPropertyWithRangeString rangeString, hash, property
			rangeParts = " #{rangeString} ".split('-')
			isAMatch = false
			if hash.has_key? property
				if rangeParts.length == 2
					lowerMatch = rangeParts[0] == " " || hash[property] >= rangeParts[0].to_i
					upperMatch = rangeParts[1] == " " || hash[property] <= rangeParts[1].to_i
					isAMatch = lowerMatch && upperMatch
				else
					isAMatch = rangeParts[0].to_i == hash[property].to_i
				end
			end
			isAMatch
		end

		def filterTracks tracks, filters, isExcludeFilter = false
			whisper 'filterTracks'
			action = isExcludeFilter ? 'delete_if' : 'keep_if'

			if filters.has_key? 'rating'
				if filters['rating'] && filters['rating'].length > 0
					tracks.send(action) { |t|
						matchPropertyWithRangeString filters['rating'], t, 'rating'
					}
				else
					tracks.send(action) { |t| t.has_key? 'rating' }
				end
			end

			if filters.has_key? 'tag'
				if filters['tag']
					# TODO: add a tag fuzzy factor: include tags of tracks that have the current tag (only 1 degree separation to start)
					selectedTags = []
					unionTagTracks = []
					filters['tag'].split(' ').each { |tagName|
						unionPattern = /^\+/
						isUnionTag = tagName.match unionPattern
						tagName.sub!(unionPattern, '') if isUnionTag
						if @library['tags'][tagName]
							selectedTags << {:name => tagName, :tag => @library['tags'][tagName], :union => isUnionTag}
							if isUnionTag
								unionTagTracks += @library['tags'][tagName]['tracks'];
							end
						else
							@library['tags'].each { |name, libraryTag|
								if libraryTag['aliases']
									libraryTag['aliases'].each { |tagAlias|
										if tagAlias == tagName
											selectedTags << {:name => name, :tag => libraryTag, :union => isUnionTag}
											if isUnionTag
												unionTagTracks += @library['tags'][tagName]['tracks'];
											end
										end
									}
								end
							}
						end
					}

					if selectedTags.length > 0
						# TODO: make a list of IDs and filter tracks against it once, rather than filtering separately for each tag
						selectedTags.each { |tagInfo|
							foundTagName = "\"#{tagInfo[:name]}\""
							if tagInfo[:tag]['aliases'] && tagInfo[:tag]['aliases'].length > 0
								foundTagName = "#{foundTagName} (aliases \"#{tagInfo[:tag]['aliases'].join '", "'}\")"
							end
							tracks.send(action) { |t| tagInfo[:tag]['tracks'].index(t['id']) || unionTagTracks.index(t['id']) }
						}

						if unionTagTracks.length > 0
							tracks.sort! { |a, b| unionTagTracks.count(b['id']) <=> unionTagTracks.count(a['id']) }
						end
					else
						puts "No matches for \"#{filters['tag']}\". Available tags are: #{listAllTagsWithAliases.join ", "}"
					end
				else
					@library['tags'].each { |name, libraryTag|
						tracks.send(action) { |t|
							libraryTag['tracks'].index(t['id'])
						}
					}
				end
			end

			if filters.has_key? 'bpm'
				if filters['bpm'] && filters['bpm'].length > 0
					tracks.send(action) { |t|
						matchPropertyWithRangeString filters['bpm'], t, 'bpm'
					}
				else
					tracks.send(action) { |t| t.has_key? 'bpm' }
				end
			end

			if filters['title']
				matches = fuzzyStringSearchInList(filters['title'], getTrackTitles(tracks))
				matches.sort! { |a,b| b[:density] <=> a[:density] }
				matchedIds = []
				matchesByTrackTitle = {}
				matches.each { |match|
					track = tracks[match[:index]]
					matchedIds << track['id']
					matchesByTrackTitle[track['title']] = match
				}
				tracks.send(action) { |t| matchedIds.include? t['id'] }
				if !isExcludeFilter
					tracks.sort! { |a,b| matchesByTrackTitle[b['title']][:density] <=> matchesByTrackTitle[a['title']][:density] }
				end
			end

			if filters['last']
				now = Time.now.to_i
				watershed = now - getSecondsFromDurationString(filters['last']).to_i
				tracks.send(action) { |t|
					t['lastPlayed'] ? t['lastPlayed'].to_i >= watershed : false
				}
			end

			if filters['min-duration']
				minDuration = getSecondsFromDurationString filters['min-duration']
				tracks.send(action) { |t|
					t['duration'] ? getSecondsFromDurationString(t['duration']) > minDuration : false
				}
			end

			if filters.has_key? 'chapters'
				tracks.send(action) { |track|
					if track
						track.has_key? 'chapters'
					else
						false
					end
				}
			end

			puts "#{tracks.length} matches for filters"

			tracks
		end

		def listAllTagsWithAliases
			allTagNames = []

			@library['tags'].each { |name, libraryTag|
				allTagNames << name
				if libraryTag['aliases']
					libraryTag['aliases'].each { |tagAlias| allTagNames << tagAlias }
				end
			}

			allTagNames.sort
		end

		def createPlaylist name, tracks = [], description = ''
			newPlaylist = {
				'description' => description,
				'public' => true,
				'tracks' => tracks
			}
			@library['playlists'][name] = newPlaylist
		end

		def createTrack url, type = 'youtube'
			if type == 'youtube'
				src = looksLikeAYouTubeID?(url) ? url : getYoutubeIdFromUrl(url)
				id = src
			elsif type == 'ocremix'
				src = getOCRemixSource url
				id = getIDFromOCRemixURL url
			end
			{
				'id' => id,
				'type' => type,
				'src' => src,
				'unattached' => true
			}
		end

		def getTrackInfo id
			rawInfo = `youtube-dl --get-title --get-description --get-duration -- #{id} 2>/dev/null` # suppress errors
			return false if !rawInfo || rawInfo.length == 0

			lines = rawInfo.chomp.lines
			track = {
				'title' => lines.shift.chomp, # first line
				'duration' => lines.pop.chomp, # last line
				'description' => lines.join("\n").chomp, # everything else
				'url' => "http://youtu.be/#{id}" # youtube-only URL
			}

			track
		end

		def updateTrackInfo track, trackInfo = nil
			trackInfo ||= getTrackInfo track['id']
			return false if !trackInfo

			track['title'] = trackInfo['title']

			if trackInfo['description']
				chapters = getChaptersFromDescription trackInfo['description'].lines
				track['chapters'] = chapters if chapters && chapters.length > 0
			end

			track['duration'] = trackInfo['duration'] if trackInfo['duration']

			track
		end

		def getChaptersFromDescription description
			description.grep(/[0-9]+:[0-9:.]+/).map! do |line|
				matches = line.match(/^(.*?)[ (]*([0-9]+:[0-9:.]+)[ )]*(.*)$/)
				{
					'time' => matches[2],
					'name' => "#{matches[1]} #{matches[3]}".gsub(/^[^0-z]/, '').strip
				}
			end
		end

		def addTrackToLibrary track
			track.delete 'unattached' if track.has_key? 'unattached'
			trackReference = track['id']
			@library['library'][trackReference] ||= track

			trackReference
		end

		def addTrackReferenceToPlaylist trackReference, playlistName
			playlistTracks = @library['playlists'][playlistName]['tracks']
			track = @library['library'][trackReference]

			if not playlistTracks.include? trackReference
				playlistTracks << trackReference
				puts "Saved '#{track['title']}' (#{trackReference}) to playlist '#{playlistName}'"
			else
				puts "Track '#{track['title']}' (#{trackReference}) is already in playlist '#{playlistName}'"
			end
		end

		##
		# YouTube Methods
		##

		def looksLikeAYouTubeID? string
			youtubeIdPattern = /^[A-Za-z0-9_-]+$/
			!! string.match(youtubeIdPattern)
		end

		def getYoutubeIdFromUrl url
			youtubeIDInURLPattern = /^.*youtu(\.be\/|be\.com.*v=)([^&\/]+)/
			matches = url.match(youtubeIDInURLPattern)
			matches ? matches[2] : false
		end

		def searchYouTube query, offset = 0, count = 20
			# FIXME: sometimes the STDIN is not editable after this
			puts "Searching YouTube for '#{query}'"
			resultsPerPage = 20
			page = (offset.to_f / resultsPerPage.to_f).to_i + 1
			queryParameter = URI::encode(query)
			queryUrl="https://www.youtube.com/results?search_query=#{queryParameter}&page=#{page}"
			getYouTubeTracksFromPage queryUrl
		end

		def getValidYouTubeURI uri
			looksLikeAYouTubeID?(uri) ? "https://www.youtube.com/watch?v=#{uri}" : uri
		end

		def getYouTubeTracksFromPage url
			url = getValidYouTubeURI url
			queryResultIds = []
			whisper "reading URL #{url}"
			open(url) do |handle|
				whisper "received URL #{url}"
				html = []
				handle.each_line { |line| html << line }

				queryResultIds = html.grep(/href="(.*youtube.*)?\/watch/).map! do |line|
					line.sub!(/^.*watch\?v=([^\"&<]+).*\n/, '\1')
				end

				queryResultIds.uniq!
			end

			threads = []
			resultTracks = []
			receivedCount = 0
			printRepeat "Getting track information (#{receivedCount}/#{queryResultIds.length})"

			queryResultIds.each_with_index do |id, index|
				track = matchExistingLibraryTrack createTrack id, 'youtube'
				resultTracks << track
				whisper "starting a new thread to get track info for #{track['id']}"
				threads << Thread.new {
					if not updateTrackInfo track
						resultTracks.delete track
					end
					receivedCount += 1
					printRepeat "Getting track information (#{receivedCount}/#{queryResultIds.length})"
				}
			end

			whisper "joining 'update info' threads"
			threads.each { |thr| thr.join }
			print "\n"

			resultTracks
		end

		def getOCRemixSource(url)
			source = nil

			open(url) do |handle|
				sourcePattern = /^.*href="(https?:\/\/ocrmirror.org[^"]+)".*$/
				sourceLine = handle.lines.grep(sourcePattern)
				if sourceLine && sourceLine.length > 0
					match = sourceLine[0].match sourcePattern
					source = match[1]
					whisper "source: #{source}"
				end
			end

			source
		end

		def getIDFromOCRemixURL(url)
			url.sub(/^.*\/remix\/([^\/?]+).*/, '\1')
		end

		##
		# Utility Methods
		##

		def getSecondsFromDurationString durationString
			seconds = 0
			factor = 1
			factors = [1,60,60,24]

			if durationString && durationString.length > 0
				durationString.split(':').reverse.each_with_index { |unit, index|
					factor *= factors[index]
					seconds += unit.to_f * factor
				}
			end

			seconds
		end

		##
		# UI Methods
		##

		def parseOptions
			output = {}

			parser = OptionParser.new

			parser.on("-a", "--add-track YOUTUBE_URLS", "Add tracks to the library, and to a playlist, if specified. Takes a comma-separated list of YouTube URLs or IDs.", " ") do |urls|
				output[:newTracks] = []
				urls.split(',').each { |url|
					if url.match(/ocremix\.org\/remix/)
						output[:newTracks] << createTrack(url, 'ocremix')
						puts "This URL contains an OC Remix ID. Adding."
					elsif looksLikeAYouTubeID? url
						youtubeId = url
					else
						youtubeId = getYoutubeIdFromUrl url
					end

          if youtubeId
            output[:newTracks] << updateTrackInfo(createTrack(youtubeId, 'youtube'))
            puts "This URL contains a YouTube ID. Adding."
          end

					if confirm "Look for all tracks on this page?"
						output[:newTracks].concat getYouTubeTracksFromPage url
					end
				}
			end

			parser.on("-c", "--clean", "Enter an interactive cleanup mode, to remove unwanted items from the library.", " ") do
				output[:interactiveCleanup] = true
			end

			parser.on("-d", "--[keep-]download", "Enable downloading files when encountering a playlist file without a cached file already download.", "Files not added to the library will be deleted after playback, unless --keep-download is used.", " ") do |keep|
				@enableDownload = true
				@keepUnattachedDownload = keep
			end

			parser.on("-f", "--filter RULES", Player::FILTER_HELP_1, Player::FILTER_HELP_2, Player::FILTER_HELP_3, " ") do |rules|
				@trackFilters = parseOptionParameters rules
			end

			parser.on("-h", "--help", "Show this help.", " ") do
				puts parser.help()
				exit
			end

			parser.on("-l", "--loop", "Loop, even if a track doesn't have an A/B loop defined.", " ") do
				@loop = true
			end

			parser.on("-p", "--playlist [NAME]", "Choose or create a playlist. If no NAME/QUERY is given, a name is guessed from other input, such as a -q query", " ") do |playlistQuery|
				output[:playlistQuery] = playlistQuery
			end

			parser.on("-q", "--query QUERY", "Search YouTube for a video.", " ") do |query|
				@youtubeSearch = query
			end

			parser.on("-r", "--rating-prompt [SECONDS]", "Prompt for a rating and tags after every track plays, waiting 5 (or the number given) seconds before continuing to the next track", " ") do |seconds|
				@ratingsPromptDuration = seconds ? seconds.to_i : 5
			end

			parser.on("-s", "--shuffle", "Enable shuffle.", " ") do
				@shuffle = true
			end

			parser.on("-t", "--track INDEX/QUERY", "Seek to the given track (either by its number in the list, or by its name).", " ") do |trackQuery|
				if trackQuery.to_i != 0
					@trackIndex = trackQuery.to_i - 1
				else
					@trackIndex = trackQuery
				end
			end

			parser.on("-v", "--verbose", "Chatter about what's going on", " ") do
				@verbose = true
			end

			parser.on("-w", "--write [SECONDS]", "Save changes to the library. If SECONDS are given, only tracks played that many seconds will be written.", " ") do |seconds|
				@writeEnabled = true
				@writeAfterSecondsPlayed = seconds ? seconds.to_f : 0.0
			end

			parser.on("-x", "--exclude-filter RULES", "Excludes tracks matching the rules. See --filter", " ") do |rules|
				@trackExcludeFilters = parseOptionParameters rules
			end

			parser.on("--input-dir DIR", "Directory from which to read the playlist and files.", "NOTE: when used, this must be the first option. Recommended to define TUNEWICH_DIR instead.", " ") do |inputDir|
				# FIXME: always process this option first, even if it's provided last
				setLibraryPath inputDir
			end

			parser.on("--no-network", "Don't fetch any information or media from the internet. Use only local files.", " ") do
				@noNetwork = true
			end

			parser.on("--format FORMAT", "Set the file format to request for streaming or downloading.", " ") do |format|
				@preferredFileFormat = format
			end

			parser.on("--update-track-info", "Fetch updated track information for every track played.", " ") do
				@updateAllPlayedTrackInfo = true
			end

			@mplayerOverrideCommands = parser.parse(ARGV)

			output
		end

		def doOptionSecondaryActions optionsOutput

			if not @fileDirectory
				puts "please specify an input directory with -i"
				exit
			end

			if @youtubeSearch && !@noNetwork
				@youtubeSearchPage = 1
				useTracks searchYouTube @youtubeSearch
			end

			if optionsOutput.has_key? :interactiveCleanup
				interactiveCleanup
				exit
			end

			if optionsOutput.has_key? :playlistQuery
				if optionsOutput[:playlistQuery]
					match = firstFuzzyMatch optionsOutput[:playlistQuery], @library['playlists'].keys

					if match && match[:score] > 1 # FIXME: what's a good baseline score for a playlist match?
						playlistName = match[:value]
					elsif confirm("Create new playlist #{optionsOutput[:playlistQuery]}?")
						playlistName = optionsOutput[:playlistQuery]
					end
				elsif @youtubeSearch
					playlistName = @youtubeSearch
				end

				if playlistName
					if not @library['playlists'].has_key? playlistName
						puts "Creating new playlist: #{playlistName}"
						createPlaylist playlistName
						writeLibraryToFile
					end

					usePlaylist playlistName, true
				end
			end

			if optionsOutput.has_key? :newTracks
				optionsOutput[:newTracks].each { |newTrack|
					if 0 == @writeAfterSecondsPlayed
						trackReference = addTrackToLibrary newTrack
						addTrackReferenceToPlaylist trackReference, @playlistName if @playlistName
					end
					@tracks << newTrack
				}
				writeLibraryToFile false
			end
		end

		def encodeOptionParameters hash
			clumps = []
			hash.each { |key, value|
				clumps << "#{key}=#{value}"
			}
			clumps.join ','
		end

		def parseOptionParameters serialized
			hash = {}
			# TODO: parse normal & negated options from one list
			# hash = {
			# 	:normal => [],
			# 	:negate => []
			# }

			serialized.split(',').each { |clump|
				pair = clump.split '='
				hash[pair[0]] = pair[1]
			}

			hash
		end

		def printRepeat message
			print "  #{" " * @printRepeatMessage.length}\r" if @printRepeatMessage
			message = message.to_s if message.respond_to? 'to_s'
			print "  #{message}\r"
			@printRepeatMessage = message.match(/\n/) ? nil : message
		end

		def cliRotate
			if not @cliRotateIndex
				@cliRotateIndex = 0
				@cliRotateCharacters = ['==', '\\\\', '||', '//']
			else
				@cliRotateIndex = (@cliRotateIndex + 1) % @cliRotateCharacters.length
			end

			@cliRotateCharacters[@cliRotateIndex]
		end

		def editListInVim list, instructions = nil
			instructions ||= "edit"
			fileDirections = "##\n#{instructions.gsub(/^/, '# ')}\n##\n\n"

			editListName = 'edit-list'
			deleteTempFile editListName
			putInTempFile editListName, fileDirections + list.join("\n")

			system "vim #{getTempFilePath editListName}"

			list = readTempFile(editListName).strip.lines
			list.delete_if { |line| # remove empty and comment lines from the list
				line.match(/^(#.*|\s*)$/)
			}

			deleteTempFile editListName

			list
		end

		def commandPrompt message = nil, commands = nil, action = nil
			whisper "opening command prompt"
			if commands
				commands['?'] = {
					'info' => 'show this info',
					'action' => Proc.new {
						commandInfo = []
						maxCommandNameLength = 0
						commands.each { |name, set|
							maxCommandNameLength = name.length if name.length > maxCommandNameLength
						}
						commands.each { |name, set|
							info = "/#{name}"
							info += " " * (maxCommandNameLength - info.length + 1)
							info += " : #{set['info']}" if set['info']
							commandInfo << info
						}
						puts commandInfo.join "\n"
					}
				}
			end

			prompt = Proc.new {
				print "#{message} " if message
				print "$ "
			}
			prompt.call

			response = {
				:input => nil,
				:commands => []
			}

			whisper "waiting for user input on STDIN"
			while input = STDIN.gets.chomp
				whisper "received STDIN: #{input}"
				while commands && !input.empty? && input[0] == '/'
					whisper "inside command while loop" # XXX
					commandParts = input.match(/^\/([^\s]+)\s*(.*)/)
					commandName = commandParts[1]
					commandArgs = commandParts[2]

					if commands[commandName]
						commandInfo = {
							:name => commandName,
							:args => commandArgs,
							:output => commands[commandName]['action'].call(commandArgs)
						}
						response[:commands] << commandInfo
						whisper "command info: #{commandInfo}" # XXX
						if commandInfo[:output] && commandInfo[:output][:chainedInput] && commandInfo[:output][:chainedInput].length > 0
							whisper "chained input: #{commandInfo[:output][:chainedInput]}" # XXX
							input = commandInfo[:output][:chainedInput]
						else
							whisper "no chained input" # XXX
							input = nil
							break
						end
					else
						puts "Invalid command '#{commandName}'; available commands: #{commands.keys.join ', '}"
						break
					end
				end
				whisper "end command while loop" # XXX

				if action
					if input && input.length > 0
						actionResult = action.call input
						if not actionResult
							whisper "command returned false; interrupting input loop"
							break
						end
					end
				else
					whisper "command done, no action to take, breaking command loop"
					break
				end

				prompt.call
			end

			response[:input] = input
			whisper "closing command prompt (response #{response})"

			response
		end

		def confirm message, commands = nil
			confirmMessage = "#{message} (y/N): "
			commandPrompt(confirmMessage, commands)[:input].match(/^[Yy]/)
		end

		def timedTextPrompt timeout, message = nil, commands = nil
			input = nil

			thr = Thread.new {
				input = STDIN.gets.chomp
				# input = commandPrompt message, commands # doesn't keep the thread alive...
			}

			timer = 0
			while thr.alive?
				printRepeat "(#{timeout - timer}) #{message}"
				sleep 1
				timer += 1
				if timer >= timeout
					input = nil
					Thread.kill thr
				end
			end

			input
		end

		def promptForPlaylist
			puts "Please choose a playlist (leave blank to play all):\n  #{@library['playlists'].keys.join "\n  "}"
			selectedListName = nil
			while !selectedListName do
				playlistQuery = commandPrompt[:input]

				if not playlistQuery or playlistQuery.length === 0
					useEntireLibrary
					break
				end

				selectedListName = findPlaylistName playlistQuery

				if not selectedListName
					puts "No matches. Try again"
				end

			end

			selectedListName
		end

		def promptForChapterIndex chapters, commands = nil, message = nil
			selectedChapterIndex = nil

			chapterList = chapters.map { |chapter| "#{chapter['time']} - #{chapter['name']}" }
			prePromptMessage = "  #{chapterList.join "\n  "}"
			prePromptMessage += "\n#{message}" if message
			promptMessage = "Please choose a chapter (leave blank to play first):"

			while not selectedChapterIndex do
				puts prePromptMessage
				chapterQuery = timedTextPrompt Player::CHAPTER_SELECT_TIMEOUT, promptMessage, commands
				break if not chapterQuery or chapterQuery.length === 0

				selectedChapter = firstFuzzyMatch chapterQuery, chapterList

				if selectedChapter
					selectedChapterIndex = selectedChapter[:index]
					break
				else
					puts "No matches. Try again."
				end

			end

			{
				:index => selectedChapterIndex
			}
		end

		def listTrackTitles(tracks)
			tracks.map { |t| "#{t['title']} [#{t['id']}]" }
		end

		def getTracksFromTitleList(titleList)
			tracks = []
			titleList.each { |line|
				matches = line.match(/^(.*) \[(.*)\]$/)
				if matches
					track = matchExistingLibraryTrack createTrack matches[2], 'youtube'
					track['title'] ||= matches[1]
					tracks << track if track
				end
			}

			tracks
		end

		def cloneTracks inputTracks
			tracks = []
			inputTracks.each { |id, t| tracks <<  t }
			tracks
		end

		def cloneLibraryToTracks inputLibrary
			tracks = []
			inputLibrary.each { |id, t| tracks << t }
			tracks
		end

		def cloneLibrary inputLibrary
			library = {}
			inputLibrary.each { |id, t| library[t['id']] = t }
			library
		end

		def cloneTracksToLibrary inputTracks
			library = {}
			inputTracks.each { |t| library[t['id']] = t }
			library
		end

	end

end

Tunewich::Player.new
